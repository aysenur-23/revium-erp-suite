[{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\driveService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":16,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[510,513],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[510,513],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Google Drive Service - Firebase Authentication Entegrasyonu\n * Firebase Authentication ile giriş yapıldığında Google Access Token kullanır\n * Ayrı OAuth flow'a gerek yok\n */\n\nimport { auth } from \"@/lib/firebase\";\nimport { GoogleAuthProvider, signInWithPopup, getAdditionalUserInfo } from \"firebase/auth\";\n\nexport type DriveUploadType = \"report\" | \"task\" | \"general\";\n\nexport interface DriveUploadOptions {\n  fileName?: string;\n  type?: DriveUploadType;\n  folderId?: string;\n  metadata?: Record<string, any>;\n  makePublic?: boolean;\n}\n\nexport interface DriveUploadResponse {\n  success: boolean;\n  fileId: string;\n  webViewLink?: string;\n  webContentLink?: string;\n}\n\n// Token storage key\nconst DRIVE_TOKEN_KEY = \"revium_drive_token\";\nconst DRIVE_TOKEN_EXPIRY_KEY = \"revium_drive_token_expiry\";\n\n/**\n * Firebase Authentication'dan Google Access Token al\n */\nconst getGoogleAccessToken = async (): Promise<string> => {\n  if (!auth?.currentUser) {\n    throw new Error(\"Kullanıcı giriş yapmamış. Lütfen önce giriş yapın.\");\n  }\n\n  const user = auth.currentUser;\n  \n  // Kullanıcı Google provider ile giriş yapmış mı kontrol et\n  const isGoogleProvider = user.providerData.some(\n    (provider) => provider.providerId === \"google.com\"\n  );\n\n  if (!isGoogleProvider) {\n    // Google provider ile giriş yapılmamış, Google ile bağlan\n    const provider = new GoogleAuthProvider();\n    provider.addScope(\"https://www.googleapis.com/auth/drive.file\");\n    \n    try {\n      const credential = await signInWithPopup(auth, provider);\n      const oauthCredential = GoogleAuthProvider.credentialFromResult(credential);\n      \n      if (!oauthCredential?.accessToken) {\n        throw new Error(\"Google Drive erişim token'ı alınamadı\");\n      }\n\n      // Token'ı kaydet\n      const expiresIn = 3600; // 1 saat\n      saveToken(oauthCredential.accessToken, expiresIn);\n      \n      return oauthCredential.accessToken;\n    } catch (error: unknown) {\n      if (import.meta.env.DEV) {\n        if (import.meta.env.DEV) {\n          console.error(\"Google token alma hatası:\", error);\n        }\n      }\n      \n      if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === \"auth/popup-closed-by-user\") {\n        throw new Error(\"Google bağlantısı iptal edildi.\");\n      }\n      \n      throw new Error(error instanceof Error ? error.message : \"Google token alınamadı\");\n    }\n  }\n\n  // Google provider ile giriş yapılmış, mevcut token'ı kullan\n  // Firebase Authentication'dan Google Access Token almak için\n  // kullanıcının ID token'ını kullanarak Google OAuth token'ı alabiliriz\n  // Ancak bu mümkün değil, bu yüzden kullanıcıyı yeniden Google ile giriş yapmaya yönlendirmeliyiz\n  // Ya da stored token'ı kullan\n  \n  // Stored token yoksa, kullanıcıyı Google ile yeniden giriş yapmaya yönlendir\n  const storedToken = getStoredToken();\n  if (!storedToken) {\n    // Token yok, kullanıcıyı Google ile bağlanmaya yönlendir\n    const provider = new GoogleAuthProvider();\n    provider.addScope(\"https://www.googleapis.com/auth/drive.file\");\n    \n    try {\n      const credential = await signInWithPopup(auth, provider);\n      const oauthCredential = GoogleAuthProvider.credentialFromResult(credential);\n      \n      if (!oauthCredential?.accessToken) {\n        throw new Error(\"Google Drive erişim token'ı alınamadı\");\n      }\n\n      // Token'ı kaydet\n      const expiresIn = 3600; // 1 saat\n      saveToken(oauthCredential.accessToken, expiresIn);\n      \n      return oauthCredential.accessToken;\n    } catch (error: unknown) {\n      if (import.meta.env.DEV) {\n        if (import.meta.env.DEV) {\n          console.error(\"Google token alma hatası:\", error);\n        }\n      }\n      \n      if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === \"auth/popup-closed-by-user\") {\n        throw new Error(\"Google bağlantısı iptal edildi.\");\n      }\n      \n      throw new Error(error instanceof Error ? error.message : \"Google token alınamadı\");\n    }\n  }\n\n  return storedToken;\n};\n\n/**\n * Access token'ı localStorage'a kaydet\n */\nconst saveToken = (token: string, expiresIn: number): void => {\n  const expiryTime = Date.now() + expiresIn * 1000;\n  localStorage.setItem(DRIVE_TOKEN_KEY, token);\n  localStorage.setItem(DRIVE_TOKEN_EXPIRY_KEY, expiryTime.toString());\n};\n\n/**\n * Access token'ı localStorage'dan al\n */\nconst getStoredToken = (): string | null => {\n  const token = localStorage.getItem(DRIVE_TOKEN_KEY);\n  const expiry = localStorage.getItem(DRIVE_TOKEN_EXPIRY_KEY);\n\n  if (!token || !expiry) {\n    return null;\n  }\n\n  // Token süresi dolmuş mu kontrol et\n  if (Date.now() > parseInt(expiry, 10)) {\n    localStorage.removeItem(DRIVE_TOKEN_KEY);\n    localStorage.removeItem(DRIVE_TOKEN_EXPIRY_KEY);\n    return null;\n  }\n\n  return token;\n};\n\n/**\n * Access token'ı al veya yenile\n */\nconst getAccessToken = async (): Promise<string> => {\n  // Önce stored token'ı kontrol et\n  const storedToken = getStoredToken();\n  if (storedToken) {\n    return storedToken;\n  }\n\n  // Yeni token al (Firebase Authentication'dan)\n  return await getGoogleAccessToken();\n};\n\n/**\n * Kullanıcıyı Google Drive'a yetkilendir (Google ile giriş)\n */\nexport const authorizeDrive = async (): Promise<boolean> => {\n  try {\n    if (!auth) {\n      throw new Error(\"Firebase Authentication başlatılmamış\");\n    }\n\n    const provider = new GoogleAuthProvider();\n    provider.addScope(\"https://www.googleapis.com/auth/drive.file\");\n    \n    const credential = await signInWithPopup(auth, provider);\n    const oauthCredential = GoogleAuthProvider.credentialFromResult(credential);\n    \n    if (!oauthCredential?.accessToken) {\n      throw new Error(\"Google Drive erişim token'ı alınamadı\");\n    }\n\n    // Token'ı kaydet\n    const expiresIn = 3600; // 1 saat\n    saveToken(oauthCredential.accessToken, expiresIn);\n    \n    return true;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Drive authorization error:\", error);\n      }\n    }\n    \n    if (error && typeof error === 'object' && 'code' in error && (error as { code: string }).code === \"auth/popup-closed-by-user\") {\n      throw new Error(\"Google bağlantısı iptal edildi.\");\n    }\n    \n    throw new Error(error?.message || \"Google Drive yetkilendirmesi başarısız oldu\");\n  }\n};\n\n/**\n * Kullanıcının Drive yetkilendirmesi var mı kontrol et\n */\nexport const isDriveAuthorized = async (): Promise<boolean> => {\n  try {\n    // Token var mı kontrol et\n    const token = getStoredToken();\n    if (token) {\n      return true;\n    }\n\n    // Kullanıcı Google provider ile giriş yapmış mı kontrol et\n    if (auth?.currentUser) {\n      const isGoogleProvider = auth.currentUser.providerData.some(\n        (provider) => provider.providerId === \"google.com\"\n      );\n      return isGoogleProvider;\n    }\n\n    return false;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Drive yetkilendirmesini kaldır\n */\nexport const revokeDriveAccess = async (): Promise<void> => {\n  try {\n    localStorage.removeItem(DRIVE_TOKEN_KEY);\n    localStorage.removeItem(DRIVE_TOKEN_EXPIRY_KEY);\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Drive revoke error:\", error);\n    }\n  }\n};\n\n/**\n * Dosyayı Google Drive'a yükle\n */\nexport const uploadFileToDrive = async (\n  file: File | Blob,\n  options: DriveUploadOptions = {}\n): Promise<DriveUploadResponse> => {\n  try {\n    // Access token al\n    const accessToken = await getAccessToken();\n\n    // Dosyayı File'a çevir\n    const fileBlob = file instanceof File ? file : new File([file], options.fileName || \"file\", { type: file.type });\n\n    // Metadata oluştur\n    const metadata: Record<string, unknown> = {\n      name: options.fileName || fileBlob.name,\n      mimeType: fileBlob.type || \"application/octet-stream\",\n    };\n\n    // Klasör ID'si varsa ekle\n    if (options.folderId) {\n      metadata.parents = [options.folderId];\n    } else if (options.type === \"task\") {\n      const taskFolderId = import.meta.env.VITE_GOOGLE_DRIVE_TASKS_FOLDER_ID;\n      if (taskFolderId) {\n        metadata.parents = [taskFolderId];\n      }\n    } else if (options.type === \"report\") {\n      const reportFolderId = import.meta.env.VITE_GOOGLE_DRIVE_REPORTS_FOLDER_ID;\n      if (reportFolderId) {\n        metadata.parents = [reportFolderId];\n      }\n    }\n\n    // Metadata properties ekle\n    if (options.metadata) {\n      metadata.properties = options.metadata;\n    }\n\n    // Multipart upload için boundary oluştur\n    const boundary = \"----WebKitFormBoundary\" + Math.random().toString(36).substring(2);\n    const delimiter = \"\\r\\n--\" + boundary + \"\\r\\n\";\n    const closeDelimiter = \"\\r\\n--\" + boundary + \"--\";\n\n    // Multipart body oluştur (doğru format)\n    const metadataPart = `Content-Type: application/json; charset=UTF-8\\r\\n\\r\\n${JSON.stringify(metadata)}`;\n    const filePart = `Content-Type: ${fileBlob.type || \"application/octet-stream\"}\\r\\n\\r\\n`;\n\n    // File'ı ArrayBuffer'a çevir\n    const fileBuffer = await fileBlob.arrayBuffer();\n    const fileUint8 = new Uint8Array(fileBuffer);\n\n    // Multipart body'yi manuel oluştur (string + binary)\n    const textEncoder = new TextEncoder();\n    const parts: Uint8Array[] = [\n      textEncoder.encode(delimiter),\n      textEncoder.encode(metadataPart),\n      textEncoder.encode(delimiter),\n      textEncoder.encode(filePart),\n      fileUint8,\n      textEncoder.encode(closeDelimiter),\n    ];\n\n    // Tüm parçaları birleştir\n    const totalLength = parts.reduce((sum, part) => sum + part.length, 0);\n    const combined = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const part of parts) {\n      combined.set(part, offset);\n      offset += part.length;\n    }\n\n    // Body'yi Blob'a çevir\n    const bodyBlob = new Blob([combined], { type: `multipart/related; boundary=${boundary}` });\n\n    // Drive API'ye yükle\n    const response = await fetch(\"https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id,webViewLink,webContentLink\", {\n      method: \"POST\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n        \"Content-Type\": `multipart/related; boundary=${boundary}`,\n      },\n      body: bodyBlob,\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      let errorMessage = errorData.error?.message || \"Dosya yükleme başarısız oldu\";\n\n      if (response.status === 401) {\n        // Token geçersiz, temizle ve tekrar dene\n        localStorage.removeItem(DRIVE_TOKEN_KEY);\n        localStorage.removeItem(DRIVE_TOKEN_EXPIRY_KEY);\n        errorMessage = \"Yetkilendirme hatası. Lütfen tekrar deneyin.\";\n      } else if (response.status === 403) {\n        errorMessage = \"Google Drive izni yok. Lütfen yetkilendirme yapın.\";\n      } else if (response.status === 507) {\n        errorMessage = \"Google Drive depolama kotası dolmuş.\";\n      }\n\n      throw new Error(errorMessage);\n    }\n\n    const result = await response.json();\n\n    if (!result.id) {\n      throw new Error(\"Dosya yükleme başarısız oldu\");\n    }\n\n    const fileId = result.id;\n\n    // Public link isteniyorsa izin ver\n    if (options.makePublic !== false) {\n      try {\n        await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}/permissions`, {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${accessToken}`,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            role: \"reader\",\n            type: \"anyone\",\n          }),\n        });\n      } catch (permError) {\n        if (import.meta.env.DEV) {\n          console.warn(\"Public permission eklenemedi:\", permError);\n        }\n        // Public permission hatası dosya yüklemesini engellemez\n      }\n    }\n\n    // Web view link'i oluştur\n    const webViewLink = result.webViewLink || `https://drive.google.com/file/d/${fileId}/view`;\n\n    return {\n      success: true,\n      fileId: fileId,\n      webViewLink: webViewLink,\n      webContentLink: result.webContentLink,\n    };\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Drive upload error:\", error);\n    }\n\n    let errorMessage = \"Google Drive yüklemesi başarısız oldu\";\n\n    if (error?.message) {\n      errorMessage = error.message;\n    } else if (typeof error === \"string\") {\n      errorMessage = error;\n    }\n\n    // Özel hata mesajları\n    if (errorMessage.includes(\"auth\") || errorMessage.includes(\"unauthorized\") || errorMessage.includes(\"401\")) {\n      errorMessage = \"Google Drive yetkilendirmesi gerekli. Lütfen Google ile giriş yapın.\";\n    } else if (errorMessage.includes(\"quota\") || errorMessage.includes(\"storage\") || errorMessage.includes(\"507\")) {\n      errorMessage = \"Google Drive depolama kotası dolmuş. Lütfen depolama alanını kontrol edin.\";\n    } else if (errorMessage.includes(\"403\")) {\n      errorMessage = \"Google Drive izni yok. Lütfen Google ile giriş yapın.\";\n    }\n\n    throw new Error(errorMessage);\n  }\n};\n\n/**\n * Drive'dan dosya sil\n */\nexport const deleteDriveFile = async (fileId: string): Promise<void> => {\n  if (!fileId || fileId.trim() === \"\") {\n    throw new Error(\"Geçerli bir Drive dosya ID'si gerekli\");\n  }\n\n  try {\n    // Access token al\n    const accessToken = await getAccessToken();\n\n    const response = await fetch(`https://www.googleapis.com/drive/v3/files/${fileId}`, {\n      method: \"DELETE\",\n      headers: {\n        Authorization: `Bearer ${accessToken}`,\n      },\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json().catch(() => ({}));\n      let errorMessage = errorData.error?.message || \"Drive dosyası silinemedi\";\n\n      if (response.status === 401) {\n        // Token geçersiz, temizle\n        localStorage.removeItem(DRIVE_TOKEN_KEY);\n        localStorage.removeItem(DRIVE_TOKEN_EXPIRY_KEY);\n        errorMessage = \"Yetkilendirme hatası. Lütfen tekrar deneyin.\";\n      }\n\n      throw new Error(errorMessage);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Drive delete error:\", error);\n      }\n    }\n\n    let errorMessage = \"Drive dosyası silinemedi\";\n    if (error instanceof Error && error.message) {\n      errorMessage = error.message;\n    } else if (typeof error === \"string\") {\n      errorMessage = error;\n    }\n\n    throw new Error(errorMessage);\n  }\n};\n\n/**\n * OAuth URL al (eski API uyumluluğu için)\n * @deprecated Artık Firebase Authentication kullanılıyor\n */\nexport const getDriveAuthUrl = async (): Promise<string> => {\n  // Firebase Authentication ile Google giriş yap\n  await authorizeDrive();\n  return window.location.href;\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\emailService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\exchangeRateService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\adminSettingsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\auditLogsService.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'logs' is never reassigned. Use 'const' instead.","line":368,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":368,"endColumn":19,"fix":{"range":[11033,11371],"text":"const logs = snapshot.docs\n            .map((docSnap) => {\n              const logData = docSnap.data() as Omit<AuditLog, \"id\">;\n              return {\n                id: docSnap.id,\n                ...logData,\n              } as AuditLog;\n            })\n            .filter((log) => log.userId && allRelevantUserIds.includes(log.userId));"}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import { db } from \"@/lib/firebase\";\nimport {\n  collection,\n  doc,\n  getDocs,\n  addDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  Timestamp,\n  or,\n  deleteDoc,\n  writeBatch,\n} from \"firebase/firestore\";\nimport { getUserProfile, getAllUsers, UserProfile } from \"./authService\";\nimport { getDepartments, Department } from \"./departmentService\";\n\nexport interface AuditLog {\n  id: string;\n  userId: string | null;\n  action: \"CREATE\" | \"UPDATE\" | \"DELETE\";\n  tableName: string;\n  recordId: string | null;\n  oldData: unknown;\n  newData: unknown;\n  createdAt: Timestamp;\n  userName?: string;\n  userEmail?: string;\n  metadata?: Record<string, unknown>;\n}\n\nconst AUDIT_LOGS_COLLECTION = \"audit_logs\";\n\n/**\n * Create an audit log entry\n */\nexport const createAuditLog = async (\n  action: \"CREATE\" | \"UPDATE\" | \"DELETE\",\n  tableName: string,\n  recordId: string | null,\n  oldData: unknown = null,\n  newData: unknown = null,\n  userId: string | null = null,\n  metadata?: Record<string, unknown>\n): Promise<string> => {\n  try {\n    const logsRef = collection(db, AUDIT_LOGS_COLLECTION);\n    const newLog: {\n      userId: string | null;\n      action: \"CREATE\" | \"UPDATE\" | \"DELETE\";\n      tableName: string;\n      recordId: string | null;\n      oldData: unknown;\n      newData: unknown;\n      createdAt: Timestamp;\n      metadata?: Record<string, unknown>;\n    } = {\n      userId,\n      action,\n      tableName,\n      recordId,\n      oldData,\n      newData,\n      createdAt: Timestamp.now(),\n    };\n    \n    if (metadata) {\n      newLog.metadata = metadata;\n    }\n    \n    const docRef = await addDoc(logsRef, newLog);\n    return docRef.id;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error creating audit log:\", error);\n    }\n    // Don't throw - audit logs shouldn't break the main flow\n    return \"\";\n  }\n};\n\n/**\n * Get audit logs with filters\n */\nexport const getAuditLogs = async (options?: {\n  limit?: number;\n  action?: \"CREATE\" | \"UPDATE\" | \"DELETE\";\n  tableName?: string;\n  userId?: string;\n}): Promise<AuditLog[]> => {\n  try {\n    const logsRef = collection(db, AUDIT_LOGS_COLLECTION);\n    let q = query(logsRef, orderBy(\"createdAt\", \"desc\"));\n    \n    // Default limit: 100 (performans için)\n    const queryLimit = options?.limit || 100;\n    q = query(q, limit(queryLimit));\n    \n    if (options?.action) {\n      q = query(q, where(\"action\", \"==\", options.action));\n    }\n    \n    if (options?.tableName) {\n      q = query(q, where(\"tableName\", \"==\", options.tableName));\n    }\n    \n    if (options?.userId) {\n      q = query(q, where(\"userId\", \"==\", options.userId));\n    }\n    \n    const snapshot = await getDocs(q);\n    const logs: AuditLog[] = [];\n    const userIds = new Set<string>();\n    \n    // Önce tüm logları topla ve userId'leri biriktir\n    for (const docSnap of snapshot.docs) {\n      const logData = docSnap.data() as Omit<AuditLog, \"id\">;\n      const log: AuditLog = {\n        id: docSnap.id,\n        ...logData,\n      };\n      \n      if (log.userId) {\n        userIds.add(log.userId);\n      }\n      \n      logs.push(log);\n    }\n    \n    // Tüm kullanıcıları bir kerede al\n    const userMap = new Map<string, { fullName?: string; email: string }>();\n    if (userIds.size > 0) {\n      try {\n        const allUsers = await getAllUsers();\n        allUsers.forEach(user => {\n          if (userIds.has(user.id)) {\n            userMap.set(user.id, {\n              fullName: user.fullName || user.displayName,\n              email: user.email,\n            });\n          }\n        });\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Error fetching users:\", error);\n        }\n      }\n    }\n    \n    // User bilgilerini loglara ekle\n    logs.forEach(log => {\n      if (log.userId) {\n        const userInfo = userMap.get(log.userId);\n        if (userInfo) {\n          log.userName = userInfo.fullName || userInfo.email;\n          log.userEmail = userInfo.email;\n        }\n      }\n    });\n    \n    return logs;\n  } catch (error: unknown) {\n    // Index hatası durumunda basit query dene\n    if (error?.code === 'failed-precondition' || error?.message?.includes('index')) {\n      console.warn(\"Audit logs index bulunamadı, basit query kullanılıyor\");\n      try {\n        const queryLimit = options?.limit || 100;\n        const simpleQuery = query(collection(db, AUDIT_LOGS_COLLECTION), orderBy(\"createdAt\", \"desc\"), limit(queryLimit));\n        const snapshot = await getDocs(simpleQuery);\n        let logs = snapshot.docs.map((docSnap) => {\n          const logData = docSnap.data() as Omit<AuditLog, \"id\">;\n          return {\n            id: docSnap.id,\n            ...logData,\n          } as AuditLog;\n        });\n        \n        // Client-side filtreleme\n        if (options?.action) {\n          logs = logs.filter(l => l.action === options.action);\n        }\n        if (options?.tableName) {\n          logs = logs.filter(l => l.tableName === options.tableName);\n        }\n        if (options?.userId) {\n          logs = logs.filter(l => l.userId === options.userId);\n        }\n        \n        // Tarihe göre sırala (zaten orderBy var ama emin olmak için)\n        logs.sort((a, b) => {\n          const aDate = a.createdAt?.toMillis() || 0;\n          const bDate = b.createdAt?.toMillis() || 0;\n          return bDate - aDate;\n        });\n        \n        // Tüm kullanıcıları bir kerede al\n        const userIds = new Set(logs.map(log => log.userId).filter(Boolean) as string[]);\n        const userMap = new Map<string, { fullName?: string; email: string }>();\n        if (userIds.size > 0) {\n          try {\n            const allUsers = await getAllUsers();\n            allUsers.forEach(user => {\n              if (userIds.has(user.id)) {\n                userMap.set(user.id, {\n                  fullName: user.fullName || user.displayName,\n                  email: user.email,\n                });\n              }\n            });\n          } catch (error: unknown) {\n            if (import.meta.env.DEV) {\n              console.error(\"Error fetching users:\", error);\n            }\n          }\n        }\n        \n        // User bilgilerini loglara ekle\n        logs.forEach(log => {\n          if (log.userId) {\n            const userInfo = userMap.get(log.userId);\n            if (userInfo) {\n              log.userName = userInfo.fullName || userInfo.email;\n              log.userEmail = userInfo.email;\n            }\n          }\n        });\n        \n        return logs;\n      } catch (fallbackError: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Fallback query de başarısız:\", fallbackError);\n        }\n        return [];\n      }\n    }\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting audit logs:\", error);\n    }\n    const errorMessage = error instanceof Error ? error.message : \"Audit logları yüklenemedi\";\n    throw new Error(errorMessage);\n  }\n};\n\n/**\n * Get recent activities (last 10 logs)\n */\nexport const getRecentActivities = async (): Promise<AuditLog[]> => {\n  return getAuditLogs({ limit: 10 });\n};\n\n/**\n * Ekip üyelerinin loglarını getir (ekip lideri için)\n * Ekip liderinin kendi loglarını ve yönettiği ekiplerdeki üyelerin loglarını döndürür\n */\nexport const getTeamMemberLogs = async (teamLeaderId: string): Promise<{\n  logs: AuditLog[];\n  teamInfo: {\n    managedTeams: Array<{ id: string; name: string }>;\n    teamMembers: Array<{ id: string; name: string; email: string }>;\n  };\n}> => {\n  try {\n    const [departments, allUsers] = await Promise.all([\n      getDepartments(),\n      getAllUsers(),\n    ]);\n    \n    // Ekip liderinin yönettiği ekipleri bul\n    const managedTeams = departments.filter((dept) => dept.managerId === teamLeaderId);\n    \n    const teamInfo = {\n      managedTeams: managedTeams.map(team => ({ id: team.id, name: team.name })),\n      teamMembers: [] as Array<{ id: string; name: string; email: string }>,\n    };\n    \n    if (managedTeams.length === 0) {\n      return { logs: [], teamInfo };\n    }\n    \n    const teamIds = managedTeams.map((team) => team.id);\n    \n    // Bu ekiplere ait kullanıcıları bul\n    const teamMembers = allUsers.filter((user) => {\n      const approvedTeams = user.approvedTeams || [];\n      const pendingTeams = user.pendingTeams || [];\n      return [...approvedTeams, ...pendingTeams].some((teamId) => teamIds.includes(teamId));\n    });\n    \n    // Ekip üyeleri bilgilerini kaydet\n    teamInfo.teamMembers = teamMembers.map(member => ({\n      id: member.id,\n      name: member.fullName || member.email,\n      email: member.email,\n    }));\n    \n    const teamMemberIds = teamMembers.map((member) => member.id);\n    \n    // Ekip liderinin kendi loglarını da dahil et\n    const allRelevantUserIds = [...teamMemberIds, teamLeaderId];\n    \n    // Tüm logları al ve filtrele (limit ile)\n    try {\n      const logsRef = collection(db, AUDIT_LOGS_COLLECTION);\n      const snapshot = await getDocs(query(logsRef, orderBy(\"createdAt\", \"desc\"), limit(500))); // Max 500 log\n      \n      const logs: AuditLog[] = [];\n      const userIds = new Set<string>();\n      \n      // Önce tüm logları topla ve userId'leri biriktir\n      for (const docSnap of snapshot.docs) {\n        const logData = docSnap.data() as Omit<AuditLog, \"id\">;\n        \n        // Ekip üyelerinin ve ekip liderinin loglarını al\n        if (logData.userId && allRelevantUserIds.includes(logData.userId)) {\n          const log: AuditLog = {\n            id: docSnap.id,\n            ...logData,\n          };\n          \n          if (log.userId) {\n            userIds.add(log.userId);\n          }\n          \n          logs.push(log);\n        }\n      }\n      \n      // Tüm kullanıcıları bir kerede al\n      const userMap = new Map<string, { fullName?: string; email: string }>();\n      if (userIds.size > 0) {\n        try {\n          const allUsers = await getAllUsers();\n          allUsers.forEach(user => {\n            if (userIds.has(user.id)) {\n              userMap.set(user.id, {\n                fullName: user.fullName || user.displayName,\n                email: user.email,\n              });\n            }\n          });\n        } catch (error: unknown) {\n          if (import.meta.env.DEV) {\n            console.error(\"Error fetching users:\", error);\n          }\n        }\n      }\n      \n      // User bilgilerini loglara ekle\n      logs.forEach(log => {\n        if (log.userId) {\n          const userInfo = userMap.get(log.userId);\n          if (userInfo) {\n            log.userName = userInfo.fullName || userInfo.email;\n            log.userEmail = userInfo.email;\n          }\n        }\n      });\n      \n      return { logs, teamInfo };\n    } catch (error: unknown) {\n      // Index hatası durumunda basit query dene\n      if (error?.code === 'failed-precondition' || error?.message?.includes('index')) {\n        console.warn(\"Team member logs index bulunamadı, basit query kullanılıyor\");\n        try {\n          const simpleQuery = query(collection(db, AUDIT_LOGS_COLLECTION), orderBy(\"createdAt\", \"desc\"));\n          const snapshot = await getDocs(simpleQuery);\n          let logs = snapshot.docs\n            .map((docSnap) => {\n              const logData = docSnap.data() as Omit<AuditLog, \"id\">;\n              return {\n                id: docSnap.id,\n                ...logData,\n              } as AuditLog;\n            })\n            .filter((log) => log.userId && allRelevantUserIds.includes(log.userId));\n          \n          // Tarihe göre sırala\n          logs.sort((a, b) => {\n            const aDate = a.createdAt?.toMillis() || 0;\n            const bDate = b.createdAt?.toMillis() || 0;\n            return bDate - aDate;\n          });\n          \n          // Tüm kullanıcıları bir kerede al\n          const userIds = new Set(logs.map(log => log.userId).filter(Boolean) as string[]);\n          const userMap = new Map<string, { fullName?: string; email: string }>();\n          if (userIds.size > 0) {\n              try {\n              const allUsers = await getAllUsers();\n              allUsers.forEach(user => {\n                if (userIds.has(user.id)) {\n                  userMap.set(user.id, {\n                    fullName: user.fullName || user.displayName,\n                    email: user.email,\n                  });\n                }\n              });\n              } catch (error: unknown) {\n              console.error(\"Error fetching users:\", error);\n              }\n          }\n          \n          // User bilgilerini loglara ekle\n          logs.forEach(log => {\n            if (log.userId) {\n              const userInfo = userMap.get(log.userId);\n              if (userInfo) {\n                log.userName = userInfo.fullName || userInfo.email;\n                log.userEmail = userInfo.email;\n            }\n          }\n          });\n          \n          return { logs, teamInfo };\n        } catch (fallbackError: unknown) {\n          if (import.meta.env.DEV) {\n            console.error(\"Fallback query de başarısız:\", fallbackError);\n          }\n          return { logs: [], teamInfo };\n        }\n      }\n      throw error;\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting team member logs:\", error);\n    }\n    return { logs: [], teamInfo: { managedTeams: [], teamMembers: [] } };\n  }\n};\n\n/**\n * Belirli bir kullanıcının loglarını getir (yetki kontrolü ile)\n */\nexport const getUserLogsWithPermission = async (\n  viewerId: string,\n  targetUserId: string\n): Promise<AuditLog[]> => {\n  try {\n    const [viewer, targetUser, departments, allUsers] = await Promise.all([\n      getUserProfile(viewerId),\n      getUserProfile(targetUserId),\n      getDepartments(),\n      getAllUsers(),\n    ]);\n    \n    if (!viewer) {\n      throw new Error(\"Görüntüleyen kullanıcı bulunamadı\");\n    }\n    \n    // Kullanıcı kendi loglarını görebilir\n    if (viewer.id === targetUserId) {\n      return getAuditLogs({ userId: targetUserId });\n    }\n    \n    // Ana yöneticiler tüm logları görebilir\n    if (viewer.role?.includes(\"main_admin\") || viewer.role?.includes(\"super_admin\")) {\n      return getAuditLogs({ userId: targetUserId });\n    }\n    \n    // Super Admin tüm logları görebilir\n    if (viewer.role?.includes(\"super_admin\") || viewer.role?.includes(\"main_admin\")) {\n      return getAuditLogs({ userId: targetUserId });\n    }\n    \n    // Ekip liderleri ekip üyelerinin loglarını görebilir\n    const managedTeams = departments.filter((dept) => dept.managerId === viewer.id);\n    if (managedTeams.length > 0) {\n      const teamIds = managedTeams.map((team) => team.id);\n      const targetUserTeams = [\n        ...(targetUser?.approvedTeams || []),\n        ...(targetUser?.pendingTeams || []),\n      ];\n      \n      const isTeamMember = targetUserTeams.some((teamId) => teamIds.includes(teamId));\n      \n      if (isTeamMember) {\n        return getAuditLogs({ userId: targetUserId });\n      }\n    }\n    \n    // Yetki yok\n    throw new Error(\"Bu kullanıcının loglarını görüntüleme yetkiniz yok\");\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting user logs with permission:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Kullanıcının tüm loglarını sil\n */\nexport const deleteUserLogs = async (userId: string): Promise<void> => {\n  try {\n    const logsRef = collection(db, AUDIT_LOGS_COLLECTION);\n    \n    // Kullanıcının tüm loglarını bul\n    const q = query(logsRef, where(\"userId\", \"==\", userId));\n    const snapshot = await getDocs(q);\n    \n    // Batch write ile tüm logları sil (500'den fazla ise birden fazla batch)\n    const batchSize = 500;\n    const docs = snapshot.docs;\n    \n    for (let i = 0; i < docs.length; i += batchSize) {\n      const batch = writeBatch(db);\n      const batchDocs = docs.slice(i, i + batchSize);\n      \n      batchDocs.forEach((docSnap) => {\n        batch.delete(docSnap.ref);\n      });\n      \n      await batch.commit();\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error deleting user logs:\", error);\n    }\n    // Log silme hatası kullanıcı silme işlemini engellemez\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\authService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":78,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1896,1899],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1896,1899],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6842,6845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6842,6845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":211,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7994,7997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7994,7997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10203,10206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10203,10206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'lastLoginUpdateTime' is never reassigned. Use 'const' instead.","line":1793,"column":5,"nodeType":"Identifier","messageId":"useConst","endLine":1793,"endColumn":45,"fix":{"range":[70722,70779],"text":"const lastLoginUpdateTime: Map<string, number> = new Map();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1888,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1888,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[74323,74326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[74323,74326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2715,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2715,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[105161,105164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[105161,105164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Firebase Authentication Service\n * Kullanıcı kayıt, giriş, çıkış ve profil yönetimi\n */\n\nimport {\n  signInWithEmailAndPassword,\n  createUserWithEmailAndPassword,\n  signOut as firebaseSignOut,\n  sendEmailVerification,\n  sendPasswordResetEmail,\n  onAuthStateChanged,\n  updateProfile,\n  User as FirebaseUser,\n  GoogleAuthProvider,\n  signInWithPopup,\n} from \"firebase/auth\";\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  setDoc,\n  updateDoc,\n  deleteDoc,\n  serverTimestamp,\n  query,\n  orderBy,\n  limit,\n  writeBatch,\n  where,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { auth, firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\nimport {\n  REQUIRE_EMAIL_VERIFICATION,\n  ALLOW_DELETED_ACCOUNT_REREGISTRATION,\n  AUTO_SEND_VERIFICATION_EMAIL,\n  RESEND_VERIFICATION_ON_LOGIN\n} from \"@/config/auth\";\n\nexport interface UserProfile {\n  id: string;\n  email: string;\n  displayName: string;\n  fullName?: string;\n  phone?: string;\n  dateOfBirth?: string;\n  role: string[];\n  departmentId?: string;\n  pendingTeams?: string[]; // Onay bekleyen ekipler (department IDs)\n  approvedTeams?: string[]; // Onaylanmış ekipler (department IDs)\n  teamLeaderIds?: string[]; // Ekip lideri olduğu ekipler (opsiyonel)\n  emailVerified: boolean;\n  createdAt: Timestamp | Date | null;\n  updatedAt: Timestamp | Date | null;\n  lastLoginAt?: Timestamp | Date | null; // Son giriş zamanı\n}\n\n/**\n * Kullanıcı kaydı\n */\nexport const register = async (\n  email: string,\n  password: string,\n  fullName: string,\n  phone?: string,\n  dateOfBirth?: string,\n  selectedTeamId?: string\n): Promise<{ success: boolean; message?: string; user?: UserProfile | null }> => {\n  try {\n    if (!auth || !firestore) {\n      throw new Error('Firebase is not initialized');\n    }\n\n    // Önce email'in kayıtlı olup olmadığını Firestore'dan kontrol et (hızlı)\n    let existingUserDoc: { id: string; data: any } | null = null;\n    try {\n      const usersRef = collection(firestore, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", email), limit(1));\n      const querySnapshot = await getDocs(q);\n\n      if (!querySnapshot.empty) {\n        const doc = querySnapshot.docs[0];\n        const userData = doc.data();\n\n        // Silinmiş hesap kontrolü - config'e göre yeniden kayıt izni ver\n        if (userData.deleted === true) {\n          if (ALLOW_DELETED_ACCOUNT_REREGISTRATION) {\n            // Silinmiş hesap - config'e göre yeni kayıt olabilir, existingUserDoc'u null yap\n            existingUserDoc = null;\n          } else {\n            // Silinmiş hesapların yeniden kaydı kapalı\n            return {\n              success: false,\n              message: \"Bu e-posta adresi daha önce kullanılmış ve hesap silinmiş. Yeni bir e-posta adresi kullanın.\",\n              user: null,\n            };\n          }\n        } else {\n          existingUserDoc = { id: doc.id, data: userData };\n        }\n      }\n    } catch (checkError) {\n      // Firestore kontrolü başarısız olsa bile devam et (permission hatası normal)\n      // Giriş yapmadan email kontrolü yapamayabiliriz, bu durumda Firebase Auth kontrolü yapılacak\n      const errorCode = (checkError as { code?: string })?.code;\n      if (errorCode !== 'permission-denied' && import.meta.env.DEV) {\n        console.warn(\"Email kontrolü yapılırken hata:\", checkError);\n      }\n    }\n\n    let firebaseUser: FirebaseUser | null = null;\n    let isExistingUser = false;\n\n    if (existingUserDoc) {\n      // Email zaten kayıtlı - mevcut kullanıcı ile giriş yapmayı dene\n      try {\n        const loginResult = await signInWithEmailAndPassword(auth, email, password);\n        firebaseUser = loginResult.user;\n        isExistingUser = true;\n\n        // Firebase Auth'daki user objesini reload et (emailVerified değerinin güncel olması için)\n        // reload() user objesini günceller, bu yüzden aynı objeyi kullanmalıyız\n        try {\n          if (import.meta.env.DEV) {\n            console.log(\"Register - User reload öncesi emailVerified:\", firebaseUser.emailVerified);\n          }\n          await firebaseUser.reload();\n          // reload() sonrası firebaseUser objesi güncellenmiş olmalı\n          // Ayrıca auth.currentUser'ı da kontrol et (bazen daha güncel olabilir)\n          if (auth.currentUser) {\n            firebaseUser = auth.currentUser;\n          }\n          if (import.meta.env.DEV) {\n            console.log(\"Register - User reload sonrası emailVerified:\", firebaseUser.emailVerified);\n            console.log(\"Register - auth.currentUser emailVerified:\", auth.currentUser?.emailVerified);\n          }\n        } catch (reloadError) {\n          if (import.meta.env.DEV) {\n            console.warn(\"User reload hatası (devam ediliyor):\", reloadError);\n          }\n          // Reload hatası olsa bile devam et\n        }\n\n        // Email doğrulanmış mı kontrol et - Firebase Auth en güncel kaynak\n        const userData = existingUserDoc.data;\n        const wasDeleted = userData.deleted === true;\n        // Firebase Auth'daki emailVerified değeri en güncel olanıdır, öncelikli kontrol\n        // reload() sonrası firebaseUser.emailVerified güncellenmiş olmalı\n        // Eğer hala false ise, Firestore'daki değere de bak (senkronizasyon sorunu olabilir)\n        let emailVerified = firebaseUser.emailVerified;\n        // Eğer Firebase Auth'da false ama Firestore'da true ise, Firestore'a güven\n        // (Firebase Auth daha güncel olmalı ama senkronizasyon sorunu olabilir)\n        if (!emailVerified && userData.emailVerified === true) {\n          if (import.meta.env.DEV) {\n            console.warn(\"Register - Firebase Auth'da emailVerified false ama Firestore'da true, Firestore'a güveniliyor\");\n          }\n          // Firestore'daki değere güven ama Firebase Auth'ı da güncelle\n          emailVerified = true;\n        }\n\n        if (import.meta.env.DEV) {\n          console.log(\"Register - Mevcut kullanıcı email doğrulama kontrolü:\", {\n            firebaseEmailVerified: firebaseUser.emailVerified,\n            firestoreEmailVerified: userData.emailVerified,\n            emailVerified,\n            wasDeleted,\n            userId: firebaseUser.uid,\n            email: firebaseUser.email,\n          });\n        }\n\n        // Eğer email doğrulanmışsa, direkt hata mesajı döndür (kayıt olmaya çalışıyor)\n        if (emailVerified && !wasDeleted) {\n          await firebaseSignOut(auth);\n          return {\n            success: false,\n            message: \"Bu hesap zaten var, doğrulanmış. Giriş yapabilirsiniz.\",\n            user: null,\n          };\n        }\n\n        // Email doğrulanmamışsa veya silinmişse devam et (aşağıdaki kod devam edecek)\n      } catch (loginError: unknown) {\n        // Şifre yanlış - email zaten kayıtlı ama şifre yanlış\n        const customError = new Error(\"Bu hesap zaten kayıtlı. Lütfen giriş yapmayı deneyin.\");\n        (customError as any).code = 'auth/email-already-in-use';\n        throw customError;\n      }\n    } else {\n      // Email kayıtlı değil veya silinmiş - yeni kullanıcı oluştur\n      try {\n        const userCredential = await createUserWithEmailAndPassword(auth, email, password);\n        firebaseUser = userCredential.user;\n        isExistingUser = false;\n      } catch (createError: unknown) {\n        // Eğer email zaten Firebase Auth'da varsa (silinmiş hesap olabilir)\n        const errorCode = (createError as { code?: string })?.code;\n        if (errorCode === 'auth/email-already-in-use') {\n          // Firebase Auth'da email var ama Firestore'da silinmiş\n          // Giriş yapmayı dene ve Firestore'u güncelle\n          try {\n            const loginResult = await signInWithEmailAndPassword(auth, email, password);\n            firebaseUser = loginResult.user;\n            isExistingUser = false; // Yeni kayıt olarak işlem yap (silinmiş hesap tekrar kayıt oluyor)\n          } catch (loginError: unknown) {\n            // Şifre yanlış\n            const customError = new Error(\"Bu hesap zaten kayıtlı. Lütfen giriş yapmayı deneyin.\");\n            (customError as any).code = 'auth/email-already-in-use';\n            throw customError;\n          }\n        } else {\n          throw createError;\n        }\n      }\n    }\n\n    if (!firebaseUser) {\n      throw new Error('Kullanıcı oluşturulamadı veya bulunamadı');\n    }\n\n    const userId = firebaseUser.uid;\n\n    // Firestore'da kullanıcı profili oluştur (sadece yeni kullanıcı için)\n    const userProfileData: Record<string, unknown> = {\n      email: email,\n      displayName: fullName,\n      fullName: fullName,\n      role: [\"viewer\"], // Varsayılan rol\n      emailVerified: false, // Email doğrulama zorunlu, başlangıçta false\n      needsEmailVerification: true, // Yeni kayıt olan kullanıcılar için email doğrulaması zorunlu\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n      pendingTeams: selectedTeamId ? [selectedTeamId] : [],\n      approvedTeams: [],\n    };\n\n    // Opsiyonel alanları sadece tanımlıysa ve boş değilse ekle\n    if (phone && phone.trim() !== '') {\n      userProfileData.phone = phone.trim();\n    }\n    if (dateOfBirth && dateOfBirth.trim() !== '') {\n      userProfileData.dateOfBirth = dateOfBirth.trim();\n    }\n\n    const userDocRef = doc(firestore, \"users\", userId);\n\n    // Firestore yazma, display name güncelleme ve email doğrulama gönderme işlemlerini paralel yap\n    const promises: Promise<void>[] = [];\n    let emailVerificationError: Error | null = null;\n\n    // Firestore yazma işlemi (hızlı - gereksiz getDoc kaldırıldı)\n    const firestorePromise = (async () => {\n      if (isExistingUser && existingUserDoc) {\n        // Mevcut kullanıcı - sadece güncelleme yap\n        // Email doğrulama durumu: Firebase Auth en güncel kaynak\n        const userData = existingUserDoc.data;\n        // Firebase Auth'daki emailVerified değeri en güncel olanıdır, öncelikli kontrol\n        const emailVerified = firebaseUser.emailVerified;\n\n        if (import.meta.env.DEV) {\n          console.log(\"Register - Mevcut kullanıcı Firestore güncelleme öncesi:\", {\n            email,\n            firebaseEmailVerified: firebaseUser.emailVerified,\n            firestoreEmailVerified: userData.emailVerified,\n            emailVerified,\n          });\n        }\n\n        const updateData: any = {\n          displayName: fullName,\n          fullName: fullName,\n          updatedAt: serverTimestamp(),\n        };\n\n        // Opsiyonel alanları sadece tanımlıysa ekle\n        if (phone && phone.trim() !== '') {\n          updateData.phone = phone.trim();\n        }\n        if (dateOfBirth && dateOfBirth.trim() !== '') {\n          updateData.dateOfBirth = dateOfBirth.trim();\n        }\n        if (selectedTeamId) {\n          updateData.pendingTeams = [selectedTeamId];\n        }\n\n        // Email doğrulama durumunu Firebase Auth'dan al ve Firestore'a senkronize et\n        if (emailVerified) {\n          // Email doğrulanmışsa needsEmailVerification flag'ini false yap\n          updateData.needsEmailVerification = false;\n          updateData.emailVerified = true;\n\n          if (import.meta.env.DEV) {\n            console.log(\"Register - Mevcut kullanıcı için email doğrulanmış, needsEmailVerification: false set ediliyor\");\n          }\n        } else {\n          // Email doğrulanmamışsa needsEmailVerification flag'ini true yap\n          updateData.needsEmailVerification = true;\n          updateData.emailVerified = false;\n\n          if (import.meta.env.DEV) {\n            console.log(\"Register - Mevcut kullanıcı için email doğrulanmamış, needsEmailVerification: true set ediliyor\");\n          }\n        }\n\n        // undefined değerleri temizle (Firestore undefined kabul etmez)\n        const cleanUpdateData: Record<string, unknown> = {};\n        for (const [key, value] of Object.entries(updateData)) {\n          if (value !== undefined) {\n            cleanUpdateData[key] = value;\n          }\n        }\n\n        await updateDoc(userDocRef, cleanUpdateData);\n\n        if (import.meta.env.DEV) {\n          console.log(\"Register - Firestore güncellemesi tamamlandı\", {\n            email,\n            needsEmailVerification: updateData.needsEmailVerification,\n            emailVerified: updateData.emailVerified,\n          });\n        }\n      } else {\n        // Yeni kullanıcı veya silinmiş hesap tekrar kayıt oluyor\n        // Silinmiş hesap için sıfırdan kayıt oluyor gibi devam et\n        // undefined değerleri temizle (Firestore undefined kabul etmez)\n        const cleanUserProfileData: Record<string, unknown> = {\n          ...userProfileData,\n          deleted: false, // Silinmiş flag'ini kaldır\n          needsEmailVerification: true, // Silinmiş hesap için de email doğrulaması zorunlu\n          emailVerified: false, // Email doğrulaması yapılmalı\n        };\n\n        // undefined değerleri kaldır\n        for (const [key, value] of Object.entries(cleanUserProfileData)) {\n          if (value === undefined) {\n            delete cleanUserProfileData[key];\n          }\n        }\n\n        // setDoc merge: true ile çalışır, eğer doküman varsa günceller, yoksa oluşturur\n        await setDoc(userDocRef, cleanUserProfileData, { merge: true });\n\n        if (import.meta.env.DEV) {\n          console.log(\"Register - Yeni kullanıcı veya silinmiş hesap için kayıt\", {\n            email,\n            isExistingUser,\n            firebaseEmailVerified: firebaseUser.emailVerified,\n          });\n        }\n      }\n    })();\n    promises.push(firestorePromise);\n\n    // Display name güncelleme\n    if (fullName) {\n      promises.push(updateProfile(firebaseUser, { displayName: fullName }).catch((error) => {\n        if (import.meta.env.DEV) {\n          console.error(\"Display name güncellenirken hata:\", error);\n        }\n        // Hata olsa bile devam et\n      }));\n    }\n\n    // Email doğrulama gönder (sadece email doğrulanmamışsa ve AUTO_SEND_VERIFICATION_EMAIL true ise)\n    // Config'e göre email gönderimi kontrol edilir\n    if (AUTO_SEND_VERIFICATION_EMAIL && !firebaseUser.emailVerified) {\n      const emailPromise = sendEmailVerification(firebaseUser)\n        .then(() => {\n          if (import.meta.env.DEV) {\n            console.log(\"Email doğrulama maili gönderildi:\", email);\n          }\n        })\n        .catch((verifyError: unknown) => {\n          const errorCode = (verifyError as { code?: string })?.code;\n          const errorMsg = verifyError instanceof Error ? verifyError.message : String(verifyError);\n\n          if (import.meta.env.DEV) {\n            console.error(\"Email doğrulama maili gönderilirken hata:\", verifyError);\n          }\n\n          // Hatayı kaydet\n          let errorMessage = \"Email doğrulama maili gönderilemedi.\";\n          if (errorCode === 'auth/too-many-requests') {\n            errorMessage = \"Çok fazla istek yapıldı. Lütfen bir süre sonra tekrar deneyin.\";\n          } else if (errorCode === 'auth/network-request-failed') {\n            errorMessage = \"Ağ hatası. İnternet bağlantınızı kontrol edin.\";\n          } else if (errorMsg) {\n            errorMessage = errorMsg;\n          }\n\n          emailVerificationError = new Error(errorMessage + \" Lütfen daha sonra tekrar deneyin.\");\n        });\n\n      // Email gönderme işlemini timeout ile sınırlandır (2 saniye - hızlı ama güvenilir)\n      const emailWithTimeout = Promise.race([\n        emailPromise,\n        new Promise<void>((resolve) => {\n          setTimeout(() => {\n            if (import.meta.env.DEV) {\n              console.warn(\"Email gönderme işlemi timeout (2 saniye), background'da devam ediyor...\");\n            }\n            resolve();\n          }, 2000); // 2 saniye timeout\n        })\n      ]);\n\n      promises.push(emailWithTimeout);\n    }\n\n    // Tüm paralel işlemleri bekle (Firestore yazma, display name, email gönderme)\n    const results = await Promise.allSettled(promises);\n\n    // Firestore güncellemesinin başarılı olduğundan emin ol\n    if (import.meta.env.DEV) {\n      const firestoreResult = results[0];\n      if (firestoreResult.status === 'rejected') {\n        console.error(\"Register - Firestore güncellemesi başarısız:\", firestoreResult.reason);\n      } else {\n        console.log(\"Register - Firestore güncellemesi başarılı\");\n      }\n    }\n\n    // Email gönderim hatası varsa fırlat\n    if (emailVerificationError) {\n      throw emailVerificationError;\n    }\n\n    // Firestore güncellemesinin tamamlandığından emin olmak için kısa bir bekleme\n    // (Firestore'un eventual consistency özelliği nedeniyle)\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Eğer ekip seçildiyse, ekip liderine ve yöneticilere bildirim gönder\n    if (selectedTeamId) {\n      try {\n        const { getDepartmentById } = await import(\"./departmentService\");\n        const { createNotification } = await import(\"./notificationService\");\n        const department = await getDepartmentById(selectedTeamId);\n\n        if (department) {\n          const requesterName = fullName || email || \"Bir kullanıcı\";\n          const teamName = department.name || \"ekip\";\n\n          const notificationPromises: Promise<void>[] = [];\n\n          // Ekip liderine bildirim gönder\n          if (department.managerId) {\n            notificationPromises.push(\n              createNotification({\n                userId: department.managerId,\n                type: \"system\",\n                title: \"Yeni katılım isteği\",\n                message: `${requesterName} \"${teamName}\" ekibine katılmak için istek gönderdi. İsteği onaylamak veya reddetmek için Ekip Üyeleri sayfasını ziyaret edin.`,\n                read: false,\n                metadata: {\n                  teamId: selectedTeamId,\n                  teamName: teamName,\n                  requesterId: userId,\n                  requesterName: requesterName,\n                  requesterEmail: email,\n                },\n              }).then(() => { }).catch(err => {\n                if (import.meta.env.DEV) {\n                  console.error(\"Error sending notification to team leader:\", err);\n                }\n              })\n            );\n          }\n\n          // Yöneticilere (super_admin, main_admin) bildirim gönder\n          try {\n            const allUsers = await getAllUsers();\n            const admins = allUsers.filter(u =>\n              u.role?.includes(\"super_admin\") || u.role?.includes(\"main_admin\")\n            );\n\n            for (const admin of admins) {\n              notificationPromises.push(\n                createNotification({\n                  userId: admin.id,\n                  type: \"system\",\n                  title: \"Yeni ekip katılım isteği\",\n                  message: `${requesterName} \"${teamName}\" ekibine katılmak için istek gönderdi. İsteği onaylamak veya reddetmek için Ekip Onay Yönetimi sayfasını ziyaret edin.`,\n                  read: false,\n                  metadata: {\n                    teamId: selectedTeamId,\n                    teamName: teamName,\n                    requesterId: userId,\n                    requesterName: requesterName,\n                    requesterEmail: email,\n                  },\n                }).then(() => { }).catch(err => {\n                  if (import.meta.env.DEV) {\n                    console.error(`Error sending notification to admin ${admin.id}:`, err);\n                  }\n                })\n              );\n            }\n          } catch (adminError) {\n            if (import.meta.env.DEV) {\n              console.error(\"Error getting admins for notification:\", adminError);\n            }\n          }\n\n          // Tüm bildirimleri paralel gönder (await etmeden, arka planda)\n          Promise.allSettled(notificationPromises).catch(() => {\n            // Bildirim hatası kayıt işlemini engellemez\n          });\n        }\n      } catch (notifError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Error sending team request notifications:\", notifError);\n        }\n        // Bildirim hatası kayıt işlemini engellemez\n      }\n    }\n\n    // Mevcut kullanıcı için mesaj farklı olabilir\n    // Email zaten doğrulanmışsa doğrulama mesajı gösterme\n    let successMessage: string;\n    if (isExistingUser) {\n      // Mevcut kullanıcı kayıt olmaya çalışıyor - \"bu hesap zaten var\" mesajı göster\n      if (firebaseUser.emailVerified) {\n        successMessage = \"Bu hesap zaten var, doğrulanmış. Giriş yapabilirsiniz.\";\n      } else {\n        successMessage = \"Hesap var ama doğrulama yapılmamış. Doğrulama maili gönderildi. Lütfen e-postanızı ve spam kutusunu kontrol edin.\";\n      }\n    } else {\n      // İlk yeni kayıt - sadece doğrulama maili bildirimi\n      if (firebaseUser.emailVerified) {\n        successMessage = \"Kayıt başarılı!\";\n      } else {\n        successMessage = \"Doğrulama maili gönderildi. Doğrulama yaptıktan sonra giriş yapabilirsiniz. Lütfen e-postanızı ve spam kutusunu kontrol edin.\";\n      }\n    }\n\n    return {\n      success: true,\n      message: successMessage,\n      user: {\n        id: userId,\n        email: email,\n        displayName: fullName,\n        fullName: fullName,\n        phone: phone || undefined,\n        dateOfBirth: dateOfBirth || undefined,\n        role: [\"viewer\"],\n        pendingTeams: selectedTeamId ? [selectedTeamId] : [],\n        approvedTeams: [],\n        emailVerified: firebaseUser.emailVerified || false,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n    };\n  } catch (error: unknown) {\n    // Firebase hata kodlarını Türkçe'ye çevir\n    let errorMessage = \"Kayıt başarısız\";\n    const errorCode = (error as { code?: string })?.code;\n    const errorMsg = error instanceof Error ? error.message : String(error);\n\n    // Beklenen hatalar için sessizce devam et, sadece beklenmeyen hatalar için log göster\n    const isExpectedError = [\n      'auth/email-already-in-use',\n      'auth/invalid-email',\n      'auth/weak-password',\n      'auth/operation-not-allowed',\n      'auth/invalid-credential',\n      'auth/user-disabled',\n      'auth/too-many-requests'\n    ].includes(errorCode || '');\n\n    // Detaylı hata loglama (sadece beklenmeyen hatalar için)\n    if (!isExpectedError && import.meta.env.DEV) {\n      console.error(\"Register error details:\", {\n        code: errorCode,\n        message: errorMsg,\n        error: error\n      });\n    }\n\n    if (errorCode === 'auth/email-already-in-use') {\n      // Email zaten kayıtlı - doğrulanmamış kullanıcı olabilir, giriş yapmayı dene\n      // Bu beklenen bir durum, console'da hata gösterme\n      try {\n        const loginResult = await signInWithEmailAndPassword(auth, email, password);\n        let existingUser = loginResult.user;\n\n        // Firebase Auth'daki user objesini reload et (emailVerified değerinin güncel olması için)\n        // reload() user objesini günceller, bu yüzden aynı objeyi kullanmalıyız\n        try {\n          if (import.meta.env.DEV) {\n            console.log(\"Register - auth/email-already-in-use User reload öncesi emailVerified:\", existingUser.emailVerified);\n          }\n          await existingUser.reload();\n          // reload() sonrası existingUser objesi güncellenmiş olmalı\n          // Ayrıca auth.currentUser'ı da kontrol et (bazen daha güncel olabilir)\n          if (auth.currentUser) {\n            existingUser = auth.currentUser;\n          }\n          if (import.meta.env.DEV) {\n            console.log(\"Register - auth/email-already-in-use User reload sonrası emailVerified:\", existingUser.emailVerified);\n            console.log(\"Register - auth/email-already-in-use auth.currentUser emailVerified:\", auth.currentUser?.emailVerified);\n          }\n        } catch (reloadError) {\n          if (import.meta.env.DEV) {\n            console.warn(\"User reload hatası (devam ediliyor):\", reloadError);\n          }\n          // Reload hatası olsa bile devam et\n        }\n\n        // Email doğrulanmamışsa veya hesap silinmişse, Firestore'u güncelle ve doğrulama email'i gönder\n        const userDoc = await getDoc(doc(firestore!, \"users\", existingUser.uid));\n        const existingData = userDoc.exists() ? userDoc.data() : null;\n        const wasDeleted = existingData?.deleted === true;\n\n        // Firebase Auth'daki emailVerified değeri en güncel olanıdır, öncelikli kontrol\n        // reload() sonrası existingUser.emailVerified güncellenmiş olmalı\n        // Eğer hala false ise, Firestore'daki değere de bak (senkronizasyon sorunu olabilir)\n        let emailVerified = existingUser.emailVerified;\n        // Eğer Firebase Auth'da false ama Firestore'da true ise, Firestore'a güven\n        // (Firebase Auth daha güncel olmalı ama senkronizasyon sorunu olabilir)\n        if (!emailVerified && existingData?.emailVerified === true) {\n          if (import.meta.env.DEV) {\n            console.warn(\"Register - auth/email-already-in-use Firebase Auth'da emailVerified false ama Firestore'da true, Firestore'a güveniliyor\");\n          }\n          // Firestore'daki değere güven ama Firebase Auth'ı da güncelle\n          emailVerified = true;\n        }\n\n        if (import.meta.env.DEV) {\n          console.log(\"Register - auth/email-already-in-use email doğrulama kontrolü:\", {\n            firebaseEmailVerified: existingUser.emailVerified,\n            firestoreEmailVerified: existingData?.emailVerified,\n            emailVerified,\n            wasDeleted,\n            userId: existingUser.uid,\n            email: existingUser.email,\n          });\n        }\n\n        // Eğer email doğrulanmışsa ve hesap silinmemişse, direkt hata mesajı döndür\n        if (emailVerified && !wasDeleted) {\n          await firebaseSignOut(auth);\n          return {\n            success: false,\n            message: \"Bu hesap zaten var, doğrulanmış. Giriş yapabilirsiniz.\",\n            user: null,\n          };\n        }\n\n        if (!emailVerified || wasDeleted) {\n          if (userDoc.exists()) {\n            // Firestore'u güncelle\n            const updateDataForExisting: Record<string, unknown> = {\n              displayName: fullName,\n              fullName: fullName,\n              updatedAt: serverTimestamp(),\n            };\n\n            // Opsiyonel alanları sadece tanımlıysa ekle\n            if (phone && phone.trim() !== '') {\n              updateDataForExisting.phone = phone.trim();\n            }\n            if (dateOfBirth && dateOfBirth.trim() !== '') {\n              updateDataForExisting.dateOfBirth = dateOfBirth.trim();\n            }\n            if (selectedTeamId) {\n              updateDataForExisting.pendingTeams = [selectedTeamId];\n            }\n\n            // Silinmiş hesap tekrar kayıt oluyorsa, deleted flag'ini kaldır\n            if (wasDeleted) {\n              updateDataForExisting.deleted = false;\n              updateDataForExisting.needsEmailVerification = true;\n              updateDataForExisting.emailVerified = false;\n            }\n\n            // undefined değerleri temizle (Firestore undefined kabul etmez)\n            const cleanUpdateDataForExisting: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(updateDataForExisting)) {\n              if (value !== undefined) {\n                cleanUpdateDataForExisting[key] = value;\n              }\n            }\n\n            await updateDoc(doc(firestore!, \"users\", existingUser.uid), cleanUpdateDataForExisting);\n          } else {\n            // Firestore'da yoksa oluştur\n            const newUserData: Record<string, unknown> = {\n              email: email,\n              displayName: fullName,\n              fullName: fullName,\n              role: [\"viewer\"],\n              emailVerified: false,\n              createdAt: serverTimestamp(),\n              updatedAt: serverTimestamp(),\n              pendingTeams: selectedTeamId ? [selectedTeamId] : [],\n              approvedTeams: [],\n            };\n\n            // Opsiyonel alanları sadece tanımlıysa ekle\n            if (phone && phone.trim() !== '') {\n              newUserData.phone = phone.trim();\n            }\n            if (dateOfBirth && dateOfBirth.trim() !== '') {\n              newUserData.dateOfBirth = dateOfBirth.trim();\n            }\n\n            // undefined değerleri temizle (Firestore undefined kabul etmez)\n            const cleanNewUserData: Record<string, unknown> = {};\n            for (const [key, value] of Object.entries(newUserData)) {\n              if (value !== undefined) {\n                cleanNewUserData[key] = value;\n              }\n            }\n\n            await setDoc(doc(firestore!, \"users\", existingUser.uid), cleanNewUserData);\n          }\n\n          // Eğer ekip seçildiyse, ekip liderine ve yöneticilere bildirim gönder\n          if (selectedTeamId) {\n            try {\n              const { getDepartmentById } = await import(\"./departmentService\");\n              const { createNotification } = await import(\"./notificationService\");\n              const department = await getDepartmentById(selectedTeamId);\n\n              if (department) {\n                const requesterName = fullName || email || \"Bir kullanıcı\";\n                const teamName = department.name || \"ekip\";\n\n                const notificationPromises: Promise<void>[] = [];\n\n                // Ekip liderine bildirim gönder\n                if (department.managerId) {\n                  notificationPromises.push(\n                    createNotification({\n                      userId: department.managerId,\n                      type: \"system\",\n                      title: \"Yeni katılım isteği\",\n                      message: `${requesterName} \"${teamName}\" ekibine katılmak için istek gönderdi. İsteği onaylamak veya reddetmek için Ekip Üyeleri sayfasını ziyaret edin.`,\n                      read: false,\n                      metadata: {\n                        teamId: selectedTeamId,\n                        teamName: teamName,\n                        requesterId: existingUser.uid,\n                        requesterName: requesterName,\n                        requesterEmail: email,\n                      },\n                    }).then(() => { }).catch(err => {\n                      if (import.meta.env.DEV) {\n                        console.error(\"Error sending notification to team leader:\", err);\n                      }\n                    })\n                  );\n                }\n\n                // Yöneticilere (super_admin, main_admin) bildirim gönder\n                try {\n                  const allUsers = await getAllUsers();\n                  const admins = allUsers.filter(u =>\n                    u.role?.includes(\"super_admin\") || u.role?.includes(\"main_admin\")\n                  );\n\n                  for (const admin of admins) {\n                    notificationPromises.push(\n                      createNotification({\n                        userId: admin.id,\n                        type: \"system\",\n                        title: \"Yeni ekip katılım isteği\",\n                        message: `${requesterName} \"${teamName}\" ekibine katılmak için istek gönderdi. İsteği onaylamak veya reddetmek için Ekip Onay Yönetimi sayfasını ziyaret edin.`,\n                        read: false,\n                        metadata: {\n                          teamId: selectedTeamId,\n                          teamName: teamName,\n                          requesterId: existingUser.uid,\n                          requesterName: requesterName,\n                          requesterEmail: email,\n                        },\n                      }).then(() => { }).catch(err => {\n                        if (import.meta.env.DEV) {\n                          console.error(`Error sending notification to admin ${admin.id}:`, err);\n                        }\n                      })\n                    );\n                  }\n                } catch (adminError) {\n                  if (import.meta.env.DEV) {\n                    console.error(\"Error getting admins for notification:\", adminError);\n                  }\n                }\n\n                // Tüm bildirimleri paralel gönder (await etmeden, arka planda)\n                Promise.allSettled(notificationPromises).catch(() => {\n                  // Bildirim hatası kayıt işlemini engellemez\n                });\n              }\n            } catch (notifError) {\n              if (import.meta.env.DEV) {\n                console.error(\"Error sending team request notifications:\", notifError);\n              }\n              // Bildirim hatası kayıt işlemini engellemez\n            }\n          }\n\n          // Display name ve email doğrulama mailini paralel gönder (hızlandırma)\n          const updatePromises: Promise<void>[] = [];\n          let emailVerificationError: Error | null = null;\n\n          updatePromises.push(updateProfile(existingUser, { displayName: fullName }).catch((error) => {\n            if (import.meta.env.DEV) {\n              console.error(\"Display name güncellenirken hata:\", error);\n            }\n          }));\n\n          // Doğrulama email'i gönder\n          updatePromises.push(\n            sendEmailVerification(existingUser)\n              .then(() => {\n                if (import.meta.env.DEV) {\n                  console.log(\"Email doğrulama maili gönderildi (mevcut kullanıcı):\", email);\n                }\n              })\n              .catch((verifyError) => {\n                if (import.meta.env.DEV) {\n                  console.error(\"Email doğrulama maili gönderilirken hata:\", verifyError);\n                }\n                emailVerificationError = new Error(\"Email doğrulama maili gönderilemedi. Lütfen daha sonra tekrar deneyin veya Firebase Console'da email ayarlarını kontrol edin.\");\n              })\n          );\n\n          // Tüm paralel işlemleri bekle\n          await Promise.allSettled(updatePromises);\n\n          // Email gönderim hatası varsa fırlat\n          if (emailVerificationError) {\n            await firebaseSignOut(auth);\n            throw emailVerificationError;\n          }\n\n          // Çıkış yap (kullanıcı email doğrulamadan giriş yapamaz)\n          await firebaseSignOut(auth);\n\n          return {\n            success: true,\n            message: \"Hesap var ama doğrulama yapılmamış. Doğrulama maili gönderildi. Lütfen e-postanızı ve spam kutusunu kontrol edin.\",\n            user: {\n              id: existingUser.uid,\n              email: email,\n              displayName: fullName,\n              fullName: fullName,\n              phone: phone || undefined,\n              dateOfBirth: dateOfBirth || undefined,\n              role: [\"viewer\"],\n              pendingTeams: selectedTeamId ? [selectedTeamId] : [],\n              approvedTeams: [],\n              emailVerified: false,\n              createdAt: new Date(),\n              updatedAt: new Date(),\n            },\n          };\n        }\n      } catch (loginError: unknown) {\n        // Giriş başarısız (şifre yanlış veya başka bir hata)\n        // Email zaten kayıtlı olduğu için \"bu hesap zaten kayıtlı\" mesajı göster\n        errorMessage = \"Bu hesap zaten kayıtlı. Lütfen giriş yapmayı deneyin.\";\n      }\n    } else if (errorCode === 'auth/invalid-email') {\n      errorMessage = \"Geçersiz e-posta adresi. Lütfen geçerli bir e-posta adresi girin.\";\n    } else if (errorCode === 'auth/weak-password') {\n      errorMessage = \"Şifre çok zayıf. Şifre en az 8 karakter, 1 büyük harf, 1 küçük harf ve 1 rakam içermelidir.\";\n    } else if (errorCode === 'auth/operation-not-allowed') {\n      errorMessage = \"E-posta/şifre ile kayıt şu anda devre dışı. Lütfen yöneticiye başvurun.\";\n    } else if (errorCode === 'auth/invalid-credential') {\n      // Email zaten kayıtlı ama şifre yanlış - \"bu hesap zaten kayıtlı\" mesajı göster\n      errorMessage = \"Bu hesap zaten kayıtlı. Lütfen giriş yapmayı deneyin.\";\n    } else if (errorCode === 'auth/user-disabled') {\n      errorMessage = \"Bu hesap devre dışı bırakılmış. Lütfen yöneticiye başvurun.\";\n    } else if (errorCode === 'auth/too-many-requests') {\n      errorMessage = \"Çok fazla istek yapıldı. Lütfen bir süre sonra tekrar deneyin.\";\n    } else if (errorCode === 'auth/network-request-failed') {\n      errorMessage = \"Ağ hatası. İnternet bağlantınızı kontrol edin.\";\n    } else if (errorCode === 'auth/internal-error') {\n      errorMessage = \"Sunucu hatası. Lütfen daha sonra tekrar deneyin.\";\n    } else if (errorCode === 'permission-denied' || errorMsg.includes('permissions')) {\n      errorMessage = \"Firestore izin hatası. Lütfen Firebase Console'da Security Rules'u kontrol edin. Detaylar: \" + (errorMsg || \"İzin reddedildi\");\n    } else if (errorMsg.includes('Unsupported field value: undefined')) {\n      errorMessage = \"Form verilerinde eksik veya geçersiz alanlar var. Lütfen tüm zorunlu alanları doldurun ve tekrar deneyin.\";\n    } else if (errorMsg.includes('invalid data')) {\n      errorMessage = \"Gönderilen veriler geçersiz. Lütfen tüm alanları kontrol edip tekrar deneyin.\";\n    } else if (errorMsg) {\n      errorMessage = errorMsg;\n    }\n\n    // Sadece beklenmeyen hatalar için console.error göster\n    // auth/email-already-in-use beklenen bir durum ve handle ediliyor, console'da gösterme\n    if (!isExpectedError && import.meta.env.DEV) {\n      console.error(\"Register error:\", error);\n    } else if (errorCode === 'auth/email-already-in-use' && import.meta.env.DEV) {\n      // Email zaten kayıtlı durumu handle edildi, sadece debug için log\n      console.debug(\"Email zaten kayıtlı, giriş yapmayı deniyoruz...\");\n    }\n\n    return {\n      success: false,\n      message: errorMessage,\n      user: null,\n    };\n  }\n};\n\n/**\n * Kullanıcı girişi\n */\nexport const login = async (\n  email: string,\n  password: string\n): Promise<{ success: boolean; message?: string; user?: UserProfile | null }> => {\n  try {\n    if (!auth || !firestore) {\n      throw new Error('Firebase is not initialized');\n    }\n    // Firebase Auth ile giriş yap\n    const userCredential = await signInWithEmailAndPassword(auth, email, password);\n    let firebaseUser = userCredential.user;\n\n    // Firebase Auth'daki user objesini reload et (emailVerified değerinin güncel olması için)\n    try {\n      if (import.meta.env.DEV) {\n        console.log(\"Login - User reload öncesi emailVerified:\", firebaseUser.emailVerified);\n      }\n      await firebaseUser.reload();\n      // reload() sonrası firebaseUser objesi güncellenmiş olmalı\n      // Ayrıca auth.currentUser'ı da kontrol et (bazen daha güncel olabilir)\n      if (auth.currentUser) {\n        firebaseUser = auth.currentUser;\n      }\n      if (import.meta.env.DEV) {\n        console.log(\"Login - User reload sonrası emailVerified:\", firebaseUser.emailVerified);\n        console.log(\"Login - auth.currentUser emailVerified:\", auth.currentUser?.emailVerified);\n      }\n    } catch (reloadError) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Login - User reload hatası (devam ediliyor):\", reloadError);\n      }\n      // Reload hatası olsa bile devam et\n    }\n\n    // Önce direkt Firestore'dan silinmiş kullanıcı kontrolü yap\n    try {\n      const userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n      if (userDoc.exists()) {\n        const userData = userDoc.data();\n        if (userData.deleted === true) {\n          // Hemen çıkış yap\n          try {\n            await firebaseSignOut(auth);\n          } catch (signOutError) {\n            if (import.meta.env.DEV) {\n              if (import.meta.env.DEV) {\n                console.error(\"Çıkış yapılırken hata:\", signOutError);\n              }\n            }\n          }\n          return {\n            success: false,\n            message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n            user: null,\n          };\n        }\n      }\n    } catch (checkError) {\n      console.error(\"Kullanıcı kontrolü hatası:\", checkError);\n      // Kontrol hatası olsa bile devam et, getUserProfile kontrol edecek\n    }\n\n    try {\n      let userProfile: UserProfile | null = null;\n      let isDeletedAccount = false;\n\n      // getUserProfile() çağrısını try-catch ile sarmalayalım\n      // Çünkü silinmiş kullanıcı için hata fırlatıyor\n      try {\n        userProfile = await getUserProfile(firebaseUser.uid);\n      } catch (profileError: unknown) {\n        // Eğer hata mesajı \"silinmiş\" içeriyorsa, silinmiş hesap\n        const errorMsg = profileError instanceof Error ? profileError.message : String(profileError);\n        if (errorMsg.includes(\"silinmiş\")) {\n          isDeletedAccount = true;\n        } else {\n          // Diğer hatalar için null olarak devam et\n          if (import.meta.env.DEV) {\n            console.warn(\"getUserProfile hatası (devam ediliyor):\", profileError);\n          }\n        }\n      }\n\n      // Eğer silinmiş hesap ise, uyarı ver ve çıkış yap\n      if (isDeletedAccount) {\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n        }\n        return {\n          success: false,\n          message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n          user: null,\n        };\n      }\n\n      // Eğer userProfile null ise, Firestore'dan direkt kontrol et\n      // Çünkü null dönmesi sadece silinmiş hesap anlamına gelmez\n      // (doküman yoksa, permission hatası varsa da null dönebilir)\n      if (!userProfile) {\n        // Firestore'dan direkt kontrol et - silinmiş mi değil mi?\n        try {\n          const userDocCheck = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n          if (userDocCheck.exists()) {\n            const userDataCheck = userDocCheck.data();\n            // Eğer doküman varsa ve silinmişse, o zaman silinmiş hesap uyarısı ver\n            if (userDataCheck.deleted === true) {\n              try {\n                await firebaseSignOut(auth);\n              } catch (signOutError) {\n                if (import.meta.env.DEV) {\n                  console.error(\"Çıkış yapılırken hata:\", signOutError);\n                }\n              }\n              return {\n                success: false,\n                message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n                user: null,\n              };\n            }\n            // Doküman var ama getUserProfile null döndü - tekrar deneyelim\n            // Belki Firestore eventual consistency nedeniyle gecikti\n            await new Promise(resolve => setTimeout(resolve, 200));\n            try {\n              userProfile = await getUserProfile(firebaseUser.uid);\n            } catch (retryError: unknown) {\n              // Eğer hata mesajı \"silinmiş\" içeriyorsa, silinmiş hesap\n              const errorMsg = retryError instanceof Error ? retryError.message : String(retryError);\n              if (errorMsg.includes(\"silinmiş\")) {\n                try {\n                  await firebaseSignOut(auth);\n                } catch (signOutError) {\n                  if (import.meta.env.DEV) {\n                    console.error(\"Çıkış yapılırken hata:\", signOutError);\n                  }\n                }\n                return {\n                  success: false,\n                  message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n                  user: null,\n                };\n              }\n              // Diğer hatalar için null olarak devam et\n              if (import.meta.env.DEV) {\n                console.warn(\"getUserProfile retry hatası (devam ediliyor):\", retryError);\n              }\n            }\n          } else {\n            // Doküman yoksa, profil oluşturulmamış olabilir\n            // Yeni kayıt olmuş ama Firestore'a yazılmamış - profil oluştur\n            await setDoc(doc(firestore, \"users\", firebaseUser.uid), {\n              email: firebaseUser.email || email,\n              displayName: firebaseUser.displayName || \"\",\n              fullName: firebaseUser.displayName || \"\",\n              role: [\"viewer\"],\n              emailVerified: firebaseUser.emailVerified || false,\n              needsEmailVerification: !firebaseUser.emailVerified,\n              createdAt: serverTimestamp(),\n              updatedAt: serverTimestamp(),\n              pendingTeams: [],\n              approvedTeams: [],\n            });\n            // Profili tekrar al\n            await new Promise(resolve => setTimeout(resolve, 200));\n            try {\n              userProfile = await getUserProfile(firebaseUser.uid);\n            } catch (profileRetryError: unknown) {\n              // Eğer hata mesajı \"silinmiş\" içeriyorsa, silinmiş hesap\n              const errorMsg = profileRetryError instanceof Error ? profileRetryError.message : String(profileRetryError);\n              if (errorMsg.includes(\"silinmiş\")) {\n                try {\n                  await firebaseSignOut(auth);\n                } catch (signOutError) {\n                  if (import.meta.env.DEV) {\n                    console.error(\"Çıkış yapılırken hata:\", signOutError);\n                  }\n                }\n                return {\n                  success: false,\n                  message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n                  user: null,\n                };\n              }\n              // Diğer hatalar için null olarak devam et\n              if (import.meta.env.DEV) {\n                console.warn(\"getUserProfile profil oluşturma sonrası hatası (devam ediliyor):\", profileRetryError);\n              }\n            }\n          }\n        } catch (profileCheckError) {\n          // Firestore kontrolü başarısız olsa bile devam et\n          // Email doğrulama kontrolü yapılacak\n          if (import.meta.env.DEV) {\n            console.warn(\"Profil kontrolü hatası (devam ediliyor):\", profileCheckError);\n          }\n        }\n      }\n\n      // Eğer hala userProfile null ise, email doğrulama kontrolüne devam et\n      // (aşağıdaki kod devam edecek, email doğrulama kontrolü yapılacak)\n\n      // Email doğrulaması kontrolü - email doğrulanmamışsa giriş yapılamaz\n      // ÖNCE Firestore'dan kontrol et (needsEmailVerification flag'i için)\n      // Firestore'un eventual consistency özelliği nedeniyle birkaç kez deneyebiliriz\n      let userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n      let needsEmailVerification = false;\n      let retryCount = 0;\n      const maxRetries = 2;\n\n      // Eğer doküman yoksa veya needsEmailVerification undefined ise, birkaç kez daha dene\n      while (retryCount < maxRetries && (!userDoc.exists() || userDoc.data()?.needsEmailVerification === undefined)) {\n        if (import.meta.env.DEV) {\n          console.log(`Login - Firestore dokümanı kontrol ediliyor (retry ${retryCount + 1}/${maxRetries})`);\n        }\n        await new Promise(resolve => setTimeout(resolve, 200)); // 200ms bekle\n        userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n        retryCount++;\n      }\n\n      if (userDoc.exists()) {\n        const userData = userDoc.data();\n        // needsEmailVerification kontrolü: true, \"true\", 1 gibi değerleri kabul et\n        needsEmailVerification = userData.needsEmailVerification === true ||\n          userData.needsEmailVerification === \"true\" ||\n          userData.needsEmailVerification === 1;\n\n        if (import.meta.env.DEV) {\n          console.log(\"Login - Email doğrulama kontrolü:\", {\n            needsEmailVerification,\n            rawNeedsEmailVerification: userData.needsEmailVerification,\n            firebaseEmailVerified: firebaseUser.emailVerified,\n            firestoreEmailVerified: userData.emailVerified,\n            userProfileEmailVerified: userProfile?.emailVerified,\n            retryCount,\n            userData: {\n              needsEmailVerification: userData.needsEmailVerification,\n              emailVerified: userData.emailVerified,\n            }\n          });\n        }\n      } else {\n        if (import.meta.env.DEV) {\n          console.warn(\"Login - Firestore dokümanı bulunamadı, email doğrulama kontrolü yapılamıyor\");\n        }\n      }\n\n      // Email doğrulama durumu: Firebase Auth en güncel kaynak, bu yüzden öncelikli\n      // SIKI KONTROL: Email doğrulanmamışsa MUTLAKA giriş yapılamaz (needsEmailVerification flag'ine bakmadan)\n      // reload() sonrası firebaseUser.emailVerified güncellenmiş olmalı\n      // Eğer hala false ise, Firestore'daki değere de bak (senkronizasyon sorunu olabilir)\n      let emailVerified = firebaseUser.emailVerified;\n      // Eğer Firebase Auth'da false ama Firestore'da true ise, Firestore'a güven\n      // (Firebase Auth daha güncel olmalı ama senkronizasyon sorunu olabilir)\n      if (!emailVerified && userDoc.exists()) {\n        const userData = userDoc.data();\n        if (userData.emailVerified === true) {\n          if (import.meta.env.DEV) {\n            console.warn(\"Login - Firebase Auth'da emailVerified false ama Firestore'da true, Firestore'a güveniliyor\");\n          }\n          // Firestore'daki değere güven ama Firebase Auth'ı da güncelle\n          emailVerified = true;\n        }\n      }\n\n      // Email doğrulama kontrolü: Config'e göre email doğrulaması zorunlu mu?\n      // Kayıt ve login senkronize çalışmalı - her ikisi de aynı mantığı kullanmalı\n      if (REQUIRE_EMAIL_VERIFICATION && !emailVerified) {\n        if (import.meta.env.DEV) {\n          console.log(\"Login - Email doğrulama gerekli (REQUIRE_EMAIL_VERIFICATION=true), giriş engelleniyor\", {\n            emailVerified,\n            needsEmailVerification,\n            firebaseEmailVerified: firebaseUser.emailVerified,\n          });\n        }\n\n        // Eğer needsEmailVerification flag'i false veya undefined ise, Firestore'u güncelle\n        // (Kayıt sırasında set edilmiş olmalı ama senkronizasyon için tekrar set et)\n        if (!needsEmailVerification) {\n          try {\n            await updateDoc(doc(firestore, \"users\", firebaseUser.uid), {\n              needsEmailVerification: true,\n              emailVerified: false,\n              updatedAt: serverTimestamp(),\n            });\n            if (import.meta.env.DEV) {\n              console.log(\"Login - needsEmailVerification flag'i Firestore'da güncellendi (true)\");\n            }\n          } catch (updateError) {\n            if (import.meta.env.DEV) {\n              console.error(\"Login - needsEmailVerification flag güncellenirken hata:\", updateError);\n            }\n            // Hata olsa bile devam et, email göndermeye çalış\n          }\n        }\n\n        // Doğrulama email'i tekrar gönder - RESEND_VERIFICATION_ON_LOGIN config'e göre\n        if (RESEND_VERIFICATION_ON_LOGIN) {\n          try {\n            await sendEmailVerification(firebaseUser);\n            if (import.meta.env.DEV) {\n              console.log(\"Email doğrulama maili gönderildi (giriş denemesi):\", email);\n            }\n          } catch (verifyError: unknown) {\n            const errorCode = (verifyError as { code?: string })?.code;\n            const errorMsg = verifyError instanceof Error ? verifyError.message : String(verifyError);\n\n            if (import.meta.env.DEV) {\n              console.error(\"Doğrulama email'i gönderilirken hata:\", verifyError);\n            }\n\n            // Email gönderilemedi, kullanıcıya bilgi ver\n            let errorMessage = \"Email doğrulama maili gönderilemedi.\";\n            if (errorCode === 'auth/too-many-requests') {\n              errorMessage = \"Çok fazla istek yapıldı. Lütfen bir süre sonra tekrar deneyin.\";\n            } else if (errorCode === 'auth/network-request-failed') {\n              errorMessage = \"Ağ hatası. İnternet bağlantınızı kontrol edin.\";\n            } else if (errorMsg) {\n              errorMessage = errorMsg;\n            }\n\n            // Çıkış yap (kullanıcı email doğrulamadan giriş yapamaz)\n            try {\n              await firebaseSignOut(auth);\n            } catch (signOutError) {\n              if (import.meta.env.DEV) {\n                console.error(\"Çıkış yapılırken hata:\", signOutError);\n              }\n            }\n\n            return {\n              success: false,\n              message: errorMessage + \" Lütfen daha sonra tekrar deneyin veya spam kutunuzu kontrol edin.\",\n              user: null,\n            };\n          }\n        }\n\n        // Çıkış yap (kullanıcı email doğrulamadan giriş yapamaz)\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n        }\n\n        return {\n          success: false,\n          message: \"E-posta adresinizi doğrulamalısınız. Doğrulama e-postası gönderildi. Lütfen e-postanızı ve spam kutusunu kontrol edin.\",\n          user: null,\n        };\n      } else if (!emailVerified) {\n        // Email doğrulama zorunlu değil ama email doğrulanmamış - uyarı log'u\n        if (import.meta.env.DEV) {\n          console.log(\"Login - Email doğrulanmamış ama REQUIRE_EMAIL_VERIFICATION=false, giriş izin verildi\");\n        }\n      } else {\n        // Email doğrulandı - giriş yapılabilir\n        if (import.meta.env.DEV) {\n          console.log(\"Login - Email doğrulama kontrolü geçildi:\", {\n            needsEmailVerification,\n            emailVerified,\n            firebaseEmailVerified: firebaseUser.emailVerified,\n          });\n        }\n      }\n\n      // Email doğrulama durumunu Firestore ile senkronize et\n      // Firebase Auth'daki emailVerified değeri Firestore'dan daha güncel olabilir\n      if (emailVerified) {\n        // Email doğrulandıysa needsEmailVerification flag'ini kaldır ve Firestore'u güncelle\n        try {\n          await updateDoc(doc(firestore, \"users\", firebaseUser.uid), {\n            needsEmailVerification: false,\n            emailVerified: true,\n            updatedAt: serverTimestamp(),\n          });\n          // userProfile'i güncelle (eğer varsa)\n          if (userProfile) {\n            userProfile.emailVerified = true;\n          }\n        } catch (updateError) {\n          if (import.meta.env.DEV) {\n            console.error(\"EmailVerified flag güncellenirken hata:\", updateError);\n          }\n        }\n      }\n\n      // Eğer userProfile hala null ise, tekrar al\n      if (!userProfile) {\n        try {\n          userProfile = await getUserProfile(firebaseUser.uid);\n        } catch (profileError: unknown) {\n          // Eğer hata mesajı \"silinmiş\" içeriyorsa, silinmiş hesap\n          const errorMsg = profileError instanceof Error ? profileError.message : String(profileError);\n          if (errorMsg.includes(\"silinmiş\")) {\n            try {\n              await firebaseSignOut(auth);\n            } catch (signOutError) {\n              if (import.meta.env.DEV) {\n                console.error(\"Çıkış yapılırken hata:\", signOutError);\n              }\n            }\n            return {\n              success: false,\n              message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n              user: null,\n            };\n          }\n          // Diğer hatalar için null olarak devam et\n          if (import.meta.env.DEV) {\n            console.warn(\"getUserProfile hatası (devam ediliyor):\", profileError);\n          }\n        }\n        // Hala null ise, hata ver\n        if (!userProfile) {\n          try {\n            await firebaseSignOut(auth);\n          } catch (signOutError) {\n            if (import.meta.env.DEV) {\n              console.error(\"Çıkış yapılırken hata:\", signOutError);\n            }\n          }\n          return {\n            success: false,\n            message: \"Kullanıcı profili alınamadı. Lütfen tekrar deneyin.\",\n            user: null,\n          };\n        }\n      }\n\n      // Son giriş zamanını güncelle - serverTimestamp() kullanarak sunucu zamanını kaydet\n      try {\n        const oldLastLoginAt = userProfile.lastLoginAt;\n        // serverTimestamp() kullanarak Firebase sunucusunun zamanını kaydet (daha doğru)\n        await updateDoc(doc(firestore, \"users\", firebaseUser.uid), {\n          lastLoginAt: serverTimestamp(),\n        });\n\n        // Profili yeniden yükle (güncellenmiş lastLoginAt ile)\n        // Not: serverTimestamp() async olduğu için hemen okumak doğru zamanı vermeyebilir\n        // Bu yüzden bir miktar bekleyip tekrar yükleyelim veya client-side timestamp ile güncelleyelim\n        await new Promise(resolve => setTimeout(resolve, 100)); // 100ms bekle\n\n        const updatedProfile = await getUserProfile(firebaseUser.uid);\n        if (updatedProfile) {\n          userProfile = updatedProfile;\n        }\n\n        // Giriş logunu kaydet (retry mekanizması ile)\n        try {\n          const loginTime = new Date().toISOString();\n          const oldLastLoginAtValue = oldLastLoginAt ? (oldLastLoginAt instanceof Timestamp ? oldLastLoginAt.toDate().toISOString() : String(oldLastLoginAt)) : null;\n\n          let retryCount = 0;\n          const maxRetries = 2;\n          while (retryCount <= maxRetries) {\n            try {\n              await logAudit(\n                \"UPDATE\",\n                \"user_logins\",\n                firebaseUser.uid,\n                firebaseUser.uid,\n                oldLastLoginAtValue ? { lastLoginAt: oldLastLoginAtValue } : null,\n                null,\n                {\n                  action: \"LOGIN\",\n                  method: \"EMAIL\",\n                  email: email,\n                  timestamp: loginTime\n                }\n              );\n              break; // Başarılı oldu, döngüden çık\n            } catch (retryError) {\n              retryCount++;\n              if (retryCount > maxRetries) {\n                if (import.meta.env.DEV) {\n                  console.error(\"Giriş logu kaydedilirken hata (tüm denemeler başarısız):\", retryError);\n                }\n              } else {\n                // Kısa bir bekleme sonrası tekrar dene\n                await new Promise(resolve => setTimeout(resolve, 100 * retryCount));\n              }\n            }\n          }\n        } catch (logError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Giriş logu kaydedilirken beklenmeyen hata:\", logError);\n          }\n          // Log hatası girişi engellememeli\n        }\n      } catch (updateError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Son giriş zamanı güncellenirken hata:\", updateError);\n        }\n        // Hata olsa bile giriş devam etsin\n      }\n\n      return {\n        success: true,\n        user: userProfile,\n      };\n    } catch (profileError: unknown) {\n      // Silinmiş kullanıcı hatası\n      if (profileError instanceof Error && profileError.message?.includes(\"silinmiş\")) {\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n        }\n        return {\n          success: false,\n          message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n          user: null,\n        };\n      }\n      // Diğer hatalar için tekrar fırlat\n      throw profileError;\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Login error:\", error);\n    }\n\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    // Eğer zaten çıkış yapıldıysa (silinmiş kullanıcı), hata mesajını döndür\n    if (errorMsg.includes(\"silinmiş\")) {\n      return {\n        success: false,\n        message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n        user: null,\n      };\n    }\n\n    // Firebase hata kodlarını Türkçe'ye çevir\n    let errorMessage = \"Giriş başarısız\";\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n\n    if (errorObj?.code === 'auth/user-not-found') {\n      errorMessage = \"Bu e-posta adresi kayıtlı değil. Lütfen kayıt olun.\";\n    } else if (errorObj?.code === 'auth/wrong-password' || errorObj?.code === 'auth/invalid-credential') {\n      errorMessage = \"E-posta adresi veya şifre hatalı. Lütfen bilgilerinizi kontrol edip tekrar deneyin.\";\n    } else if (errorObj?.code === 'auth/invalid-email') {\n      errorMessage = \"Geçersiz e-posta adresi. Lütfen geçerli bir e-posta adresi girin.\";\n    } else if (errorObj?.code === 'auth/user-disabled') {\n      errorMessage = \"Bu hesap devre dışı bırakılmış. Lütfen yöneticiye başvurun.\";\n    } else if (errorObj?.code === 'auth/too-many-requests') {\n      errorMessage = \"Çok fazla başarısız giriş denemesi. Lütfen birkaç dakika sonra tekrar deneyin.\";\n    } else if (errorObj?.code === 'auth/network-request-failed') {\n      errorMessage = \"İnternet bağlantınızı kontrol edin ve tekrar deneyin.\";\n    } else if (errorObj?.message) {\n      errorMessage = errorObj.message;\n    }\n\n    return {\n      success: false,\n      message: errorMessage,\n      user: null,\n    };\n  }\n};\n\n/**\n * Kullanıcı çıkışı\n */\nexport const logout = async (): Promise<{ success: boolean; message?: string }> => {\n  try {\n    if (!auth) {\n      return { success: false, message: 'Firebase Auth is not initialized' };\n    }\n\n    // Çıkış yapmadan önce kullanıcı ID'sini al\n    const userId = auth.currentUser?.uid;\n    const userEmail = auth.currentUser?.email;\n\n    // Çıkış logunu kaydet (çıkış yapmadan önce, retry mekanizması ile)\n    if (userId) {\n      try {\n        const logoutTime = new Date().toISOString();\n\n        let retryCount = 0;\n        const maxRetries = 2;\n        while (retryCount <= maxRetries) {\n          try {\n            await logAudit(\n              \"UPDATE\",\n              \"user_logins\",\n              userId,\n              userId,\n              null,\n              null,\n              {\n                action: \"LOGOUT\",\n                timestamp: logoutTime,\n                email: userEmail || null\n              }\n            );\n            break; // Başarılı oldu, döngüden çık\n          } catch (retryError) {\n            retryCount++;\n            if (retryCount > maxRetries) {\n              if (import.meta.env.DEV) {\n                console.error(\"Çıkış logu kaydedilirken hata (tüm denemeler başarısız):\", retryError);\n              }\n            } else {\n              // Kısa bir bekleme sonrası tekrar dene\n              await new Promise(resolve => setTimeout(resolve, 100 * retryCount));\n            }\n          }\n        }\n      } catch (logError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Çıkış logu kaydedilirken beklenmeyen hata:\", logError);\n        }\n        // Log hatası çıkışı engellememeli\n      }\n    }\n\n    await firebaseSignOut(auth);\n    return { success: true };\n  } catch (error: unknown) {\n    console.error(\"Logout error:\", error);\n    return {\n      success: false,\n      message: (error && typeof error === 'object' && 'message' in error ? (error as { message?: string }).message : undefined) || \"Çıkış başarısız\",\n    };\n  }\n};\n\n/**\n * Şifre sıfırlama\n */\nexport const resetPassword = async (email: string): Promise<{ success: boolean; message?: string }> => {\n  try {\n    if (!auth || !firestore) {\n      throw new Error('Firebase is not initialized');\n    }\n\n    // Önce email'in kayıtlı olup olmadığını Firestore'dan kontrol et\n    // Güvenlik nedeniyle Firebase Auth'da direkt kontrol yapamayız ama Firestore'dan kontrol edebiliriz\n    try {\n      const usersRef = collection(firestore, \"users\");\n      const q = query(usersRef, where(\"email\", \"==\", email), limit(1));\n      const querySnapshot = await getDocs(q);\n\n      if (querySnapshot.empty) {\n        // Email kayıtlı değil\n        return {\n          success: false,\n          message: \"Bu e-posta adresi kayıtlı değil. Lütfen kayıt olun.\",\n        };\n      }\n\n      // Email kayıtlı, silinmiş hesap kontrolü\n      const userDoc = querySnapshot.docs[0];\n      const userData = userDoc.data();\n      if (userData.deleted === true) {\n        return {\n          success: false,\n          message: \"Bu hesap silinmiş. Lütfen yeni bir hesap oluşturun.\",\n        };\n      }\n    } catch (checkError) {\n      // Firestore kontrolü başarısız olsa bile devam et\n      // Firebase Auth kendi kontrolünü yapacak\n      if (import.meta.env.DEV) {\n        console.warn(\"Email kontrolü yapılırken hata:\", checkError);\n      }\n    }\n\n    // Firebase'in şifre sıfırlama e-postasını gönder\n    await sendPasswordResetEmail(auth, email);\n    return {\n      success: true,\n      message: \"Şifre sıfırlama e-postası gönderildi. Lütfen e-postanızı ve spam kutusunu kontrol edin.\"\n    };\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Reset password error:\", error);\n    }\n    // Firebase hata kodlarını Türkçe'ye çevir\n    let errorMessage = \"Şifre sıfırlama başarısız\";\n    const errorObj = error && typeof error === 'object' && 'code' in error ? error as { code?: string; message?: string } : null;\n    if (errorObj?.code === 'auth/user-not-found') {\n      errorMessage = \"Bu e-posta adresi kayıtlı değil. Lütfen kayıt olun.\";\n    } else if (errorObj?.code === 'auth/invalid-email') {\n      errorMessage = \"Geçersiz e-posta adresi. Lütfen geçerli bir e-posta adresi girin.\";\n    } else if (errorObj?.code === 'auth/too-many-requests') {\n      errorMessage = \"Çok fazla istek yapıldı. Lütfen bir süre sonra tekrar deneyin.\";\n    } else if (errorObj?.message) {\n      errorMessage = errorObj.message;\n    }\n    return {\n      success: false,\n      message: errorMessage,\n    };\n  }\n};\n\n/**\n * Kullanıcı profilini Firestore'dan al\n */\nexport const getUserProfile = async (userId: string, allowDeleted: boolean = false): Promise<UserProfile | null> => {\n  try {\n    if (!firestore) {\n      console.error('Firestore is not initialized');\n      return null;\n    }\n    const userDoc = await getDoc(doc(firestore, \"users\", userId));\n\n    if (!userDoc.exists()) {\n      return null;\n    }\n\n    const data = userDoc.data();\n    const firebaseUser = auth?.currentUser || null;\n\n    // Silinmiş kullanıcı kontrolü\n    if (data.deleted === true) {\n      // Eğer allowDeleted true ise, silinmiş kullanıcı bilgilerini döndür (sadece okuma için)\n      if (allowDeleted) {\n        return {\n          id: userId,\n          email: data.email || \"\",\n          displayName: \"Silinmiş Kullanıcı\",\n          fullName: \"Silinmiş Kullanıcı\",\n          phone: null,\n          dateOfBirth: null,\n          role: [],\n          departmentId: null,\n          emailVerified: false,\n          createdAt: data.createdAt,\n          updatedAt: data.updatedAt,\n        };\n      }\n      // Mevcut kullanıcı kendi profilini alıyorsa ve silinmişse, otomatik çıkış yap\n      if (firebaseUser && firebaseUser.uid === userId && auth) {\n        // Çıkış yap, await ile bekle\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n          // Çıkış hatası olsa bile devam et\n        }\n      }\n      throw new Error(\"Bu hesap silinmiş. Giriş yapamazsınız.\");\n    }\n\n    // Rolleri roles collection'ındaki tanımlarla senkronize et\n    const { getRoles } = await import(\"./rolePermissionsService\");\n    const definedRoles = await getRoles();\n    const definedRoleKeys = new Set(definedRoles.map(r => r.key));\n    const userRoles = (data.role || []) as string[];\n    const validRoles = userRoles.filter(role => definedRoleKeys.has(role));\n    const finalRoles = validRoles.length > 0 ? validRoles : [\"personnel\"];\n\n    // Eğer roller değiştiyse, veritabanını güncelle\n    if (JSON.stringify(userRoles) !== JSON.stringify(finalRoles)) {\n      await updateDoc(userDoc.ref, { role: finalRoles });\n    }\n\n    return {\n      id: userId,\n      email: data.email || firebaseUser?.email || \"\",\n      displayName: data.displayName || firebaseUser?.displayName || \"\",\n      fullName: data.fullName,\n      phone: data.phone,\n      dateOfBirth: data.dateOfBirth,\n      role: finalRoles,\n      departmentId: data.departmentId,\n      emailVerified: firebaseUser?.emailVerified || data.emailVerified || false,\n      createdAt: data.createdAt,\n      updatedAt: data.updatedAt,\n      lastLoginAt: data.lastLoginAt,\n    };\n  } catch (error: unknown) {\n    // Permission hatalarını sessizce handle et (giriş yapmadan normal)\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n\n    if (errorObj?.code === 'permission-denied' || errorObj?.message?.includes('permissions')) {\n      // Permission hatası beklenen bir durum (giriş yapmadan), sessizce handle et\n      if (import.meta.env.DEV) {\n        console.debug(\"Permission hatası (beklenen): Kullanıcı giriş yapmamış olabilir\");\n      }\n    } else if (import.meta.env.DEV) {\n      console.error(\"Get user profile error:\", error);\n    }\n\n    return null;\n  }\n};\n\n/**\n * Kullanıcı profilini güncelle\n */\nexport const updateUserProfile = async (\n  userId: string,\n  updates: Partial<Omit<UserProfile, \"id\" | \"email\" | \"emailVerified\" | \"createdAt\" | \"updatedAt\">>,\n  updatedBy?: string | null\n): Promise<{ success: boolean; message?: string }> => {\n  try {\n    if (!firestore) {\n      throw new Error('Firestore is not initialized');\n    }\n\n    // Eski veriyi al (audit log için)\n    const oldProfile = await getUserProfile(userId);\n\n    // Firestore undefined değerleri kabul etmez, bu yüzden undefined alanları temizle\n    const cleanUpdates: Record<string, unknown> = {\n      updatedAt: serverTimestamp(),\n    };\n\n    Object.keys(updates).forEach((key) => {\n      const value = (updates as Record<string, unknown>)[key];\n      if (value !== undefined) {\n        cleanUpdates[key] = value;\n      }\n    });\n\n    await updateDoc(doc(firestore, \"users\", userId), cleanUpdates);\n\n    // Firebase Auth'ta displayName güncelle\n    if (updates.displayName && auth?.currentUser) {\n      await updateProfile(auth.currentUser, {\n        displayName: updates.displayName,\n      });\n    }\n\n    // Audit log (rol değişiklikleri hariç - rol değişiklikleri UserManagement'da ayrı loglanıyor)\n    const logUserId = updatedBy || auth?.currentUser?.uid;\n    if (logUserId && oldProfile) {\n      // Rol değişikliği kontrolü - eğer sadece rol değiştiyse log ekleme\n      const hasRoleChange = updates.role && JSON.stringify(updates.role) !== JSON.stringify(oldProfile.role);\n      const hasOtherChanges = Object.keys(updates).some(key => key !== \"role\");\n\n      // Eğer rol değişikliği varsa ve başka değişiklik yoksa log ekleme (rol değişiklikleri UserManagement'da loglanıyor)\n      if (!hasRoleChange || hasOtherChanges) {\n        const newProfile = await getUserProfile(userId);\n        await logAudit(\n          \"UPDATE\",\n          \"users\",\n          userId,\n          logUserId,\n          oldProfile,\n          newProfile,\n          { action: \"update_profile\", changedFields: Object.keys(updates).filter(k => k !== \"role\") }\n        );\n      }\n    }\n\n    return { success: true };\n  } catch (error: unknown) {\n    console.error(\"Update user profile error:\", error);\n    return {\n      success: false,\n      message: (error && typeof error === 'object' && 'message' in error ? (error as { message?: string }).message : undefined) || \"Profil güncellenemedi\",\n    };\n  }\n};\n\n/**\n * Kullanıcı profilini güncelle (alias for updateUserProfile)\n */\nexport const updateFirebaseUserProfile = updateUserProfile;\n\n/**\n * Auth state değişikliklerini dinle\n */\n// Son giriş zamanını güncellemek için kullanılan flag (duplicate güncellemeleri önlemek için)\nlet lastLoginUpdateTime: Map<string, number> = new Map();\n\nexport const onAuthChange = (callback: (user: UserProfile | null) => void) => {\n  if (!auth) {\n    if (import.meta.env.DEV) {\n      console.error('Firebase Auth is not initialized');\n      console.warn('Firebase yapılandırması eksik olabilir. Lütfen .env dosyasını kontrol edin.');\n    }\n    // Hemen callback çağır (loading state'i false yapmak için)\n    // Firebase başlatılamazsa kullanıcı auth sayfasına yönlendirilecek\n    setTimeout(() => callback(null), 0);\n    return () => { }; // Return empty unsubscribe function\n  }\n\n  // Firestore kontrolü - opsiyonel ama önerilir\n  if (!firestore) {\n    if (import.meta.env.DEV) {\n      console.warn('Firestore is not initialized - bazı özellikler çalışmayabilir');\n    }\n    // Firestore olmadan da devam edebiliriz, sadece user profile alınamaz\n  }\n\n  // Timeout: Eğer 3 saniye içinde auth state gelmezse callback(null) çağır\n  let timeoutFired = false;\n  const timeout = setTimeout(() => {\n    if (!timeoutFired) {\n      console.warn('Auth state timeout - callback(null) çağrılıyor');\n      timeoutFired = true;\n      callback(null);\n    }\n  }, 3000);\n\n  const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {\n    // Async callback'i promise olarak wrap et ve unhandled rejection'ları yakala\n    (async () => {\n      try {\n        // Timeout'u iptal et - auth state geldi\n        if (!timeoutFired) {\n          clearTimeout(timeout);\n          timeoutFired = true;\n        }\n\n        if (firebaseUser) {\n          // Önce direkt Firestore'dan silinmiş kullanıcı kontrolü yap\n          if (firestore) {\n            try {\n              const userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n              if (userDoc.exists()) {\n                const userData = userDoc.data();\n                if (userData.deleted === true) {\n                  // Hemen çıkış yap\n                  try {\n                    await firebaseSignOut(auth);\n                  } catch (signOutError) {\n                    if (import.meta.env.DEV) {\n                      if (import.meta.env.DEV) {\n                        console.error(\"Çıkış yapılırken hata:\", signOutError);\n                      }\n                    }\n                  }\n                  callback(null);\n                  return;\n                }\n              }\n            } catch (checkError) {\n              if (import.meta.env.DEV) {\n                console.error(\"Kullanıcı kontrolü hatası:\", checkError);\n              }\n              // Kontrol hatası olsa bile devam et, getUserProfile kontrol edecek\n            }\n          }\n\n          try {\n            let userProfile = await getUserProfile(firebaseUser.uid);\n            // Eğer userProfile null ise (silinmiş kullanıcı), çıkış yap\n            if (!userProfile) {\n              try {\n                await firebaseSignOut(auth);\n              } catch (signOutError) {\n                if (import.meta.env.DEV) {\n                  if (import.meta.env.DEV) {\n                    console.error(\"Çıkış yapılırken hata:\", signOutError);\n                  }\n                }\n              }\n              callback(null);\n              return;\n            }\n\n            // Email doğrulandıysa needsEmailVerification flag'ini kaldır ve emailVerified'i güncelle\n            if (firestore && firebaseUser.emailVerified) {\n              try {\n                const userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n                if (userDoc.exists()) {\n                  const userData = userDoc.data();\n                  const updateData: any = {};\n\n                  // Email doğrulandıysa flag'leri güncelle\n                  if (userData.needsEmailVerification === true) {\n                    updateData.needsEmailVerification = false;\n                  }\n                  if (!userData.emailVerified || userData.emailVerified === false) {\n                    updateData.emailVerified = true;\n                  }\n\n                  // Eğer güncellenecek bir şey varsa güncelle\n                  if (Object.keys(updateData).length > 0) {\n                    updateData.updatedAt = serverTimestamp();\n                    await updateDoc(doc(firestore, \"users\", firebaseUser.uid), updateData);\n\n                    // Firestore güncellendikten sonra userProfile'i yeniden yükle\n                    // Böylece güncellenmiş emailVerified değeri kullanılır\n                    userProfile = await getUserProfile(firebaseUser.uid);\n                    if (!userProfile) {\n                      callback(null);\n                      return;\n                    }\n                  }\n                }\n              } catch (updateError) {\n                if (import.meta.env.DEV) {\n                  console.error(\"Email doğrulama flag güncellenirken hata:\", updateError);\n                }\n              }\n            }\n\n            // Son giriş zamanını güncelle (sadece gerektiğinde, duplicate güncellemeleri önlemek için)\n            // Not: login() ve signInWithGoogle() fonksiyonlarında zaten güncelleniyor,\n            // burada sadece sayfa yenilendiğinde veya başka bir cihazdan giriş yapıldığında güncellenmeli\n            const now = Date.now();\n            const lastUpdate = lastLoginUpdateTime.get(firebaseUser.uid) || 0;\n            const timeSinceLastUpdate = now - lastUpdate;\n\n            // Eğer son güncellemeden 1 dakikadan fazla zaman geçtiyse veya hiç güncellenmemişse\n            // (1 dakika yeterli, çünkü login() ve signInWithGoogle() zaten güncelliyor)\n            if (timeSinceLastUpdate > 1 * 60 * 1000 || lastUpdate === 0) {\n              try {\n                // Mevcut lastLoginAt değerini kontrol et\n                const currentLastLogin = userProfile.lastLoginAt;\n                let shouldUpdate = false;\n\n                // Eğer lastLoginAt yoksa veya geçersizse mutlaka güncelle\n                if (!currentLastLogin) {\n                  shouldUpdate = true;\n                } else {\n                  // Eğer lastLoginAt çok eskiyse (30 dakikadan fazla) güncelle\n                  try {\n                    let loginDate: Date;\n                    if (currentLastLogin instanceof Timestamp) {\n                      loginDate = currentLastLogin.toDate();\n                    } else if (currentLastLogin && typeof currentLastLogin === 'object' && 'toDate' in currentLastLogin && typeof (currentLastLogin as { toDate: () => Date }).toDate === 'function') {\n                      loginDate = (currentLastLogin as { toDate: () => Date }).toDate();\n                    } else if (currentLastLogin && typeof currentLastLogin === 'object' && '_seconds' in currentLastLogin) {\n                      const seconds = Number((currentLastLogin as { _seconds?: number })._seconds || 0);\n                      const nanoseconds = Number((currentLastLogin as { _nanoseconds?: number })._nanoseconds || 0);\n                      loginDate = new Timestamp(seconds, nanoseconds).toDate();\n                    } else {\n                      shouldUpdate = true; // Geçersiz format, güncelle\n                    }\n\n                    if (!shouldUpdate && loginDate) {\n                      const diffInMinutes = Math.floor((now - loginDate.getTime()) / (1000 * 60));\n                      // Eğer son giriş 30 dakikadan fazla önceyse güncelle\n                      if (diffInMinutes > 30) {\n                        shouldUpdate = true;\n                      }\n                    }\n                  } catch (parseError) {\n                    // Parse hatası varsa güncelle\n                    shouldUpdate = true;\n                  }\n                }\n\n                if (shouldUpdate) {\n                  // serverTimestamp() kullanarak sunucu zamanını kaydet\n                  await updateDoc(doc(firestore, \"users\", firebaseUser.uid), {\n                    lastLoginAt: serverTimestamp(),\n                  });\n                  lastLoginUpdateTime.set(firebaseUser.uid, now);\n\n                  // Profili yeniden yükle (güncellenmiş lastLoginAt ile)\n                  await new Promise(resolve => setTimeout(resolve, 200)); // 200ms bekle (serverTimestamp işlemesi için)\n                  const updatedProfile = await getUserProfile(firebaseUser.uid);\n                  if (updatedProfile) {\n                    userProfile = updatedProfile;\n                  }\n                }\n              } catch (updateError) {\n                if (import.meta.env.DEV) {\n                  console.error(\"Son giriş zamanı güncellenirken hata (onAuthChange):\", updateError);\n                }\n                // Hata olsa bile devam et\n              }\n            }\n\n            callback(userProfile);\n          } catch (error: unknown) {\n            // Silinmiş kullanıcı ise çıkış yap\n            const errorObj = error && typeof error === 'object' ? error as { message?: string } : null;\n            if (errorObj?.message?.includes(\"silinmiş\")) {\n              try {\n                await firebaseSignOut(auth);\n              } catch (signOutError) {\n                if (import.meta.env.DEV) {\n                  if (import.meta.env.DEV) {\n                    console.error(\"Çıkış yapılırken hata:\", signOutError);\n                  }\n                }\n              }\n              callback(null);\n            } else {\n              // Diğer hatalar için de callback(null) çağır\n              if (import.meta.env.DEV) {\n                console.error(\"onAuthChange callback hatası:\", error);\n              }\n              callback(null);\n            }\n          }\n        } else {\n          callback(null);\n        }\n      } catch (error: unknown) {\n        // En dış seviye hata yakalama - unhandled promise rejection'ları önle\n        if (import.meta.env.DEV) {\n          console.error(\"onAuthChange async callback hatası:\", error);\n        }\n        // Hata durumunda callback(null) çağır\n        try {\n          callback(null);\n        } catch (callbackError) {\n          // Callback çağrısı bile başarısız olursa sessizce handle et\n          if (import.meta.env.DEV) {\n            console.error(\"onAuthChange callback çağrısı hatası:\", callbackError);\n          }\n        }\n      }\n    })().catch((error) => {\n      // Promise rejection'ları yakala\n      if (import.meta.env.DEV) {\n        console.error(\"onAuthChange promise rejection:\", error);\n      }\n      try {\n        callback(null);\n      } catch (callbackError) {\n        if (import.meta.env.DEV) {\n          console.error(\"onAuthChange callback çağrısı hatası (promise rejection):\", callbackError);\n        }\n      }\n    });\n  });\n\n  // Return unsubscribe function that also clears timeout\n  return () => {\n    if (!timeoutFired) {\n      clearTimeout(timeout);\n    }\n    unsubscribe();\n  };\n};\n\n/**\n * Mevcut kullanıcıyı al\n */\nexport const getCurrentUser = (): FirebaseUser | null => {\n  return auth?.currentUser || null;\n};\n\n/**\n * Tüm kullanıcıları listele\n */\nexport const getAllUsers = async (): Promise<UserProfile[]> => {\n  try {\n    if (!firestore) {\n      throw new Error('Firestore is not initialized');\n    }\n\n    // Sadece authenticated kullanıcılar için çalış\n    const { getAuth } = await import(\"firebase/auth\");\n    const { auth } = await import(\"@/lib/firebase\");\n    const currentAuth = auth || getAuth();\n\n    if (!currentAuth?.currentUser) {\n      // Giriş yapmamış kullanıcılar için boş array döndür\n      return [];\n    }\n\n    // Önce roles collection'ından tanımlı rolleri al\n    const { getRoles } = await import(\"./rolePermissionsService\");\n    const definedRoles = await getRoles();\n    const definedRoleKeys = new Set(definedRoles.map(r => r.key));\n\n    // Önce orderBy ile deneyelim (index varsa hızlı olur)\n    // Performans için limit ekle (500 kayıt)\n    try {\n      const q = query(collection(firestore, \"users\"), orderBy(\"displayName\", \"asc\"), limit(500));\n      const snapshot = await getDocs(q);\n\n      const users = snapshot.docs\n        .map((doc) => {\n          const data = doc.data();\n          // Silinmiş kullanıcıları filtrele\n          if (data.deleted === true) {\n            return null;\n          }\n\n          // Kullanıcının rolleri sadece tanımlı rollerden olsun\n          const userRoles = (data.role || []) as string[];\n          const validRoles = userRoles.filter(role => definedRoleKeys.has(role));\n          const finalRoles = validRoles.length > 0 ? validRoles : [\"personnel\"];\n\n          // Eğer roller değiştiyse, veritabanını güncelle (async, await etmeden)\n          if (JSON.stringify(userRoles) !== JSON.stringify(finalRoles)) {\n            updateDoc(doc.ref, { role: finalRoles }).catch(err => {\n              console.error(`Error syncing roles for user ${doc.id}:`, err);\n            });\n          }\n\n          return {\n            id: doc.id,\n            email: data.email || \"\",\n            displayName: data.displayName || data.fullName || \"\",\n            fullName: data.fullName || data.displayName || \"\",\n            phone: data.phone || \"\",\n            dateOfBirth: data.dateOfBirth || \"\",\n            role: finalRoles,\n            departmentId: data.departmentId || \"\",\n            pendingTeams: data.pendingTeams || [],\n            approvedTeams: data.approvedTeams || [],\n            teamLeaderIds: data.teamLeaderIds || [],\n            emailVerified: data.emailVerified || false,\n            createdAt: data.createdAt || null,\n            updatedAt: data.updatedAt || null,\n            lastLoginAt: data.lastLoginAt || null,\n          } as UserProfile;\n        })\n        .filter((user): user is UserProfile => user !== null && !!user.id && !!(user.displayName || user.fullName || user.email)); // Geçerli kullanıcıları filtrele (email varsa da kabul et)\n\n      return users;\n    } catch (orderByError: unknown) {\n      // Index hatası varsa orderBy olmadan al (sessizce handle et)\n      if (import.meta.env.DEV) {\n        const errorObj = orderByError && typeof orderByError === 'object' ? orderByError as { code?: string; message?: string } : null;\n        if (errorObj?.code !== 'permission-denied') {\n          console.warn(\"OrderBy failed, fetching without order:\", errorObj?.message || orderByError);\n        }\n      }\n      // Önce roles collection'ından tanımlı rolleri al\n      const { getRoles } = await import(\"./rolePermissionsService\");\n      const definedRoles = await getRoles();\n      const definedRoleKeys = new Set(definedRoles.map(r => r.key));\n\n      // Performans için limit ekle (500 kayıt)\n      const q = query(collection(firestore, \"users\"), limit(500));\n      const snapshot = await getDocs(q);\n      const users = snapshot.docs\n        .map((doc) => {\n          const data = doc.data();\n          // Silinmiş kullanıcıları filtrele\n          if (data.deleted === true) {\n            return null;\n          }\n\n          // Kullanıcının rolleri sadece tanımlı rollerden olsun\n          const userRoles = (data.role || []) as string[];\n          const validRoles = userRoles.filter(role => definedRoleKeys.has(role));\n\n          // Eğer hiç geçerli rol yoksa, varsayılan rol ekle\n          const finalRoles = validRoles.length > 0 ? validRoles : [\"personnel\"];\n\n          // Eğer roller değiştiyse, veritabanını güncelle\n          if (JSON.stringify(userRoles) !== JSON.stringify(finalRoles)) {\n            // Async olarak güncelle (await etmeden)\n            updateDoc(doc.ref, { role: finalRoles }).catch(err => {\n              console.error(`Error syncing roles for user ${doc.id}:`, err);\n            });\n          }\n\n          return {\n            id: doc.id,\n            email: data.email || \"\",\n            displayName: data.displayName || data.fullName || \"\",\n            fullName: data.fullName || data.displayName || \"\",\n            phone: data.phone || \"\",\n            dateOfBirth: data.dateOfBirth || \"\",\n            role: finalRoles,\n            departmentId: data.departmentId || \"\",\n            pendingTeams: data.pendingTeams || [],\n            approvedTeams: data.approvedTeams || [],\n            teamLeaderIds: data.teamLeaderIds || [],\n            emailVerified: data.emailVerified || false,\n            createdAt: data.createdAt || null,\n            updatedAt: data.updatedAt || null,\n            lastLoginAt: data.lastLoginAt || null,\n          } as UserProfile;\n        })\n        .filter((user): user is UserProfile => user !== null && !!user.id && !!(user.displayName || user.fullName || user.email)); // Geçerli kullanıcıları filtrele (email varsa da kabul et)\n\n      // Client-side sorting\n      return users.sort((a, b) => {\n        const nameA = (a.displayName || a.fullName || \"\").toLowerCase();\n        const nameB = (b.displayName || b.fullName || \"\").toLowerCase();\n        return nameA.localeCompare(nameB, \"tr\");\n      });\n    }\n  } catch (error: unknown) {\n    // Permission hatalarını sessizce handle et (giriş yapmadan normal)\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n\n    if (errorObj?.code === 'permission-denied' || errorObj?.message?.includes('permissions')) {\n      // Permission hatası beklenen bir durum (giriş yapmadan), sessizce handle et\n      if (import.meta.env.DEV) {\n        console.debug(\"Permission hatası (beklenen): Kullanıcı giriş yapmamış olabilir\");\n      }\n    } else if (errorObj?.code === 'unavailable' || errorObj?.message?.includes('network')) {\n      if (import.meta.env.DEV) {\n        console.warn(\"⚠️ Firestore bağlantı hatası! İnternet bağlantınızı kontrol edin.\");\n      }\n    } else {\n      if (import.meta.env.DEV) {\n        console.error(\"⚠️ Kullanıcı listesi alınamadı:\", errorObj?.message || error);\n      }\n    }\n\n    // Hata durumunda boş array döndür, uygulama çökmesin\n    return [];\n  }\n};\n\n/**\n * Google ile giriş yap\n */\nexport const signInWithGoogle = async (): Promise<{ success: boolean; message?: string; user?: UserProfile | null }> => {\n  try {\n    if (!auth) {\n      throw new Error('Firebase Auth is not initialized');\n    }\n    const provider = new GoogleAuthProvider();\n    provider.addScope(\"https://www.googleapis.com/auth/drive.file\"); // Drive scope added\n    const result = await signInWithPopup(auth, provider);\n    const firebaseUser = result.user;\n\n    // Önce direkt Firestore'dan silinmiş kullanıcı kontrolü yap\n    try {\n      const userDoc = await getDoc(doc(firestore, \"users\", firebaseUser.uid));\n      if (userDoc.exists()) {\n        const userData = userDoc.data();\n        if (userData.deleted === true) {\n          // Hemen çıkış yap\n          try {\n            await firebaseSignOut(auth);\n          } catch (signOutError) {\n            if (import.meta.env.DEV) {\n              if (import.meta.env.DEV) {\n                console.error(\"Çıkış yapılırken hata:\", signOutError);\n              }\n            }\n          }\n          return {\n            success: false,\n            message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n            user: null,\n          };\n        }\n      }\n    } catch (checkError) {\n      console.error(\"Kullanıcı kontrolü hatası:\", checkError);\n      // Kontrol hatası olsa bile devam et, getUserProfile kontrol edecek\n    }\n\n    // Check if user profile exists, create if not\n    try {\n      let userProfile = await getUserProfile(firebaseUser.uid);\n\n      // Eğer kullanıcı silinmişse\n      if (!userProfile) {\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n        }\n        return {\n          success: false,\n          message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n          user: null,\n        };\n      }\n\n      // Kullanıcı profilini güncelle - serverTimestamp() kullanarak sunucu zamanını kaydet\n      const oldLastLoginAt = userProfile.lastLoginAt;\n      // serverTimestamp() kullanarak Firebase sunucusunun zamanını kaydet (daha doğru)\n      await updateDoc(doc(firestore, \"users\", firebaseUser.uid), {\n        displayName: firebaseUser.displayName,\n        fullName: firebaseUser.displayName,\n        emailVerified: firebaseUser.emailVerified,\n        updatedAt: serverTimestamp(),\n        lastLoginAt: serverTimestamp(),\n      });\n\n      // Profili yeniden yükle (güncellenmiş lastLoginAt ile)\n      // Not: serverTimestamp() async olduğu için hemen okumak doğru zamanı vermeyebilir\n      // Bu yüzden bir miktar bekleyip tekrar yükleyelim\n      await new Promise(resolve => setTimeout(resolve, 100)); // 100ms bekle\n\n      const updatedProfile = await getUserProfile(firebaseUser.uid);\n      if (updatedProfile) {\n        userProfile = updatedProfile;\n      }\n\n      // Giriş logunu kaydet (retry mekanizması ile)\n      try {\n        const loginTime = new Date().toISOString();\n        const oldLastLoginAtValue = oldLastLoginAt ? (oldLastLoginAt instanceof Timestamp ? oldLastLoginAt.toDate().toISOString() : String(oldLastLoginAt)) : null;\n\n        let retryCount = 0;\n        const maxRetries = 2;\n        while (retryCount <= maxRetries) {\n          try {\n            await logAudit(\n              \"UPDATE\",\n              \"user_logins\",\n              firebaseUser.uid,\n              firebaseUser.uid,\n              oldLastLoginAtValue ? { lastLoginAt: oldLastLoginAtValue } : null,\n              null,\n              {\n                action: \"LOGIN\",\n                method: \"GOOGLE\",\n                email: firebaseUser.email || null,\n                timestamp: loginTime\n              }\n            );\n            break; // Başarılı oldu, döngüden çık\n          } catch (retryError) {\n            retryCount++;\n            if (retryCount > maxRetries) {\n              if (import.meta.env.DEV) {\n                console.error(\"Giriş logu kaydedilirken hata (tüm denemeler başarısız):\", retryError);\n              }\n            } else {\n              // Kısa bir bekleme sonrası tekrar dene\n              await new Promise(resolve => setTimeout(resolve, 100 * retryCount));\n            }\n          }\n        }\n      } catch (logError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Giriş logu kaydedilirken beklenmeyen hata:\", logError);\n        }\n        // Log hatası girişi engellememeli\n      }\n\n      return {\n        success: true,\n        user: userProfile,\n      };\n    } catch (profileError: unknown) {\n      // Silinmiş kullanıcı hatası\n      if (profileError instanceof Error && profileError.message?.includes(\"silinmiş\")) {\n        try {\n          await firebaseSignOut(auth);\n        } catch (signOutError) {\n          if (import.meta.env.DEV) {\n            console.error(\"Çıkış yapılırken hata:\", signOutError);\n          }\n        }\n        return {\n          success: false,\n          message: \"Bu hesap silinmiş. Giriş yapamazsınız.\",\n          user: null,\n        };\n      }\n      // Eğer profil yoksa yeni profil oluştur\n      const newUserProfile = {\n        id: firebaseUser.uid,\n        email: firebaseUser.email || \"\",\n        displayName: firebaseUser.displayName || \"\",\n        fullName: firebaseUser.displayName || \"\",\n        role: [\"viewer\"], // Default role\n        emailVerified: firebaseUser.emailVerified,\n        createdAt: serverTimestamp(),\n        updatedAt: serverTimestamp(),\n        pendingTeams: [],\n        approvedTeams: [],\n      };\n      await setDoc(doc(firestore, \"users\", firebaseUser.uid), newUserProfile);\n\n      return {\n        success: true,\n        user: newUserProfile as UserProfile,\n      };\n    }\n  } catch (error: unknown) {\n    console.error(\"Google Sign-In error:\", error);\n    let errorMessage = \"Google ile giriş başarısız\";\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n    if (errorObj?.code === 'auth/popup-closed-by-user') {\n      errorMessage = \"Google giriş penceresi kapatıldı.\";\n    } else if (errorObj?.message) {\n      errorMessage = errorObj.message;\n    }\n    return {\n      success: false,\n      message: errorMessage,\n      user: null,\n    };\n  }\n};\n\n/**\n * Email doğrulama e-postası gönder\n */\nexport const sendVerificationEmail = async (): Promise<{ success: boolean; message?: string }> => {\n  try {\n    if (!auth) {\n      return { success: false, message: 'Firebase Auth is not initialized' };\n    }\n    const user = auth.currentUser;\n    if (!user) {\n      return { success: false, message: \"Kullanıcı oturum açmamış\" };\n    }\n\n    // Email zaten doğrulanmışsa gönderme\n    if (user.emailVerified) {\n      return { success: false, message: \"Email zaten doğrulanmış\" };\n    }\n\n    await sendEmailVerification(user);\n    if (import.meta.env.DEV) {\n      console.log(\"Email doğrulama maili gönderildi (manuel):\", user.email);\n    }\n    return { success: true, message: \"Doğrulama e-postası gönderildi. Lütfen e-postanızı ve spam kutusunu kontrol edin.\" };\n  } catch (error: unknown) {\n    const errorCode = (error as { code?: string })?.code;\n    const errorMsg = error instanceof Error ? error.message : String(error);\n\n    if (import.meta.env.DEV) {\n      console.error(\"Send verification email error:\", error);\n    }\n\n    // Firebase hata kodlarını Türkçe'ye çevir\n    let errorMessage = \"Email doğrulama maili gönderilemedi\";\n    if (errorCode === 'auth/too-many-requests') {\n      errorMessage = \"Çok fazla istek yapıldı. Lütfen bir süre sonra tekrar deneyin.\";\n    } else if (errorCode === 'auth/network-request-failed') {\n      errorMessage = \"Ağ hatası. İnternet bağlantınızı kontrol edin.\";\n    } else if (errorMsg) {\n      errorMessage = errorMsg;\n    }\n    return {\n      success: false,\n      message: (error && typeof error === 'object' && 'message' in error ? (error as { message?: string }).message : undefined) || \"Doğrulama e-postası gönderilemedi\",\n    };\n  }\n};\n\n/**\n * Kullanıcıyı tamamen sil (sadece super_admin)\n * - Firebase Auth'dan siler (Cloud Function gerekir)\n * - Firestore users collection'ında soft delete yapar\n * - Tüm logları siler\n * - Görevlerden kullanıcıyı çıkarır\n * - Bildirimlerini siler\n * - Ekip ilişkilerini temizler\n * - Eğer göreve kimse kalmamışsa havuza alır\n */\nexport const deleteUser = async (userId: string, deletedBy: string): Promise<void> => {\n  try {\n    if (!auth || !firestore) {\n      throw new Error(\"Firebase is not initialized\");\n    }\n\n    // Kullanıcı profilini al (silinmiş bile olsa bilgileri görmek için allowDeleted: true)\n    const userProfile = await getUserProfile(userId, true);\n    if (!userProfile) {\n      throw new Error(\"Kullanıcı bulunamadı\");\n    }\n\n    // Zaten silinmişse hata ver\n    const userDoc = await getDoc(doc(firestore, \"users\", userId));\n    if (userDoc.exists() && userDoc.data()?.deleted === true) {\n      throw new Error(\"Bu kullanıcı zaten silinmiş.\");\n    }\n\n    // Silen kişinin yetkisini kontrol et (super_admin olmalı)\n    const deleterProfile = await getUserProfile(deletedBy);\n    if (!deleterProfile || (!deleterProfile.role?.includes(\"super_admin\") && !deleterProfile.role?.includes(\"main_admin\"))) {\n      throw new Error(\"Kullanıcı silme yetkiniz yok. Sadece ana yöneticiler kullanıcı silebilir.\");\n    }\n\n    // Kendini silmeye çalışıyorsa engelle\n    if (userId === deletedBy) {\n      throw new Error(\"Kendi hesabınızı silemezsiniz.\");\n    }\n\n    // Orijinal verileri sakla (audit log için)\n    const originalData = {\n      email: userProfile.email,\n      displayName: userProfile.displayName,\n      fullName: userProfile.fullName,\n      phone: userProfile.phone,\n      role: userProfile.role,\n      departmentId: userProfile.departmentId,\n    };\n\n    // 1. Tüm görevlerden kullanıcıyı çıkar ve gerekirse havuza al\n    try {\n      const { removeUserFromAllTasks } = await import(\"./taskService\");\n      await removeUserFromAllTasks(userId);\n    } catch (taskError) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Görevlerden kullanıcı çıkarılırken hata:\", taskError);\n      }\n      // Devam et, kritik değil\n    }\n\n    // 2. Tüm logları sil (opsiyonel - GDPR için log tutmak gerekebilir)\n    try {\n      const { deleteUserLogs } = await import(\"./auditLogsService\");\n      await deleteUserLogs(userId);\n    } catch (logError) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Loglar silinirken hata:\", logError);\n      }\n      // Devam et, kritik değil\n    }\n\n    // 3. Kullanıcının tüm bildirimlerini sil\n    try {\n      const { deleteUserNotifications } = await import(\"./notificationService\");\n      if (typeof deleteUserNotifications === 'function') {\n        await deleteUserNotifications(userId);\n      }\n    } catch (notifError) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Bildirimler silinirken hata:\", notifError);\n      }\n      // Devam et, kritik değil\n    }\n\n    // 4. Ekip ilişkilerini temizle (departmentlarda manager ise)\n    try {\n      const { getDepartments, updateDepartment } = await import(\"./departmentService\");\n      const departments = await getDepartments();\n\n      for (const dept of departments) {\n        if (dept.managerId === userId) {\n          // Bu departmanda manager ise, manager'ı null yap\n          await updateDepartment(dept.id, { managerId: null });\n          if (import.meta.env.DEV) {\n            console.log(`Departman ${dept.id} manager'ı temizlendi`);\n          }\n        }\n      }\n    } catch (deptError) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Ekip ilişkileri temizlenirken hata:\", deptError);\n      }\n      // Devam et, kritik değil\n    }\n\n    // 5. Firestore'da soft delete yap\n    // Kullanıcıyı silmek yerine \"deleted\" flag'i ekleyelim\n    // Böylece kullanıcı giriş yapamaz ama veriler korunur (GDPR uyumluluğu için)\n    const userRef = doc(firestore, \"users\", userId);\n\n    await updateDoc(userRef, {\n      deleted: true,\n      deletedAt: serverTimestamp(),\n      deletedBy: deletedBy,\n      // Orijinal email'i koruyoruz (yeniden kayıt kontrolü için gerekli)\n      // email: userProfile.email, // DEĞİŞTİRME\n      displayName: \"Silinmiş Kullanıcı\",\n      fullName: \"Silinmiş Kullanıcı\",\n      phone: null,\n      dateOfBirth: null,\n      role: [],\n      departmentId: null,\n      pendingTeams: [],\n      approvedTeams: [],\n      teamLeaderIds: [],\n      // Orijinal verileri metadata olarak sakla (gerekirse geri yüklemek için)\n      _originalData: originalData,\n    });\n\n    // 6. Audit log oluştur\n    try {\n      const { logSecurityEvent } = await import(\"@/utils/auditLogger\");\n      await logSecurityEvent(\n        \"ACCOUNT_DELETE\",\n        deletedBy,\n        {\n          targetUserId: userId,\n          deletedAt: new Date().toISOString(),\n          reason: \"Kullanıcı yönetici tarafından silindi\",\n          originalEmail: userProfile?.email // Logda email'i tutmak faydalı olabilir\n        }\n      );\n    } catch (auditError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Audit log oluşturulurken hata:\", auditError);\n      }\n      // Devam et, silme işlemi tamamlandı\n    }\n\n    if (import.meta.env.DEV) {\n      console.log(`Kullanıcı ${userId} başarıyla silindi (soft delete)`);\n    }\n\n  } catch (error: unknown) {\n    console.error(\"Delete user error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Silinmiş kullanıcıyı geri yükle (sadece super_admin)\n * Soft delete ile silinmiş kullanıcıları geri yükler\n */\nexport const restoreUser = async (userId: string, restoredBy: string): Promise<void> => {\n  try {\n    if (!auth || !firestore) {\n      throw new Error(\"Firebase is not initialized\");\n    }\n\n    // Geri yükleyen kişinin yetkisini kontrol et\n    const restorerProfile = await getUserProfile(restoredBy);\n    if (!restorerProfile || (!restorerProfile.role?.includes(\"super_admin\") && !restorerProfile.role?.includes(\"main_admin\"))) {\n      throw new Error(\"Kullanıcı geri yükleme yetkiniz yok. Sadece ana yöneticiler kullanıcı geri yükleyebilir.\");\n    }\n\n    // Kullanıcı dokümanını al\n    const userRef = doc(firestore, \"users\", userId);\n    const userDoc = await getDoc(userRef);\n\n    if (!userDoc.exists()) {\n      throw new Error(\"Kullanıcı bulunamadı\");\n    }\n\n    const userData = userDoc.data();\n\n    if (userData.deleted !== true) {\n      throw new Error(\"Bu kullanıcı silinmemiş, geri yükleme gerekmiyor.\");\n    }\n\n    // Orijinal verileri al\n    const originalData = userData._originalData || {};\n\n    // Geri yükle\n    await updateDoc(userRef, {\n      deleted: false,\n      deletedAt: null,\n      deletedBy: null,\n      displayName: originalData.displayName || userData.email?.split(\"@\")[0] || \"Kullanıcı\",\n      fullName: originalData.fullName || originalData.displayName || userData.email?.split(\"@\")[0] || \"Kullanıcı\",\n      phone: originalData.phone || null,\n      role: originalData.role || [\"viewer\"],\n      departmentId: originalData.departmentId || null,\n      pendingTeams: [],\n      approvedTeams: [],\n      teamLeaderIds: [],\n      restoredAt: serverTimestamp(),\n      restoredBy: restoredBy,\n      _originalData: null, // Temizle\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    try {\n      const { logSecurityEvent } = await import(\"@/utils/auditLogger\");\n      await logSecurityEvent(\n        \"ACCOUNT_RESTORE\",\n        restoredBy,\n        {\n          targetUserId: userId,\n          restoredAt: new Date().toISOString(),\n        }\n      );\n    } catch (auditError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Audit log oluşturulurken hata:\", auditError);\n      }\n    }\n\n    if (import.meta.env.DEV) {\n      console.log(`Kullanıcı ${userId} başarıyla geri yüklendi`);\n    }\n\n  } catch (error: unknown) {\n    console.error(\"Restore user error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Silinmiş kullanıcıları listele (sadece super_admin için)\n */\nexport const getDeletedUsers = async (): Promise<UserProfile[]> => {\n  try {\n    if (!firestore) {\n      throw new Error(\"Firestore is not initialized\");\n    }\n\n    const usersRef = collection(firestore, \"users\");\n    const q = query(usersRef, where(\"deleted\", \"==\", true), limit(100));\n    const snapshot = await getDocs(q);\n\n    return snapshot.docs.map((doc) => {\n      const data = doc.data();\n      return {\n        id: doc.id,\n        email: data.email || \"\",\n        displayName: data._originalData?.displayName || \"Silinmiş Kullanıcı\",\n        fullName: data._originalData?.fullName || \"Silinmiş Kullanıcı\",\n        phone: data._originalData?.phone || null,\n        role: [],\n        emailVerified: false,\n        createdAt: data.createdAt || null,\n        updatedAt: data.updatedAt || null,\n        deletedAt: data.deletedAt || null,\n        deletedBy: data.deletedBy || null,\n      } as UserProfile & { deletedAt?: any; deletedBy?: string };\n    });\n\n  } catch (error: unknown) {\n    console.error(\"Get deleted users error:\", error);\n    return [];\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\customerNoteService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\customerService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":309,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":309,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8327,8330],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8327,8330],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":406,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":406,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10970,10973],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10970,10973],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Firebase Customer Service\n * Müşteri yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\n\nexport interface Customer {\n  id: string;\n  name: string;\n  company?: string | null;\n  email?: string | null;\n  phone?: string | null;\n  address?: string | null;\n  taxId?: string | null;\n  notes?: string | null;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n  createdBy: string;\n}\n\n/**\n * Tüm müşterileri listele\n */\nexport const getCustomers = async (): Promise<Customer[]> => {\n  try {\n    if (!firestore) {\n      throw new Error(\"Firebase Firestore başlatılamadı. Lütfen .env dosyasında Firebase yapılandırmasını kontrol edin.\");\n    }\n    \n    // orderBy kullanmadan önce index gerektirebilir, bu yüzden önce basit sorgu deneyelim\n    // Performans için limit ekle (500 kayıt)\n    try {\n      const q = query(collection(firestore, \"customers\"), orderBy(\"createdAt\", \"desc\"), limit(500));\n      const snapshot = await getDocs(q);\n      const customers = snapshot.docs.map((doc) => ({\n        id: doc.id,\n        ...doc.data(),\n      })) as Customer[];\n      \n      // Duplicate kontrolü - aynı ID'ye sahip müşterileri filtrele\n      const uniqueCustomers = customers.filter((customer, index, self) =>\n        index === self.findIndex((c) => c.id === customer.id)\n      );\n      \n      return uniqueCustomers;\n    } catch (orderByError: unknown) {\n      // Index hatası varsa orderBy olmadan al\n      if (import.meta.env.DEV) {\n        if (import.meta.env.DEV) {\n          console.warn(\"OrderBy failed, fetching customers without order:\", orderByError);\n        }\n      }\n      const q = query(collection(firestore, \"customers\"), limit(500));\n      const snapshot = await getDocs(q);\n      const customers = snapshot.docs.map((doc) => ({\n        id: doc.id,\n        ...doc.data(),\n      })) as Customer[];\n      \n      // Duplicate kontrolü - aynı ID'ye sahip müşterileri filtrele\n      const uniqueCustomers = customers.filter((customer, index, self) =>\n        index === self.findIndex((c) => c.id === customer.id)\n      );\n      \n      // Client-side sorting\n      return uniqueCustomers.sort((a, b) => {\n        const aTime = a.createdAt?.toMillis() || 0;\n        const bTime = b.createdAt?.toMillis() || 0;\n        return bTime - aTime; // Descending order\n      });\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get customers error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Müşteri detayını al\n */\nexport const getCustomerById = async (customerId: string): Promise<Customer | null> => {\n  try {\n    const customerDoc = await getDoc(doc(firestore, \"customers\", customerId));\n    \n    if (!customerDoc.exists()) {\n      return null;\n    }\n\n    return {\n      id: customerDoc.id,\n      ...customerDoc.data(),\n    } as Customer;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get customer by id error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni müşteri oluştur\n */\nexport const createCustomer = async (\n  customerData: Omit<Customer, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<Customer> => {\n  try {\n    const docRef = await addDoc(collection(firestore, \"customers\"), {\n      ...customerData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n\n    const createdCustomer = await getCustomerById(docRef.id);\n    if (!createdCustomer) {\n      throw new Error(\"Müşteri oluşturulamadı\");\n    }\n\n    // Audit log\n    await logAudit(\"CREATE\", \"customers\", docRef.id, customerData.createdBy, null, createdCustomer);\n\n    // Aktivite log ekle\n    if (customerData.createdBy) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(customerData.createdBy);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addCustomerActivity(\n          docRef.id,\n          customerData.createdBy,\n          \"created\",\n          `bu müşteriyi oluşturdu`,\n          { customerName: customerData.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add customer activity error:\", error);\n        }\n      }\n    }\n\n    return createdCustomer;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Create customer error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Müşteriyi güncelle\n */\nexport const updateCustomer = async (\n  customerId: string,\n  updates: Partial<Omit<Customer, \"id\" | \"createdAt\" | \"createdBy\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldCustomer = await getCustomerById(customerId);\n    \n    await updateDoc(doc(firestore, \"customers\", customerId), {\n      ...updates,\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Yeni veriyi al\n    const newCustomer = await getCustomerById(customerId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"customers\", customerId, userId, oldCustomer, newCustomer);\n    }\n\n    // Aktivite log ekle\n    if (userId && oldCustomer) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        const changedFields = Object.keys(updates).filter(key => {\n          const oldValue = (oldCustomer as Record<string, unknown>)[key];\n          const newValue = (updates as Record<string, unknown>)[key];\n          return oldValue !== newValue;\n        });\n        \n        if (changedFields.length > 0) {\n          await addCustomerActivity(\n            customerId,\n            userId,\n            \"updated\",\n            `bu müşteriyi güncelledi`,\n            { changedFields },\n            userName,\n            userEmail\n          );\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add customer activity error:\", error);\n        }\n      }\n    }\n  } catch (error) {\n    console.error(\"Update customer error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Müşteriyi sil\n */\nexport const deleteCustomer = async (customerId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldCustomer = await getCustomerById(customerId);\n    \n    // Aktivite log ekle (silmeden önce)\n    if (userId && oldCustomer) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addCustomerActivity(\n          customerId,\n          userId,\n          \"deleted\",\n          `bu müşteriyi sildi`,\n          { customerName: oldCustomer.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add customer activity error:\", error);\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, \"customers\", customerId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"customers\", customerId, userId, oldCustomer, null);\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete customer error:\", error);\n    }\n    throw error;\n  }\n};\n\n// Customer Comments and Activities\n\nexport interface CustomerComment {\n  id: string;\n  customerId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp;\n  updatedAt?: Timestamp | null;\n}\n\nexport interface CustomerActivity {\n  id: string;\n  customerId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp;\n}\n\n/**\n * Müşteri yorumu ekle\n */\nexport const addCustomerComment = async (\n  customerId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<CustomerComment> => {\n  try {\n    const commentData: Omit<CustomerComment, \"id\"> = {\n      customerId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"customers\", customerId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addCustomerActivity(customerId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Müşteriyi oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const customer = await getCustomerById(customerId);\n      if (customer?.createdBy && customer.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: customer.createdBy,\n          type: \"comment_added\",\n          title: \"Müşterinize Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} \"${customer.name}\" müşterinize yorum ekledi: ${content.substring(0, 100)}${content.length > 100 ? \"...\" : \"\"}`,\n          read: false,\n          relatedId: customerId,\n          metadata: { commentId: docRef.id, commenterId: userId, commenterName: userName, commenterEmail: userEmail },\n        });\n      }\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.error(\"Send comment notification error:\", error);\n      }\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add customer comment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Müşteri yorumlarını al\n */\nexport const getCustomerComments = async (customerId: string): Promise<CustomerComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"customers\", customerId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as CustomerComment[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get customer comments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Müşteri aktivite log ekle\n */\nexport const addCustomerActivity = async (\n  customerId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<CustomerActivity, \"id\"> = {\n      customerId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"customers\", customerId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add customer activity error:\", error);\n    }\n    return \"\";\n  }\n};\n\n/**\n * Müşteri aktivite loglarını al\n */\nexport const getCustomerActivities = async (customerId: string): Promise<CustomerActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"customers\", customerId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as CustomerActivity[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get customer activities error:\", error);\n    }\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\departmentService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\materialCategoryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\materialService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":556,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":556,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17421,17424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17421,17424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":647,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":647,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19955,19958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19955,19958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Firebase Raw Material Service\n * Hammade yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\nimport { handlePermissionError, isPermissionError, getPermissionErrorMessage } from \"@/utils/errorLogger\";\nimport { auth } from \"@/lib/firebase\";\n\nexport interface RawMaterial {\n  id: string;\n  name: string;\n  code?: string | null;\n  sku?: string | null; // SKU kodu (code ile aynı ama eski sistem uyumluluğu için)\n  category?: string | null; // Kategori\n  unit: string; // 'kg', 'm', 'adet', vb.\n  currentStock: number;\n  stock?: number | null; // currentStock ile aynı (eski sistem uyumluluğu için)\n  minStock?: number | null;\n  min_stock?: number | null; // minStock ile aynı (eski sistem uyumluluğu için)\n  maxStock?: number | null;\n  max_stock?: number | null; // maxStock ile aynı (eski sistem uyumluluğu için)\n  cost?: number | null; // unitPrice ile aynı (eski sistem uyumluluğu için)\n  unitPrice?: number | null; // Birim fiyat\n  vatRate?: number | null; // KDV yüzdesi\n  totalPrice?: number | null; // Toplam fiyat (KDV dahil)\n  currency?: string | null; // Para birimi: 'TRY', 'USD', 'EUR', vb.\n  currencies?: string[]; // Para birimleri: ['TRY', 'USD', 'EUR', vb.] (eski sistem uyumluluğu için)\n  brand?: string | null; // Marka\n  link?: string | null; // Link/URL\n  supplier?: string | null;\n  purchasedBy?: string | null; // Satın alan kişi (user ID)\n  location?: string | null; // Hammadde konumu\n  notes?: string | null;\n  description?: string | null; // Açıklama\n  deleted?: boolean | null; // Silinmiş mi? (eski sistem uyumluluğu için)\n  isDeleted?: boolean | null; // Silinmiş mi? (eski sistem uyumluluğu için)\n  createdBy?: string | null; // Oluşturan kullanıcı ID\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\nexport interface MaterialTransaction {\n  id: string;\n  materialId: string;\n  type: \"in\" | \"out\";\n  quantity: number;\n  reason: string;\n  relatedOrderId?: string | null;\n  createdAt: Timestamp;\n  createdBy: string;\n}\n\n/**\n * Tüm hammaddeleri listele\n */\nexport const getRawMaterials = async (includeDeleted: boolean = false): Promise<RawMaterial[]> => {\n  try {\n    // Performans için limit ekle (500 kayıt)\n    let q;\n    if (includeDeleted) {\n      q = query(collection(firestore, \"rawMaterials\"), orderBy(\"createdAt\", \"desc\"), limit(500));\n    } else {\n      // Silinmiş olmayan hammaddeleri getir\n      q = query(\n        collection(firestore, \"rawMaterials\"),\n        orderBy(\"createdAt\", \"desc\"),\n        limit(500)\n      );\n    }\n    const snapshot = await getDocs(q);\n    const materials: RawMaterial[] = [];\n    \n    for (const docSnapshot of snapshot.docs) {\n      const data = docSnapshot.data();\n      if (!data || typeof data !== 'object') continue;\n      \n      // Silinmiş hammaddeleri atla (eğer includeDeleted false ise)\n      if (!includeDeleted) {\n        const deleted = data.deleted === true || data.isDeleted === true;\n        if (deleted) {\n          continue;\n        }\n      }\n      \n      const material: RawMaterial = {\n        id: docSnapshot.id,\n        name: data.name || \"\",\n        code: data.code || data.sku || null,\n        sku: data.sku || data.code || null,\n        category: data.category || \"other\",\n        unit: data.unit || \"Adet\",\n        currentStock: data.currentStock !== undefined ? data.currentStock : (data.stock || 0),\n        stock: data.stock !== undefined ? data.stock : (data.currentStock || 0),\n        minStock: data.minStock !== undefined ? data.minStock : (data.min_stock || 0),\n        min_stock: data.min_stock !== undefined ? data.min_stock : (data.minStock || 0),\n        maxStock: data.maxStock !== undefined ? data.maxStock : (data.max_stock || null),\n        max_stock: data.max_stock !== undefined ? data.max_stock : (data.maxStock || null),\n        cost: data.cost !== undefined ? data.cost : (data.unitPrice || null),\n        unitPrice: data.unitPrice !== undefined ? data.unitPrice : (data.cost || null),\n        totalPrice: data.totalPrice !== undefined ? data.totalPrice : null,\n        brand: data.brand || null,\n        link: data.link || null,\n        purchasedBy: data.purchasedBy || null,\n        location: data.location || null,\n        currency: data.currency || null,\n        currencies: data.currencies || null,\n        notes: data.notes || null,\n        description: data.description || null,\n        createdBy: data.createdBy || null,\n        createdAt: data.createdAt || Timestamp.now(),\n        updatedAt: data.updatedAt || Timestamp.now(),\n      };\n      materials.push(material);\n    }\n    \n    return materials;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get raw materials error:\", error);\n      }\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"read\",\n        collection: \"rawMaterials\",\n        userId: auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Hammade detayını al\n */\nexport const getRawMaterialById = async (materialId: string): Promise<RawMaterial | null> => {\n  try {\n    const materialDoc = await getDoc(doc(firestore, \"rawMaterials\", materialId));\n    \n    if (!materialDoc.exists()) {\n      return null;\n    }\n\n    const data = materialDoc.data() as Omit<RawMaterial, \"id\">;\n    return {\n      id: materialDoc.id,\n      name: data.name || \"\",\n      code: data.code || data.sku || null,\n      sku: data.sku || data.code || null,\n      category: data.category || \"other\",\n      unit: data.unit || \"Adet\",\n      currentStock: data.currentStock !== undefined ? data.currentStock : (data.stock || 0),\n      stock: data.stock !== undefined ? data.stock : (data.currentStock || 0),\n      minStock: data.minStock !== undefined ? data.minStock : (data.min_stock || 0),\n      min_stock: data.min_stock !== undefined ? data.min_stock : (data.minStock || 0),\n      maxStock: data.maxStock !== undefined ? data.maxStock : (data.max_stock || null),\n      max_stock: data.max_stock !== undefined ? data.max_stock : (data.maxStock || null),\n      cost: data.cost !== undefined ? data.cost : (data.unitPrice || null),\n      unitPrice: data.unitPrice !== undefined ? data.unitPrice : (data.cost || null),\n      totalPrice: data.totalPrice !== undefined ? data.totalPrice : null,\n      brand: data.brand || null,\n      link: data.link || null,\n      purchasedBy: data.purchasedBy || null,\n      location: data.location || null,\n      currency: data.currency || null,\n      currencies: data.currencies || null,\n      notes: data.notes || null,\n      description: data.description || null,\n      createdBy: data.createdBy || null,\n      createdAt: data.createdAt || Timestamp.now(),\n      updatedAt: data.updatedAt || Timestamp.now(),\n    } as RawMaterial;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get raw material by id error:\", error);\n      }\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"read\",\n        collection: \"rawMaterials\",\n        documentId: materialId,\n        userId: auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni hammade oluştur\n */\nexport const createRawMaterial = async (\n  materialData: Omit<RawMaterial, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<RawMaterial> => {\n  try {\n    const userId = auth?.currentUser?.uid;\n    \n    const docRef = await addDoc(collection(firestore, \"rawMaterials\"), {\n      ...materialData,\n      createdBy: userId || materialData.createdBy || null,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n\n    const createdMaterial = await getRawMaterialById(docRef.id);\n    if (!createdMaterial) {\n      throw new Error(\"Hammade oluşturulamadı\");\n    }\n\n    // Audit log\n    if (userId) {\n      await logAudit(\"CREATE\", \"raw_materials\", docRef.id, userId, null, createdMaterial);\n    }\n\n    // Aktivite log ekle\n    const finalUserId = userId || materialData.createdBy || auth?.currentUser?.uid;\n    if (finalUserId) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(finalUserId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addMaterialActivity(\n          docRef.id,\n          finalUserId,\n          \"created\",\n          `bu hammadeyi oluşturdu`,\n          { materialName: materialData.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add material activity error:\", error);\n        }\n      }\n    }\n\n    return createdMaterial;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Create raw material error:\", error);\n      }\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"create\",\n        collection: \"rawMaterials\",\n        userId: auth?.currentUser?.uid,\n        data: materialData,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Hammadeyi güncelle\n */\nexport const updateRawMaterial = async (\n  materialId: string,\n  updates: Partial<Omit<RawMaterial, \"id\" | \"createdAt\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldMaterial = await getRawMaterialById(materialId);\n    \n    await updateDoc(doc(firestore, \"rawMaterials\", materialId), {\n      ...updates,\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Yeni veriyi al\n    const newMaterial = await getRawMaterialById(materialId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"raw_materials\", materialId, userId, oldMaterial, newMaterial);\n    }\n\n    // Aktivite log ekle\n    const finalUserId = userId || auth?.currentUser?.uid;\n    if (finalUserId && oldMaterial) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(finalUserId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        const changedFields = Object.keys(updates).filter(key => {\n          const oldValue = (oldMaterial as Record<string, unknown>)[key];\n          const newValue = (updates as Record<string, unknown>)[key];\n          return oldValue !== newValue;\n        });\n        \n        if (changedFields.length > 0) {\n          await addMaterialActivity(\n            materialId,\n            finalUserId,\n            \"updated\",\n            `bu hammadeyi güncelledi`,\n            { changedFields },\n            userName,\n            userEmail\n          );\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add material activity error:\", error);\n        }\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Update raw material error:\", error);\n      }\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"update\",\n        collection: \"rawMaterials\",\n        documentId: materialId,\n        userId: userId || auth?.currentUser?.uid,\n        data: updates,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Hammadeyi sil\n */\nexport const deleteRawMaterial = async (materialId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldMaterial = await getRawMaterialById(materialId);\n    \n    // Aktivite log ekle (silmeden önce)\n    const finalUserId = userId || auth?.currentUser?.uid;\n    if (finalUserId && oldMaterial) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(finalUserId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addMaterialActivity(\n          materialId,\n          finalUserId,\n          \"deleted\",\n          `bu hammadeyi sildi`,\n          { materialName: oldMaterial.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add material activity error:\", error);\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, \"rawMaterials\", materialId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"raw_materials\", materialId, userId, oldMaterial, null);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete raw material error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"delete\",\n        collection: \"rawMaterials\",\n        documentId: materialId,\n        userId: userId || auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Stok hareketi ekle\n * @param transactionData - İşlem verisi\n * @param skipStockUpdate - Stok güncellemesini atla (stok zaten güncellenmişse true)\n */\nexport const addMaterialTransaction = async (\n  transactionData: Omit<MaterialTransaction, \"id\" | \"createdAt\">,\n  skipStockUpdate: boolean = false\n): Promise<MaterialTransaction> => {\n  try {\n    const materialId = transactionData.materialId;\n    \n    // Stok hareketini ekle\n    const docRef = await addDoc(\n      collection(firestore, \"rawMaterials\", materialId, \"transactions\"),\n      {\n        ...transactionData,\n        createdAt: serverTimestamp(),\n      }\n    );\n\n    // Stok miktarını güncelle (eğer skipStockUpdate false ise)\n    if (!skipStockUpdate) {\n      const material = await getRawMaterialById(materialId);\n      if (material) {\n        const newStock =\n          transactionData.type === \"in\"\n            ? material.currentStock + transactionData.quantity\n            : material.currentStock - transactionData.quantity;\n\n        await updateRawMaterial(materialId, {\n          currentStock: newStock,\n        });\n      }\n    }\n\n    const createdTransaction = {\n      id: docRef.id,\n      materialId: transactionData.materialId,\n      type: transactionData.type,\n      quantity: transactionData.quantity,\n      reason: transactionData.reason,\n      relatedOrderId: transactionData.relatedOrderId || null,\n      createdBy: transactionData.createdBy,\n      createdAt: Timestamp.now(),\n    } as MaterialTransaction;\n\n    // Audit log\n    try {\n      const { logAudit } = await import(\"@/utils/auditLogger\");\n      await logAudit(\n        \"CREATE\",\n        \"material_transactions\",\n        docRef.id,\n        transactionData.createdBy,\n        null,\n        {\n          type: transactionData.type,\n          quantity: transactionData.quantity,\n          reason: transactionData.reason,\n        },\n        {\n          materialId: transactionData.materialId,\n          relatedOrderId: transactionData.relatedOrderId || null,\n        }\n      );\n    } catch (logError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Material transaction audit log error:\", logError);\n      }\n      // Log hatası işlemi engellememeli\n    }\n\n    return createdTransaction;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add material transaction error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"create\",\n        collection: \"rawMaterials/transactions\",\n        userId: transactionData.createdBy,\n        data: transactionData,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Hammade hareketlerini al\n */\nexport const getMaterialTransactions = async (materialId: string): Promise<MaterialTransaction[]> => {\n  try {\n    const snapshot = await getDocs(\n      collection(firestore, \"rawMaterials\", materialId, \"transactions\")\n    );\n    return snapshot.docs.map((doc) => {\n      const data = doc.data() as Omit<MaterialTransaction, \"id\">;\n      return {\n        id: doc.id,\n        materialId: data.materialId || \"\",\n        type: data.type || \"out\",\n        quantity: data.quantity || 0,\n        reason: data.reason || \"\",\n        relatedOrderId: data.relatedOrderId || null,\n        createdAt: data.createdAt || Timestamp.now(),\n        createdBy: data.createdBy || \"\",\n      } as MaterialTransaction;\n    });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get material transactions error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"read\",\n        collection: \"rawMaterials/transactions\",\n        userId: auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n// Material Comments and Activities\n\nexport interface MaterialComment {\n  id: string;\n  materialId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp;\n  updatedAt?: Timestamp | null;\n}\n\nexport interface MaterialActivity {\n  id: string;\n  materialId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp;\n}\n\n/**\n * Hammadde yorumu ekle\n */\nexport const addMaterialComment = async (\n  materialId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<MaterialComment> => {\n  try {\n    const commentData: Omit<MaterialComment, \"id\"> = {\n      materialId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"rawMaterials\", materialId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addMaterialActivity(materialId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Hammadeyi oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const material = await getRawMaterialById(materialId);\n      if (material?.createdBy && material.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: material.createdBy,\n          type: \"comment_added\",\n          title: \"Hammadenize Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} \"${material.name}\" hammadenize yorum ekledi: ${content.substring(0, 100)}${content.length > 100 ? \"...\" : \"\"}`,\n          read: false,\n          relatedId: materialId,\n          metadata: { commentId: docRef.id, commenterId: userId, commenterName: userName, commenterEmail: userEmail },\n        });\n      }\n    } catch (error) {\n      console.error(\"Send comment notification error:\", error);\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error) {\n    console.error(\"Add material comment error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Hammadde yorumlarını al\n */\nexport const getMaterialComments = async (materialId: string): Promise<MaterialComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"rawMaterials\", materialId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as MaterialComment[];\n  } catch (error) {\n    console.error(\"Get material comments error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Hammadde aktivite log ekle\n */\nexport const addMaterialActivity = async (\n  materialId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<MaterialActivity, \"id\"> = {\n      materialId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"rawMaterials\", materialId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error) {\n    console.error(\"Add material activity error:\", error);\n    return \"\";\n  }\n};\n\n/**\n * Hammadde aktivite loglarını al\n */\nexport const getMaterialActivities = async (materialId: string): Promise<MaterialActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"rawMaterials\", materialId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as MaterialActivity[];\n  } catch (error) {\n    console.error(\"Get material activities error:\", error);\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\notificationService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":88,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2635,2638],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2635,2638],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":93,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2899,2902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2899,2902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'q' is never reassigned. Use 'const' instead.","line":327,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":327,"endColumn":10,"fix":{"range":[9828,9849],"text":"const q = buildQuery();"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Firebase Notification Service\n * Bildirim yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n  onSnapshot,\n  Unsubscribe,\n  QueryConstraint,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { sendNotificationEmail } from \"@/services/emailService\";\n\nexport interface Notification {\n  id: string;\n  userId: string;\n  type: \"task_assigned\" | \"task_updated\" | \"task_completed\" | \"task_created\" | \"task_deleted\" | \"task_pool_request\" | \"order_created\" | \"order_updated\" | \"role_changed\" | \"system\" | \"task_approval\" | \"comment_added\";\n  title: string;\n  message: string;\n  read: boolean;\n  relatedId?: string | null; // task ID, order ID, vb.\n  metadata?: Record<string, unknown> | null; // assignment_id, vb. için\n  createdAt: Timestamp;\n}\n\n/**\n * Kullanıcının bildirimlerini al\n */\nexport const getNotifications = async (\n  userId: string,\n  options?: { unreadOnly?: boolean; limit?: number }\n): Promise<Notification[]> => {\n  try {\n    // Firestore index gereksinimleri: equality filtreler önce, sonra orderBy\n    // Index: read (ASC), userId (ASC), createdAt (DESC)\n    let q = query(\n      collection(firestore, \"notifications\"),\n      where(\"userId\", \"==\", userId)\n    );\n\n    if (options?.unreadOnly) {\n      q = query(q, where(\"read\", \"==\", false));\n    }\n\n    // orderBy her zaman en sonda olmalı\n    q = query(q, orderBy(\"createdAt\", \"desc\"));\n\n    if (options?.limit) {\n      q = query(q, limit(options.limit));\n    }\n\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as Notification[];\n  } catch (error: unknown) {\n    const isIndexError =\n      typeof error === \"object\" &&\n      error !== null &&\n      \"code\" in error &&\n      (error as { code?: string }).code === \"failed-precondition\" &&\n      \"message\" in error &&\n      typeof (error as { message?: string }).message === \"string\" &&\n      (error as { message: string }).message.includes(\"index\");\n\n    if (isIndexError) {\n      // Index hatası durumunda boş array döndür (işlemin devam etmesini engelleme)\n      // Index oluşturulana kadar bildirimler görünmeyecek ama sistem çalışmaya devam edecek\n      // Hataları sessizce handle et - sadece development'ta ilk kez göster\n      if (import.meta.env.DEV) {\n        const message = (error as { message: string }).message;\n        const indexUrl = message.match(/https:\\/\\/[^\\s]+/)?.[0];\n        // Sadece ilk kez göster (tekrar tekrar loglamayı önle)\n        if (!(window as any).__firestoreIndexWarningShown) {\n          console.debug(\"ℹ️ Firestore index eksik. Bildirimler index oluşturulana kadar görünmeyecek.\");\n          if (indexUrl) {\n            console.debug(\"Index oluşturma linki:\", indexUrl);\n          }\n          (window as any).__firestoreIndexWarningShown = true;\n        }\n      }\n      return [];\n    }\n\n    // Diğer hatalar için de boş array döndür (sistemin çalışmaya devam etmesi için)\n    // Sadece gerçek hataları logla (index hatası değilse)\n    if (import.meta.env.DEV) {\n      console.debug(\"Get notifications error (non-index):\", error);\n    }\n    return [];\n  }\n};\n\n/**\n * Okunmamış bildirim sayısını al\n */\nexport const getUnreadNotificationCount = async (userId: string): Promise<number> => {\n  try {\n    const q = query(\n      collection(firestore, \"notifications\"),\n      where(\"userId\", \"==\", userId),\n      where(\"read\", \"==\", false)\n    );\n    const snapshot = await getDocs(q);\n    return snapshot.size;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Get unread notification count error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Bildirim oluştur\n */\nexport const createNotification = async (\n  notificationData: Omit<Notification, \"id\" | \"createdAt\">\n): Promise<Notification> => {\n  try {\n    const docRef = await addDoc(collection(firestore, \"notifications\"), {\n      ...notificationData,\n      createdAt: serverTimestamp(),\n    });\n\n    const createdNotification = await getDoc(docRef);\n    if (!createdNotification.exists()) {\n      throw new Error(\"Bildirim oluşturulamadı\");\n    }\n\n    const notification = {\n      id: createdNotification.id,\n      ...createdNotification.data(),\n    } as Notification;\n\n    // Bildirim başarıyla oluşturuldu, hemen döndür\n    // Email gönderimi arka planda yapılacak (hem Cloud Functions hem de manuel fallback)\n\n    // Email gönderimini arka planda başlat (await etme)\n    // Önce Cloud Functions denenecek, eğer çalışmıyorsa manuel email gönderimi yapılacak\n    Promise.resolve().then(async () => {\n      try {\n        const userDoc = await getDoc(doc(firestore, \"users\", notificationData.userId));\n        if (userDoc.exists()) {\n          const userData = userDoc.data();\n          if (userData?.email) {\n            // Manuel email gönderimi (Cloud Functions çalışmıyorsa fallback)\n            // Hata olsa bile sessizce devam et\n            try {\n              const emailResult = await sendNotificationEmail(\n                userData.email,\n                notificationData.title,\n                notificationData.message,\n                notificationData.type,\n                notificationData.relatedId || null,\n                notificationData.metadata || null\n              );\n\n              // Email gönderim sonucunu logla (sadece başarılı olduğunda)\n              if (import.meta.env.DEV && emailResult.success) {\n                console.log(`✅ Bildirim maili gönderildi: ${userData.email}`);\n              }\n            } catch (emailError: unknown) {\n              // Email gönderilemedi - sessizce devam et\n              // Cloud Functions da email gönderebilir, bu yüzden kritik değil\n            }\n          }\n        }\n      } catch (error) {\n        // Hata olsa bile sessizce devam et\n      }\n    }).catch(() => {\n      // Promise rejection'ı yakala ama hiçbir şey yapma\n    });\n\n    // Bildirimi hemen döndür (email gönderimi arka planda devam edecek)\n    return notification;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Create notification error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Bildirimi güncelle\n */\nexport const updateNotification = async (\n  notificationId: string,\n  updates: Partial<Omit<Notification, \"id\" | \"userId\" | \"createdAt\">>\n): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"notifications\", notificationId), updates);\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Update notification error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Bildirimi okundu olarak işaretle\n */\nexport const markNotificationAsRead = async (notificationId: string): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"notifications\", notificationId), {\n      read: true,\n    });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Mark notification as read error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Tüm bildirimleri okundu olarak işaretle\n */\nexport const markAllNotificationsAsRead = async (userId: string): Promise<void> => {\n  try {\n    const q = query(\n      collection(firestore, \"notifications\"),\n      where(\"userId\", \"==\", userId),\n      where(\"read\", \"==\", false)\n    );\n    const snapshot = await getDocs(q);\n\n    const batch = snapshot.docs.map((doc) =>\n      updateDoc(doc.ref, { read: true })\n    );\n\n    await Promise.all(batch);\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Mark all notifications as read error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Bildirimi sil\n */\nexport const deleteNotification = async (notificationId: string): Promise<void> => {\n  try {\n    await deleteDoc(doc(firestore, \"notifications\", notificationId));\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Delete notification error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Kullanıcının tüm bildirimlerini sil\n * Kullanıcı hesabı silindiğinde çağrılır\n */\nexport const deleteUserNotifications = async (userId: string): Promise<void> => {\n  try {\n    const q = query(\n      collection(firestore, \"notifications\"),\n      where(\"userId\", \"==\", userId)\n    );\n    const snapshot = await getDocs(q);\n\n    if (snapshot.empty) {\n      if (import.meta.env.DEV) {\n        console.log(`Kullanıcı ${userId} için silinecek bildirim bulunamadı`);\n      }\n      return;\n    }\n\n    // Tüm bildirimleri paralel sil\n    const deletePromises = snapshot.docs.map((docSnapshot) =>\n      deleteDoc(doc(firestore, \"notifications\", docSnapshot.id))\n    );\n\n    await Promise.all(deletePromises);\n\n    if (import.meta.env.DEV) {\n      console.log(`${snapshot.size} bildirim silindi (kullanıcı: ${userId})`);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Delete user notifications error:\", error);\n    // Hata fırlatma - bu işlem kritik değil, ana işlem devam etmeli\n  }\n};\n\n/**\n * Bildirimleri gerçek zamanlı olarak dinle\n * @param userId Kullanıcı ID'si\n * @param options Bildirim seçenekleri\n * @param callback Bildirimler değiştiğinde çağrılacak callback\n * @returns Unsubscribe fonksiyonu\n */\nexport const subscribeToNotifications = (\n  userId: string,\n  options: { unreadOnly?: boolean; limit?: number } = {},\n  callback: (notifications: Notification[]) => void\n): Unsubscribe => {\n  try {\n    const notificationsRef = collection(firestore, \"notifications\");\n\n    const buildQuery = () => {\n      const constraints: QueryConstraint[] = [\n        where(\"userId\", \"==\", userId),\n        orderBy(\"createdAt\", \"desc\")\n      ];\n\n      if (options?.unreadOnly) {\n        constraints.push(where(\"read\", \"==\", false));\n      }\n\n      if (options?.limit) {\n        constraints.push(limit(options.limit));\n      }\n\n      return query(notificationsRef, ...constraints);\n    };\n\n    let q = buildQuery();\n\n    // onSnapshot ile gerçek zamanlı dinleme\n    const unsubscribe = onSnapshot(\n      q,\n      (snapshot) => {\n        try {\n          const notifications = snapshot.docs.map((doc) => ({\n            id: doc.id,\n            ...doc.data(),\n          })) as Notification[];\n\n          callback(notifications);\n        } catch (error: unknown) {\n          if (import.meta.env.DEV) console.error(\"Subscribe to notifications error:\", error);\n          callback([]);\n        }\n      },\n      (error) => {\n        // 404 ve network hatalarını sessizce handle et (Firestore otomatik yeniden bağlanacak)\n        // Production'da da sessizce handle et - bu normal Firestore long-polling davranışı\n        if (error?.code === 'unavailable' ||\n          error?.code === 'not-found' ||\n          error?.message?.includes('404') ||\n          error?.message?.includes('network') ||\n          error?.message?.includes('transport errored')) {\n          // Sessizce handle et - Firestore otomatik olarak yeniden bağlanacak\n          // Production'da console'a yazma (performans ve gürültü azaltma)\n          callback([]);\n          return;\n        }\n\n        // Sadece gerçek hataları logla\n        if (import.meta.env.DEV) {\n          console.error(\"Notifications snapshot error:\", error);\n        }\n        // Index hatası durumunda basit query dene\n        if (error?.code === 'failed-precondition' || error?.message?.includes('index')) {\n          try {\n            const simpleQuery = query(\n              notificationsRef,\n              where(\"userId\", \"==\", userId),\n              orderBy(\"createdAt\", \"desc\")\n            );\n            const fallbackUnsubscribe = onSnapshot(\n              simpleQuery,\n              (snapshot) => {\n                try {\n                  let notifications = snapshot.docs.map((doc) => ({\n                    id: doc.id,\n                    ...doc.data(),\n                  })) as Notification[];\n\n                  // Client-side filtreleme\n                  if (options?.unreadOnly) {\n                    notifications = notifications.filter(n => !n.read);\n                  }\n                  if (options?.limit) {\n                    notifications = notifications.slice(0, options.limit);\n                  }\n\n                  callback(notifications);\n                } catch (err: unknown) {\n                  if (import.meta.env.DEV) console.error(\"Fallback subscribe to notifications error:\", err);\n                  callback([]);\n                }\n              },\n              (err: unknown) => {\n                if (import.meta.env.DEV) console.error(\"Fallback notifications snapshot error:\", err);\n                callback([]);\n              }\n            );\n            return fallbackUnsubscribe;\n          } catch (fallbackError: unknown) {\n            if (import.meta.env.DEV) console.error(\"Fallback query setup error:\", fallbackError);\n            callback([]);\n          }\n        } else {\n          callback([]);\n        }\n      }\n    );\n\n    return unsubscribe;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) console.error(\"Subscribe to notifications setup error:\", error);\n    return () => { };\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\orderService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":530,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":530,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17373,17376],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17373,17376],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":535,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":535,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17563,17566],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17563,17566],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'q' is never reassigned. Use 'const' instead.","line":900,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":900,"endColumn":10,"fix":{"range":[29065,29086],"text":"const q = buildQuery();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1017,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1017,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[32792,32795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[32792,32795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":1109,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":1109,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[35323,35326],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[35323,35326],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Firebase Order Service\n * Sipariş yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n  onSnapshot,\n  Unsubscribe,\n  QueryConstraint,\n  FieldValue,\n  writeBatch,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\n\nexport interface OrderItem {\n  id: string;\n  productId?: string | null;\n  product_id?: string | null; // Alias\n  productName?: string | null;\n  product_name?: string | null; // Alias\n  quantity: number;\n  unitPrice: number;\n  unit_price?: number; // Alias\n  discount?: number;\n  discountType?: \"amount\" | \"percentage\"; // İndirim tipi: tutar veya yüzde\n  total: number;\n  category?: string | null;\n}\n\nexport interface Order {\n  id: string;\n  orderNumber: string;\n  order_number?: string; // Alias\n  customerId?: string | null;\n  customer_id?: string | null; // Alias\n  customerName?: string | null;\n  customer_name?: string | null; // Alias\n  customerCompany?: string | null;\n  customer_company?: string | null; // Alias\n  status: \"draft\" | \"pending\" | \"confirmed\" | \"planned\" | \"in_production\" | \"quality_check\" | \"completed\" | \"shipped\" | \"delivered\" | \"cancelled\" | \"on_hold\";\n  approvalStatus?: \"pending\" | \"approved\" | \"rejected\";\n  approvalRequestedBy?: string;\n  approvalRequestedAt?: Timestamp;\n  approvedBy?: string;\n  approvedAt?: Timestamp;\n  rejectedBy?: string;\n  rejectedAt?: Timestamp;\n  rejectionReason?: string;\n  statusUpdatedBy?: string;\n  statusUpdatedAt?: Timestamp;\n  subtotal?: number;\n  taxAmount?: number;\n  discountTotal?: number;\n  itemsCount?: number;\n  totalQuantity?: number;\n  totalAmount?: number;\n  total_amount?: number; // Alias\n  taxRate?: number;\n  tax_rate?: number; // Alias\n  items_count?: number; // Alias\n  total_quantity?: number; // Alias\n  currency?: string;\n  orderDate?: Timestamp | null;\n  order_date?: string | null; // Alias (string format)\n  deliveryDate?: Timestamp | null;\n  delivery_date?: string | null; // Alias (string format)\n  receivedDate?: Timestamp | null; // Teslim alınan tarih\n  received_date?: string | null; // Alias (string format)\n  dueDate?: Timestamp | null;\n  due_date?: string | null; // Alias (string format)\n  notes?: string | null;\n  paymentTerms?: string | null;\n  payment_terms?: string | null; // Alias\n  createdAt: Timestamp;\n  created_at?: string; // Alias (string format)\n  updatedAt: Timestamp;\n  updated_at?: string; // Alias (string format)\n  createdBy: string;\n  created_by?: string; // Alias\n  customerEmail?: string | null;\n  customer_email?: string | null; // Alias\n  customerPhone?: string | null;\n  customer_phone?: string | null; // Alias\n  shippingAddress?: string | null;\n  shipping_address?: string | null; // Alias\n  deliveryAddress?: string | null;\n  delivery_address?: string | null; // Alias\n  shippingNotes?: string | null;\n  shipping_notes?: string | null; // Alias\n  deliveryNotes?: string | null;\n  delivery_notes?: string | null; // Alias\n  priority?: number | null;\n  deductMaterials?: boolean; // Hammadde düşürme (varsayılan: true)\n}\n\n/**\n * Tüm siparişleri listele\n */\nexport const getOrders = async (filters?: {\n  customerId?: string;\n  status?: string;\n}): Promise<Order[]> => {\n  try {\n    // Performans için limit ekle (500 kayıt)\n    let q = query(collection(firestore, \"orders\"), orderBy(\"createdAt\", \"desc\"), limit(500));\n\n    if (filters?.customerId) {\n      q = query(q, where(\"customerId\", \"==\", filters.customerId));\n    }\n\n    if (filters?.status) {\n      q = query(q, where(\"status\", \"==\", filters.status));\n    }\n\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as Order[];\n  } catch (error: unknown) {\n    // Index hatası durumunda basit query dene\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorCode = (error as { code?: string })?.code;\n    if (errorCode === 'failed-precondition' || errorMessage.includes('index')) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Orders index bulunamadı, basit query kullanılıyor\");\n      }\n      try {\n        const simpleQuery = query(collection(firestore, \"orders\"), orderBy(\"createdAt\", \"desc\"), limit(500));\n        const snapshot = await getDocs(simpleQuery);\n        let orders = snapshot.docs.map((doc) => ({\n          id: doc.id,\n          ...doc.data(),\n        })) as Order[];\n        \n        // Client-side filtreleme\n        if (filters?.customerId) {\n          orders = orders.filter(o => o.customerId === filters.customerId);\n        }\n        if (filters?.status) {\n          orders = orders.filter(o => o.status === filters.status);\n        }\n        \n        return orders;\n      } catch (fallbackError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Fallback query de başarısız:\", fallbackError);\n        }\n        // Son çare: filtreleme olmadan (limit ile)\n        const snapshot = await getDocs(query(collection(firestore, \"orders\"), limit(500)));\n        let orders = snapshot.docs.map((doc) => ({\n          id: doc.id,\n          ...doc.data(),\n        })) as Order[];\n        \n        // Client-side filtreleme\n        if (filters?.customerId) {\n          orders = orders.filter(o => o.customerId === filters.customerId);\n        }\n        if (filters?.status) {\n          orders = orders.filter(o => o.status === filters.status);\n        }\n        \n        // Tarihe göre sırala\n        orders.sort((a, b) => {\n          const aDate = a.createdAt?.toMillis() || 0;\n          const bDate = b.createdAt?.toMillis() || 0;\n          return bDate - aDate;\n        });\n        \n        return orders;\n      }\n    }\n    if (import.meta.env.DEV) {\n      console.error(\"Get orders error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Sipariş detayını al\n */\nexport const getOrderById = async (orderId: string): Promise<Order | null> => {\n  try {\n    const orderDoc = await getDoc(doc(firestore, \"orders\", orderId));\n    \n    if (!orderDoc.exists()) {\n      return null;\n    }\n\n    return {\n      id: orderDoc.id,\n      ...orderDoc.data(),\n    } as Order;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get order by id error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Sipariş kalemlerini al\n */\nexport const getOrderItems = async (orderId: string): Promise<OrderItem[]> => {\n  try {\n    const snapshot = await getDocs(collection(firestore, \"orders\", orderId, \"items\"));\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as OrderItem[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get order items error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Sipariş kalemini güncelle\n */\nexport const updateOrderItem = async (\n  orderId: string,\n  itemId: string,\n  updates: Partial<Omit<OrderItem, \"id\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const itemDoc = await getDoc(doc(firestore, \"orders\", orderId, \"items\", itemId));\n    const oldItem = itemDoc.data() as OrderItem | undefined;\n    \n    await updateDoc(doc(firestore, \"orders\", orderId, \"items\", itemId), updates);\n    \n    // Audit log\n    if (userId) {\n      const newItem = { ...oldItem, ...updates } as OrderItem;\n      await logAudit(\n        \"UPDATE\",\n        \"order_items\",\n        itemId,\n        userId,\n        oldItem || null,\n        newItem,\n        { orderId }\n      );\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Update order item error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni sipariş oluştur\n */\nexport const createOrder = async (\n  orderData: Omit<Order, \"id\" | \"createdAt\" | \"updatedAt\"> & { deductMaterials?: boolean },\n  items?: Omit<OrderItem, \"id\">[]\n): Promise<Order> => {\n  try {\n    const docRef = await addDoc(collection(firestore, \"orders\"), {\n      ...orderData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n\n    // Sipariş kalemlerini batch write ile ekle (optimize edildi)\n    if (items && items.length > 0) {\n      const batch = writeBatch(firestore);\n      const itemsCollection = collection(firestore, \"orders\", docRef.id, \"items\");\n      \n      // Tüm item'ları batch'e ekle\n      const itemRefs: string[] = [];\n      for (const item of items) {\n        const itemRef = doc(itemsCollection);\n        batch.set(itemRef, item);\n        itemRefs.push(itemRef.id);\n      }\n      \n      // Batch'i commit et\n      await batch.commit();\n      \n      // Audit log'ları toplu olarak ekle (paralel)\n      if (orderData.createdBy && itemRefs.length > 0) {\n        await Promise.all(\n          itemRefs.map((itemId, index) =>\n            logAudit(\n              \"CREATE\",\n              \"order_items\",\n              itemId,\n              orderData.createdBy,\n              null,\n              items[index],\n              { orderId: docRef.id }\n            ).catch((error) => {\n              // Audit log hatası sipariş oluşturmayı engellemez\n              if (import.meta.env.DEV) {\n                console.error(`Audit log error for item ${itemId}:`, error);\n              }\n            })\n          )\n        );\n      }\n    }\n\n    // Gereksiz re-fetch kaldırıldı - order'ı direkt oluştur\n    const createdOrder: Order = {\n      id: docRef.id,\n      ...orderData,\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now(),\n    } as Order;\n\n    // Hammadde düşürme kontrolü: PROD- ile başlayan siparişler veya deductMaterials=true olan siparişler\n    const isProductionOrder = orderData.orderNumber?.startsWith(\"PROD-\") || orderData.order_number?.startsWith(\"PROD-\");\n    const shouldDeductMaterials = isProductionOrder || orderData.deductMaterials === true;\n    \n    if (shouldDeductMaterials && items && items.length > 0) {\n      try {\n        const { getProductRecipes } = await import(\"@/services/firebase/recipeService\");\n        const { getRawMaterialById, updateRawMaterial, addMaterialTransaction } = await import(\"@/services/firebase/materialService\");\n        \n        // Tüm reçeteleri paralel olarak topla\n        const allRecipePromises = items\n          .filter(item => item.product_id || item.productId)\n          .map(async (item) => {\n            const productId = item.product_id || item.productId;\n            const quantity = item.quantity || 1;\n            const recipes = await getProductRecipes(productId);\n            return recipes.map(recipe => ({\n              recipe,\n              quantity,\n              productName: item.product_name || 'Ürün',\n              item,\n            }));\n          });\n        \n        const allRecipeArrays = await Promise.all(allRecipePromises);\n        const allRecipes = allRecipeArrays.flat();\n        \n        // Tüm material'ları paralel olarak çek\n        const materialIds = [...new Set(allRecipes.map(r => r.recipe.rawMaterialId).filter(Boolean))];\n        const materialPromises = materialIds.map(id => getRawMaterialById(id!));\n        const materials = await Promise.all(materialPromises);\n        const materialMap = new Map(materials.filter(Boolean).map(m => [m!.id, m!]));\n        \n        // Material güncellemelerini ve transaction'ları hazırla\n        const materialUpdates: Array<{\n          materialId: string;\n          newStock: number;\n          totalQuantity: number;\n          reason: string;\n        }> = [];\n        \n        // Her reçete için güncelleme bilgilerini topla\n        for (const { recipe, quantity, productName } of allRecipes) {\n          if (recipe.rawMaterialId) {\n            const material = materialMap.get(recipe.rawMaterialId);\n            if (material) {\n              const totalQuantity = recipe.quantityPerUnit * quantity;\n              \n              // Stok kontrolü\n              if (material.currentStock < totalQuantity) {\n                if (import.meta.env.DEV) {\n                  console.warn(`Yetersiz stok: ${material.name} için ${totalQuantity} gerekli, ${material.currentStock} mevcut`);\n                }\n              }\n              \n              const newStock = Math.max(0, material.currentStock - totalQuantity);\n              \n              // Aynı material için miktarları topla (eğer birden fazla reçete varsa)\n              const existingUpdate = materialUpdates.find(u => u.materialId === recipe.rawMaterialId);\n              if (existingUpdate) {\n                existingUpdate.newStock = Math.max(0, existingUpdate.newStock - totalQuantity);\n                existingUpdate.totalQuantity += totalQuantity;\n              } else {\n                materialUpdates.push({\n                  materialId: recipe.rawMaterialId,\n                  newStock,\n                  totalQuantity,\n                  reason: `${isProductionOrder ? 'Üretim siparişi' : 'Sipariş'}: ${orderData.orderNumber || docRef.id} - ${productName} (${quantity} adet)`,\n                });\n              }\n            }\n          }\n        }\n        \n        // Tüm material güncellemelerini paralel yap\n        await Promise.all(\n          materialUpdates.map(async (update) => {\n            try {\n              await updateRawMaterial(update.materialId, {\n                currentStock: update.newStock,\n              });\n              \n              // Stok hareketi kaydı ekle (stok zaten güncellendi, skipStockUpdate: true)\n              await addMaterialTransaction({\n                materialId: update.materialId,\n                type: \"out\",\n                quantity: update.totalQuantity,\n                reason: update.reason,\n                relatedOrderId: docRef.id,\n                createdBy: orderData.createdBy,\n              }, true); // skipStockUpdate: true - stok zaten güncellendi\n            } catch (error) {\n              // Bir material güncellemesi hatası diğerlerini engellemez\n              if (import.meta.env.DEV) {\n                console.error(`Material update error for ${update.materialId}:`, error);\n              }\n            }\n          })\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Hammadde stok düşürme hatası:\", error);\n        }\n        // Hata olsa bile sipariş oluşturulmuş olacak, sadece log\n      }\n    }\n\n    // Audit log\n    await logAudit(\"CREATE\", \"orders\", docRef.id, orderData.createdBy, null, createdOrder);\n\n    // Aktivite log ekle\n    if (orderData.createdBy) {\n      try {\n        const { getUserProfile } = await import(\"@/services/firebase/authService\");\n        const userProfile = await getUserProfile(orderData.createdBy);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addOrderActivity(\n          docRef.id,\n          orderData.createdBy,\n          \"created\",\n          `bu siparişi oluşturdu`,\n          { orderNumber: orderData.orderNumber || orderData.order_number },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add order activity error:\", error);\n        }\n      }\n    }\n\n    return createdOrder;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Create order error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Sipariş durumu geçiş validasyonu\n */\nconst isValidStatusTransition = (currentStatus: string, newStatus: string): boolean => {\n  const validTransitions: Record<string, string[]> = {\n    draft: [\"pending\", \"cancelled\"],\n    pending: [\"confirmed\", \"cancelled\"],\n    confirmed: [\"in_production\", \"on_hold\", \"cancelled\"],\n    planned: [\"in_production\", \"pending\", \"on_hold\", \"cancelled\"], // Production order için\n    in_production: [\"quality_check\", \"completed\", \"on_hold\", \"cancelled\"],\n    quality_check: [\"completed\", \"in_production\", \"on_hold\", \"cancelled\"],\n    completed: [], // Üretim siparişleri için tamamlandı durumundan sonra geçiş yok\n    on_hold: [\"in_production\", \"cancelled\"],\n    shipped: [\"delivered\"],\n    delivered: [\"completed\", \"quality_check\", \"in_production\"],\n    cancelled: [],\n  };\n\n  const allowedStatuses = validTransitions[currentStatus] || [];\n  return allowedStatuses.includes(newStatus);\n};\n\n/**\n * Siparişi güncelle\n */\nexport const updateOrder = async (\n  orderId: string,\n  updates: Partial<Omit<Order, \"id\" | \"createdAt\" | \"createdBy\">>,\n  userId?: string,\n  skipStatusValidation?: boolean\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldOrder = await getOrderById(orderId);\n    \n    if (!oldOrder) {\n      throw new Error(\"Sipariş bulunamadı\");\n    }\n\n    // Status değişikliği varsa validasyon yap (üst yöneticiler için atlanabilir)\n    if (updates.status && updates.status !== oldOrder.status) {\n      // Üst yöneticiler için validasyonu atla\n      if (!skipStatusValidation && !isValidStatusTransition(oldOrder.status, updates.status)) {\n        throw new Error(\n          `Geçersiz durum geçişi: ${oldOrder.status} → ${updates.status}. ` +\n          `Geçerli geçişler: ${getValidStatusTransitions(oldOrder.status).join(\", \")}`\n        );\n      }\n    }\n    \n    // Status değişikliği varsa statusUpdatedBy ve statusUpdatedAt ekle\n    const updateData: Partial<Order> & { statusUpdatedBy?: string; statusUpdatedAt?: FieldValue | Timestamp } = {\n      ...updates,\n      updatedAt: serverTimestamp() as any,\n    };\n    \n    if (updates.status && updates.status !== oldOrder.status && userId) {\n      updateData.statusUpdatedBy = userId;\n      updateData.statusUpdatedAt = serverTimestamp() as any;\n    }\n    \n    await updateDoc(doc(firestore, \"orders\", orderId), updateData);\n    \n    // Yeni veriyi al\n    const newOrder = await getOrderById(orderId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"orders\", orderId, userId, oldOrder, newOrder);\n    }\n\n    // Aktivite log ekle\n    if (userId) {\n      try {\n        const { getUserProfile } = await import(\"@/services/firebase/authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        // Durum değişikliği aktivitesi\n        if (updates.status && updates.status !== oldOrder.status) {\n          const statusLabels: Record<string, string> = {\n            draft: \"Taslak\",\n            pending: \"Beklemede\",\n            confirmed: \"Onaylandı\",\n            planned: \"Planlanan\",\n            in_production: \"Üretimde\",\n            quality_check: \"Kalite Kontrol\",\n            completed: \"Tamamlandı\",\n            shipped: \"Kargoda\",\n            delivered: \"Teslim Edildi\",\n            on_hold: \"Beklemede\",\n            cancelled: \"İptal\",\n          };\n          const oldStatusLabel = statusLabels[oldOrder.status] || oldOrder.status;\n          const newStatusLabel = statusLabels[updates.status] || updates.status;\n          await addOrderActivity(\n            orderId,\n            userId,\n            \"status_changed\",\n            `bu siparişi ${oldStatusLabel} durumundan ${newStatusLabel} durumuna taşıdı`,\n            { oldStatus: oldOrder.status, newStatus: updates.status },\n            userName,\n            userEmail\n          );\n        } else {\n          // Genel güncelleme aktivitesi\n          const changedFields = Object.keys(updates).filter(key => {\n            const oldValue = (oldOrder as unknown as Record<string, unknown>)[key];\n            const newValue = (updates as Record<string, unknown>)[key];\n            return oldValue !== newValue;\n          });\n          \n          if (changedFields.length > 0) {\n            await addOrderActivity(\n              orderId,\n              userId,\n              \"updated\",\n              `bu siparişi güncelledi`,\n              { changedFields },\n              userName,\n              userEmail\n            );\n          }\n        }\n      } catch (error) {\n        // Aktivite log hatası ana işlemi etkilememeli\n        console.error(\"Add order activity error:\", error);\n      }\n    }\n\n    // Siparişi tanımlayan kişiye bildirim gönder (güncelleyen kişi hariç)\n    if (oldOrder.createdBy && oldOrder.createdBy !== userId) {\n      try {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        const { getUserProfile } = await import(\"@/services/firebase/authService\");\n        \n        const updaterProfile = userId ? await getUserProfile(userId) : null;\n        const updaterName = updaterProfile?.fullName || updaterProfile?.displayName || updaterProfile?.email || \"Bir kullanıcı\";\n        \n        let message = `\"${oldOrder.orderNumber || oldOrder.order_number || orderId}\" siparişi güncellendi.`;\n        \n        // Status değişikliği varsa özel mesaj\n        if (updates.status && updates.status !== oldOrder.status) {\n          const statusLabels: Record<string, string> = {\n            draft: \"Taslak\",\n            pending: \"Beklemede\",\n            confirmed: \"Onaylandı\",\n            in_production: \"Üretimde\",\n            quality_check: \"Kalite Kontrol\",\n            completed: \"Tamamlandı\",\n            shipped: \"Kargoda\",\n            delivered: \"Teslim Edildi\",\n            cancelled: \"İptal\",\n            on_hold: \"Beklemede\",\n          };\n          const oldStatusLabel = statusLabels[oldOrder.status] || oldOrder.status;\n          const newStatusLabel = statusLabels[updates.status] || updates.status;\n          const updateTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n          message = `\"${oldOrder.orderNumber || oldOrder.order_number || orderId}\" sipariş numaralı siparişin durumu \"${oldStatusLabel}\" durumundan \"${newStatusLabel}\" durumuna güncellendi.\\n\\nİşlem Zamanı: ${updateTime}`;\n        } else {\n          const updateTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n          message = `\"${oldOrder.orderNumber || oldOrder.order_number || orderId}\" sipariş numaralı sipariş güncellendi.\\n\\nİşlem Zamanı: ${updateTime}`;\n        }\n        \n        await createNotification({\n          userId: oldOrder.createdBy,\n          type: \"order_updated\",\n          title: \"Siparişiniz güncellendi\",\n          message: `${updaterName} kullanıcısı tarafından ${message}`,\n          read: false,\n          relatedId: orderId,\n          metadata: { \n            updatedBy: userId,\n            statusChanged: updates.status && updates.status !== oldOrder.status,\n            oldStatus: oldOrder.status,\n            newStatus: updates.status || oldOrder.status,\n            updatedAt: new Date(),\n          },\n        });\n      } catch (notifError) {\n        console.error(\"Sipariş güncelleme bildirimi gönderilemedi:\", notifError);\n        // Bildirim hatası sipariş güncellemesini engellemez\n      }\n    }\n  } catch (error) {\n    console.error(\"Update order error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Sipariş tamamlanma onayı iste\n */\nexport const requestOrderCompletion = async (\n  orderId: string,\n  userId: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldOrder = await getOrderById(orderId);\n    \n    await updateDoc(doc(firestore, \"orders\", orderId), {\n      approvalStatus: \"pending\",\n      approvalRequestedBy: userId,\n      approvalRequestedAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Audit log\n    if (userId) {\n      const newOrder = await getOrderById(orderId);\n      await logAudit(\n        \"UPDATE\",\n        \"orders\",\n        orderId,\n        userId,\n        oldOrder,\n        newOrder,\n        { action: \"request_completion\", approvalStatus: \"pending\" }\n      );\n    }\n    \n    // Opsiyonel: Bildirim gönderilebilir\n  } catch (error) {\n    console.error(\"Request order completion error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Sipariş tamamlanmasını onayla\n */\nexport const approveOrderCompletion = async (\n  orderId: string,\n  userId: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldOrder = await getOrderById(orderId);\n    \n    await updateDoc(doc(firestore, \"orders\", orderId), {\n      status: \"completed\",\n      approvalStatus: \"approved\",\n      approvedBy: userId,\n      approvedAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Audit log\n    if (userId) {\n      const newOrder = await getOrderById(orderId);\n      await logAudit(\n        \"UPDATE\",\n        \"orders\",\n        orderId,\n        userId,\n        oldOrder,\n        newOrder,\n        { action: \"approve_completion\", approvalStatus: \"approved\" }\n      );\n    }\n    \n    // Opsiyonel: Bildirim\n  } catch (error) {\n    console.error(\"Approve order completion error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Sipariş tamamlanmasını reddet\n */\nexport const rejectOrderCompletion = async (\n  orderId: string,\n  userId: string,\n  reason?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldOrder = await getOrderById(orderId);\n    \n    await updateDoc(doc(firestore, \"orders\", orderId), {\n      status: \"in_production\", // Geri döndür\n      approvalStatus: \"rejected\",\n      rejectedBy: userId,\n      rejectedAt: serverTimestamp(),\n      rejectionReason: reason || null,\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Audit log\n    if (userId) {\n      const newOrder = await getOrderById(orderId);\n      await logAudit(\n        \"UPDATE\",\n        \"orders\",\n        orderId,\n        userId,\n        oldOrder,\n        newOrder,\n        { action: \"reject_completion\", approvalStatus: \"rejected\", reason: reason || null }\n      );\n    }\n    \n    // Opsiyonel: Bildirim\n  } catch (error) {\n    console.error(\"Reject order completion error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Geçerli durum geçişlerini al\n */\nexport const getValidStatusTransitions = (currentStatus: string): string[] => {\n  const validTransitions: Record<string, string[]> = {\n    draft: [\"pending\", \"cancelled\"],\n    pending: [\"confirmed\", \"cancelled\"],\n    confirmed: [\"in_production\", \"on_hold\", \"cancelled\"],\n    planned: [\"in_production\", \"pending\", \"on_hold\", \"cancelled\"], // Production order için\n    in_production: [\"quality_check\", \"completed\", \"on_hold\", \"cancelled\"],\n    quality_check: [\"completed\", \"in_production\", \"on_hold\", \"cancelled\"],\n    completed: [], // Üretim siparişleri için tamamlandı durumundan sonra geçiş yok\n    on_hold: [\"in_production\", \"cancelled\"],\n    shipped: [\"delivered\"],\n    delivered: [\"completed\", \"quality_check\", \"in_production\"],\n    cancelled: [],\n  };\n\n  return validTransitions[currentStatus] || [];\n};\n\n/**\n * Sipariş durumunu güncelle (validasyon ile)\n */\nexport const updateOrderStatus = async (\n  orderId: string,\n  newStatus: Order[\"status\"],\n  userId?: string\n): Promise<void> => {\n  try {\n    await updateOrder(orderId, { status: newStatus }, userId);\n  } catch (error) {\n    console.error(\"Update order status error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Siparişi sil\n */\nexport const deleteOrder = async (orderId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldOrder = await getOrderById(orderId);\n    \n    // Aktivite log ekle (silmeden önce)\n    if (userId && oldOrder) {\n      try {\n        const { getUserProfile } = await import(\"@/services/firebase/authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addOrderActivity(\n          orderId,\n          userId,\n          \"deleted\",\n          `bu siparişi sildi`,\n          { orderNumber: oldOrder.orderNumber || oldOrder.order_number },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add order activity error:\", error);\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, \"orders\", orderId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"orders\", orderId, userId, oldOrder, null);\n    }\n  } catch (error) {\n    console.error(\"Delete order error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Siparişleri gerçek zamanlı olarak dinle\n * @param filters Sipariş filtreleri\n * @param callback Siparişler değiştiğinde çağrılacak callback\n * @returns Unsubscribe fonksiyonu\n */\nexport const subscribeToOrders = (\n  filters: {\n    customerId?: string;\n    status?: string;\n  } = {},\n  callback: (orders: Order[]) => void\n): Unsubscribe => {\n  try {\n    const ordersRef = collection(firestore, \"orders\");\n    \n    const buildQuery = () => {\n      const constraints: QueryConstraint[] = [orderBy(\"createdAt\", \"desc\")];\n      \n      if (filters?.customerId) {\n        constraints.push(where(\"customerId\", \"==\", filters.customerId));\n      }\n      \n      if (filters?.status) {\n        constraints.push(where(\"status\", \"==\", filters.status));\n      }\n      \n      return query(ordersRef, ...constraints);\n    };\n    \n    let q = buildQuery();\n    \n    // onSnapshot ile gerçek zamanlı dinleme\n    const unsubscribe = onSnapshot(\n      q,\n      (snapshot) => {\n        try {\n          let orders = snapshot.docs.map((doc) => ({\n            id: doc.id,\n            ...doc.data(),\n          })) as Order[];\n          \n          // Client-side filtreleme (index hatası durumunda)\n          if (filters?.customerId) {\n            orders = orders.filter(o => o.customerId === filters.customerId);\n          }\n          if (filters?.status) {\n            orders = orders.filter(o => o.status === filters.status);\n          }\n          \n          callback(orders);\n        } catch (error) {\n          console.error(\"Subscribe to orders error:\", error);\n          callback([]);\n        }\n      },\n      (error) => {\n        // 404 ve network hatalarını sessizce handle et (Firestore otomatik yeniden bağlanacak)\n        // Production'da da sessizce handle et - bu normal Firestore long-polling davranışı\n        if (error?.code === 'unavailable' || \n            error?.code === 'not-found' ||\n            error?.message?.includes('404') || \n            error?.message?.includes('network') ||\n            error?.message?.includes('transport errored')) {\n          // Sessizce handle et - Firestore otomatik olarak yeniden bağlanacak\n          // Production'da console'a yazma (performans ve gürültü azaltma)\n          callback([]);\n          return;\n        }\n        \n        // Sadece gerçek hataları logla\n        if (import.meta.env.DEV) {\n          console.error(\"Orders snapshot error:\", error);\n        }\n        // Index hatası durumunda basit query dene\n        if (error?.code === 'failed-precondition' || error?.message?.includes('index')) {\n          try {\n            const simpleQuery = query(ordersRef, orderBy(\"createdAt\", \"desc\"));\n            const fallbackUnsubscribe = onSnapshot(\n              simpleQuery,\n              (snapshot) => {\n                try {\n                  let orders = snapshot.docs.map((doc) => ({\n                    id: doc.id,\n                    ...doc.data(),\n                  })) as Order[];\n                  \n                  // Client-side filtreleme\n                  if (filters?.customerId) {\n                    orders = orders.filter(o => o.customerId === filters.customerId);\n                  }\n                  if (filters?.status) {\n                    orders = orders.filter(o => o.status === filters.status);\n                  }\n                  \n                  callback(orders);\n                } catch (err) {\n                  console.error(\"Fallback subscribe to orders error:\", err);\n                  callback([]);\n                }\n              },\n              (err) => {\n                console.error(\"Fallback orders snapshot error:\", err);\n                callback([]);\n              }\n            );\n            return fallbackUnsubscribe;\n          } catch (fallbackError) {\n            console.error(\"Fallback query setup error:\", fallbackError);\n            callback([]);\n          }\n        } else {\n          callback([]);\n        }\n      }\n    );\n    \n    return unsubscribe;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Subscribe to orders setup error:\", error);\n    }\n    return () => {};\n  }\n};\n\n// Order Comments and Activities\n\nexport interface OrderComment {\n  id: string;\n  orderId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp;\n  updatedAt?: Timestamp | null;\n}\n\nexport interface OrderActivity {\n  id: string;\n  orderId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp;\n}\n\n/**\n * Sipariş yorumu ekle\n */\nexport const addOrderComment = async (\n  orderId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<OrderComment> => {\n  try {\n    const commentData: Omit<OrderComment, \"id\"> = {\n      orderId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"orders\", orderId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addOrderActivity(orderId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Siparişi oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const order = await getOrderById(orderId);\n      if (order?.createdBy && order.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: order.createdBy,\n          type: \"comment_added\",\n          title: \"Siparişinize Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} \"${order.orderNumber || order.order_number || orderId}\" siparişinize yorum ekledi: ${content.substring(0, 100)}${content.length > 100 ? \"...\" : \"\"}`,\n          read: false,\n          relatedId: orderId,\n          metadata: { commentId: docRef.id, commenterId: userId, commenterName: userName, commenterEmail: userEmail },\n        });\n      }\n    } catch (error) {\n      // Bildirim hatası ana işlemi etkilememeli\n      console.error(\"Send comment notification error:\", error);\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error) {\n    console.error(\"Add order comment error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Sipariş yorumlarını al\n */\nexport const getOrderComments = async (orderId: string): Promise<OrderComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"orders\", orderId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as OrderComment[];\n  } catch (error) {\n    console.error(\"Get order comments error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Sipariş aktivite log ekle\n */\nexport const addOrderActivity = async (\n  orderId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<OrderActivity, \"id\"> = {\n      orderId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"orders\", orderId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add order activity error:\", error);\n    }\n    return \"\";\n  }\n};\n\n/**\n * Sipariş aktivite loglarını al\n */\nexport const getOrderActivities = async (orderId: string): Promise<OrderActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"orders\", orderId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as OrderActivity[];\n  } catch (error) {\n    console.error(\"Get order activities error:\", error);\n    throw error;\n  }\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\productService.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'products' is never reassigned. Use 'const' instead.","line":69,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":69,"endColumn":21,"fix":{"range":[1964,2081],"text":"const products = snapshot.docs.map((doc) => ({\n          id: doc.id,\n          ...doc.data(),\n        })) as Product[];"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":320,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8585,8588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8585,8588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":417,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11184,11187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11184,11187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Firebase Product Service\n * Ürün yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\n\nexport interface Product {\n  id: string;\n  name: string;\n  sku?: string | null; // Stock Keeping Unit\n  code?: string | null;\n  description?: string | null;\n  unitPrice?: number | null;\n  price?: number | null; // Alias for unitPrice\n  cost?: number | null;\n  unit: string; // 'adet', 'kg', 'm', vb.\n  stock?: number;\n  minStock?: number | null;\n  maxStock?: number | null;\n  category?: string | null;\n  imageUrl?: string | null;\n  image_url?: string | null; // Alias for imageUrl\n  location?: string | null;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n  createdBy: string;\n}\n\n/**\n * Tüm ürünleri listele\n */\nexport const getProducts = async (): Promise<Product[]> => {\n  try {\n    // Performans için limit ekle (500 kayıt)\n    const q = query(collection(firestore, \"products\"), orderBy(\"createdAt\", \"desc\"), limit(500));\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as Product[];\n  } catch (error: unknown) {\n    // Index hatası durumunda basit query dene\n    const errorMessage = error instanceof Error ? error.message : String(error);\n    const errorCode = (error as { code?: string })?.code;\n    if (errorCode === 'failed-precondition' || errorMessage.includes('index') || errorMessage.includes('requires an index')) {\n      if (import.meta.env.DEV) {\n        console.warn(\"Products index bulunamadı, basit query kullanılıyor\");\n      }\n      try {\n        // Index olmadan sıralama yapmadan dene\n        const simpleQuery = query(collection(firestore, \"products\"), limit(500));\n        const snapshot = await getDocs(simpleQuery);\n        let products = snapshot.docs.map((doc) => ({\n          id: doc.id,\n          ...doc.data(),\n        })) as Product[];\n        \n        // Client-side sıralama\n        products.sort((a, b) => {\n          const aDate = a.createdAt?.toMillis() || 0;\n          const bDate = b.createdAt?.toMillis() || 0;\n          return bDate - aDate;\n        });\n        \n        return products;\n      } catch (fallbackError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Fallback query de başarısız:\", fallbackError);\n        }\n        // Son çare: boş array döndür\n        return [];\n      }\n    }\n    // Sadece development'ta log göster\n    if (import.meta.env.DEV) {\n      console.error(\"Get products error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Ürün detayını al\n */\nexport const getProductById = async (productId: string): Promise<Product | null> => {\n  try {\n    const productDoc = await getDoc(doc(firestore, \"products\", productId));\n    \n    if (!productDoc.exists()) {\n      return null;\n    }\n\n    return {\n      id: productDoc.id,\n      ...productDoc.data(),\n    } as Product;\n  } catch (error) {\n    // Sadece development'ta log göster\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get product by id error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni ürün oluştur\n */\nexport const createProduct = async (\n  productData: Omit<Product, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<Product> => {\n  try {\n    const docRef = await addDoc(collection(firestore, \"products\"), {\n      ...productData,\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n\n    const createdProduct = await getProductById(docRef.id);\n    if (!createdProduct) {\n      throw new Error(\"Ürün oluşturulamadı\");\n    }\n\n    // Audit log\n    await logAudit(\"CREATE\", \"products\", docRef.id, productData.createdBy, null, createdProduct);\n\n    // Aktivite log ekle\n    if (productData.createdBy) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(productData.createdBy);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addProductActivity(\n          docRef.id,\n          productData.createdBy,\n          \"created\",\n          `bu ürünü oluşturdu`,\n          { productName: productData.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add product activity error:\", error);\n          }\n        }\n      }\n    }\n\n    return createdProduct;\n  } catch (error) {\n    // Sadece development'ta log göster\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Create product error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Ürünü güncelle\n */\nexport const updateProduct = async (\n  productId: string,\n  updates: Partial<Omit<Product, \"id\" | \"createdAt\" | \"createdBy\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldProduct = await getProductById(productId);\n    \n    await updateDoc(doc(firestore, \"products\", productId), {\n      ...updates,\n      updatedAt: serverTimestamp(),\n    });\n    \n    // Yeni veriyi al\n    const newProduct = await getProductById(productId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"products\", productId, userId, oldProduct, newProduct);\n    }\n\n    // Aktivite log ekle\n    if (userId && oldProduct) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        const changedFields = Object.keys(updates).filter(key => {\n          const oldValue = (oldProduct as Record<string, unknown>)[key];\n          const newValue = (updates as Record<string, unknown>)[key];\n          return oldValue !== newValue;\n        });\n        \n        if (changedFields.length > 0) {\n          await addProductActivity(\n            productId,\n            userId,\n            \"updated\",\n            `bu ürünü güncelledi`,\n            { changedFields },\n            userName,\n            userEmail\n          );\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add product activity error:\", error);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    // Sadece development'ta log göster\n    if (import.meta.env.DEV) {\n      console.error(\"Update product error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Ürünü sil\n */\nexport const deleteProduct = async (productId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldProduct = await getProductById(productId);\n    \n    // Aktivite log ekle (silmeden önce)\n    if (userId && oldProduct) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addProductActivity(\n          productId,\n          userId,\n          \"deleted\",\n          `bu ürünü sildi`,\n          { productName: oldProduct.name },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add product activity error:\", error);\n          }\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, \"products\", productId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"products\", productId, userId, oldProduct, null);\n    }\n  } catch (error) {\n    // Sadece development'ta log göster\n    if (import.meta.env.DEV) {\n      console.error(\"Delete product error:\", error);\n    }\n    throw error;\n  }\n};\n\n// Product Comments and Activities\n\nexport interface ProductComment {\n  id: string;\n  productId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp;\n  updatedAt?: Timestamp | null;\n}\n\nexport interface ProductActivity {\n  id: string;\n  productId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp;\n}\n\n/**\n * Ürün yorumu ekle\n */\nexport const addProductComment = async (\n  productId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<ProductComment> => {\n  try {\n    const commentData: Omit<ProductComment, \"id\"> = {\n      productId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"products\", productId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addProductActivity(productId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Ürünü oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const product = await getProductById(productId);\n      if (product?.createdBy && product.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: product.createdBy,\n          type: \"comment_added\",\n          title: \"Ürününüze Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} \"${product.name}\" ürününüze yorum ekledi: ${content.substring(0, 100)}${content.length > 100 ? \"...\" : \"\"}`,\n          read: false,\n          relatedId: productId,\n          metadata: { commentId: docRef.id, commenterId: userId, commenterName: userName, commenterEmail: userEmail },\n        });\n      }\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.error(\"Send comment notification error:\", error);\n      }\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add product comment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Ürün yorumlarını al\n */\nexport const getProductComments = async (productId: string): Promise<ProductComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"products\", productId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as ProductComment[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get product comments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Ürün aktivite log ekle\n */\nexport const addProductActivity = async (\n  productId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<ProductActivity, \"id\"> = {\n      productId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"products\", productId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add product activity error:\", error);\n    }\n    return \"\";\n  }\n};\n\n/**\n * Ürün aktivite loglarını al\n */\nexport const getProductActivities = async (productId: string): Promise<ProductActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"products\", productId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as ProductActivity[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get product activities error:\", error);\n    }\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\projectService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\recipeService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\reportService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\requestService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\rolePermissionsService.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'subPermissions' is never reassigned. Use 'const' instead.","line":357,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":357,"endColumn":45,"fix":{"range":[10085,10125],"text":"const subPermissions: SubPermissions = {};"}},{"ruleId":"prefer-const","severity":2,"message":"'subPermissions' is never reassigned. Use 'const' instead.","line":458,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":458,"endColumn":45,"fix":{"range":[14336,14376],"text":"const subPermissions: SubPermissions = {};"}},{"ruleId":"prefer-const","severity":2,"message":"'updatedSubPermissions' is never reassigned. Use 'const' instead.","line":601,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":601,"endColumn":48,"fix":{"range":[19975,20060],"text":"const updatedSubPermissions: SubPermissions = { ...(permission.subPermissions || {}) };"}}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import { db } from \"@/lib/firebase\";\nimport {\n  collection,\n  doc,\n  getDocs,\n  getDoc,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  Timestamp,\n  setDoc,\n  writeBatch,\n  onSnapshot,\n  Unsubscribe,\n} from \"firebase/firestore\";\n\nexport interface SubPermissions {\n  [key: string]: boolean;\n}\n\nexport interface RolePermission {\n  id: string;\n  role: string;\n  resource: string;\n  canCreate: boolean;\n  canRead: boolean;\n  canUpdate: boolean;\n  canDelete: boolean;\n  subPermissions?: SubPermissions; // Alt yetkiler\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\nexport interface RoleDefinition {\n  id: string;\n  key: string;\n  label: string;\n  color: string;\n  isSystem?: boolean; // Sistem rolleri silinemez\n}\n\nconst ROLE_PERMISSIONS_COLLECTION = \"role_permissions\";\nconst ROLES_COLLECTION = \"roles\";\n\n// Permission cache configuration\nconst CACHE_TTL = 5 * 60 * 1000; // 5 dakika cache TTL\nconst cacheTimestamps = new Map<string, number>();\n\n// Permission cache for real-time updates\nconst permissionCache = new Map<string, RolePermission | null>();\nconst permissionListeners = new Map<string, Unsubscribe>();\nconst cacheCallbacks = new Set<() => void>();\n\n/**\n * Check if cache entry is expired\n */\nconst isCacheExpired = (cacheKey: string): boolean => {\n  const timestamp = cacheTimestamps.get(cacheKey);\n  if (!timestamp) return true;\n  return Date.now() - timestamp > CACHE_TTL;\n};\n\n/**\n * Update cache timestamp\n */\nconst updateCacheTimestamp = (cacheKey: string): void => {\n  cacheTimestamps.set(cacheKey, Date.now());\n};\n\n/**\n * Clear permission cache (optionally for specific role)\n */\nexport const clearPermissionCache = (role?: string): void => {\n  if (role) {\n    // Clear only specific role's cache\n    for (const key of permissionCache.keys()) {\n      if (key.startsWith(`${role}:`)) {\n        permissionCache.delete(key);\n        cacheTimestamps.delete(key);\n      }\n    }\n  } else {\n    // Clear all cache\n    permissionCache.clear();\n    cacheTimestamps.clear();\n  }\n  // Notify all callbacks\n  cacheCallbacks.forEach(callback => {\n    try {\n      callback();\n    } catch (e) {\n      // Callback hatası diğerlerini etkilemesin\n    }\n  });\n};\n\n/**\n * Force refresh all permissions from Firestore\n */\nexport const forceRefreshPermissions = async (): Promise<void> => {\n  // Clear all cache\n  permissionCache.clear();\n  cacheTimestamps.clear();\n\n  // Unsubscribe all listeners\n  permissionListeners.forEach(unsubscribe => unsubscribe());\n  permissionListeners.clear();\n\n  // Notify callbacks\n  cacheCallbacks.forEach(callback => {\n    try {\n      callback();\n    } catch (e) {\n      // Ignore callback errors\n    }\n  });\n};\n\n/**\n * Subscribe to permission cache changes\n */\nexport const onPermissionCacheChange = (callback: () => void): (() => void) => {\n  cacheCallbacks.add(callback);\n  return () => {\n    cacheCallbacks.delete(callback);\n  };\n};\n\nconst RESOURCES = [\n  \"tasks\",\n  \"users\",\n  \"departments\",\n  \"orders\",\n  \"production_orders\",\n  \"customers\",\n  \"products\",\n  \"projects\",\n  \"audit_logs\",\n  \"role_permissions\",\n  \"raw_materials\",\n  \"warranty\",\n];\n\n// Default System Roles\nconst DEFAULT_ROLES: RoleDefinition[] = [\n  { id: \"super_admin\", key: \"super_admin\", label: \"Süper Yönetici\", color: \"bg-red-500\", isSystem: true },\n  { id: \"team_leader\", key: \"team_leader\", label: \"Ekip Lideri\", color: \"bg-blue-500\", isSystem: true },\n  { id: \"personnel\", key: \"personnel\", label: \"Personel\", color: \"bg-green-500\", isSystem: true },\n];\n\n/**\n * Initialize default roles if they don't exist\n */\nconst initializeDefaultRoles = async (): Promise<void> => {\n  try {\n    // Sadece authenticated kullanıcılar için çalış\n    const { getAuth } = await import(\"firebase/auth\");\n    const { auth } = await import(\"@/lib/firebase\");\n    const currentAuth = auth || getAuth();\n\n    if (!currentAuth?.currentUser) {\n      // Giriş yapmamış kullanıcılar için sessizce çık\n      return;\n    }\n\n    const rolesRef = collection(db, ROLES_COLLECTION);\n    const snapshot = await getDocs(rolesRef);\n\n    if (snapshot.empty) {\n      for (const role of DEFAULT_ROLES) {\n        await setDoc(doc(db, ROLES_COLLECTION, role.key), role);\n      }\n    }\n  } catch (error) {\n    // Permission hatalarını sessizce handle et\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n    if (errorObj?.code !== 'permission-denied' && !errorObj?.message?.includes('permissions')) {\n      if (import.meta.env.DEV) {\n        console.error(\"Error initializing default roles:\", error);\n      }\n    }\n  }\n};\n\n/**\n * Get all roles\n */\nexport const getRoles = async (): Promise<RoleDefinition[]> => {\n  try {\n    // Sadece authenticated kullanıcılar için initializeDefaultRoles çağır\n    const { getAuth } = await import(\"firebase/auth\");\n    const { auth } = await import(\"@/lib/firebase\");\n    const currentAuth = auth || getAuth();\n\n    if (currentAuth?.currentUser) {\n      await initializeDefaultRoles();\n    }\n\n    const rolesRef = collection(db, ROLES_COLLECTION);\n    const snapshot = await getDocs(rolesRef);\n    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() } as RoleDefinition));\n  } catch (error) {\n    // Permission hatalarını sessizce handle et\n    const errorObj = error && typeof error === 'object' ? error as { code?: string; message?: string } : null;\n    if (errorObj?.code !== 'permission-denied' && !errorObj?.message?.includes('permissions')) {\n      if (import.meta.env.DEV) {\n        console.error(\"Error getting roles:\", error);\n      }\n    }\n    return DEFAULT_ROLES;\n  }\n};\n\n/**\n * Add a new role\n */\nexport const addRole = async (role: Omit<RoleDefinition, \"id\" | \"isSystem\">): Promise<void> => {\n  try {\n    const roleKey = role.key.toLowerCase().replace(/\\s+/g, \"_\");\n    const newRole = {\n      ...role,\n      key: roleKey,\n      isSystem: false\n    };\n\n    await setDoc(doc(db, ROLES_COLLECTION, roleKey), newRole);\n\n    // Initialize permissions for the new role\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    for (const resource of RESOURCES) {\n      // Alt yetkileri al (yeni roller için varsayılan olarak boş)\n      const permissionData: Record<string, unknown> = {\n        role: roleKey,\n        resource,\n        canCreate: false,\n        canRead: true, // Default read access\n        canUpdate: false,\n        canDelete: false,\n        createdAt: Timestamp.now(),\n        updatedAt: Timestamp.now(),\n      };\n\n      // undefined değerleri kaldır (Firestore undefined kabul etmez)\n      const cleanPermission = Object.fromEntries(\n        Object.entries(permissionData).filter(([_, value]) => value !== undefined)\n      );\n\n      await addDoc(permissionsRef, cleanPermission);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error adding role:\", error);\n    }\n    throw new Error(error instanceof Error ? error.message : \"Rol eklenemedi\");\n  }\n};\n\n/**\n * Delete a role\n */\nexport const deleteRole = async (roleKey: string): Promise<void> => {\n  try {\n    // Sistem rolleri silinemez\n    const roleDoc = await getDoc(doc(db, ROLES_COLLECTION, roleKey));\n    if (roleDoc.exists() && roleDoc.data().isSystem) {\n      throw new Error(\"Sistem rolleri silinemez\");\n    }\n\n    // Bu role sahip kullanıcıları bul ve rollerini güncelle\n    const usersRef = collection(db, \"users\");\n    const usersQuery = query(usersRef);\n    const usersSnapshot = await getDocs(usersQuery);\n\n    const { writeBatch } = await import(\"firebase/firestore\");\n    let batch = writeBatch(db);\n    let batchCount = 0;\n    const maxBatchSize = 500;\n\n    for (const userDoc of usersSnapshot.docs) {\n      const userData = userDoc.data();\n      const userRoles = userData.role || [];\n\n      // Eğer kullanıcı bu role sahipse, rolü kaldır\n      if (userRoles.includes(roleKey)) {\n        const updatedRoles = userRoles.filter((r: string) => r !== roleKey);\n        // Eğer hiç rol kalmadıysa, varsayılan rol ekle\n        const finalRoles = updatedRoles.length > 0 ? updatedRoles : [\"personnel\"];\n\n        batch.update(userDoc.ref, {\n          role: finalRoles,\n        });\n        batchCount++;\n\n        if (batchCount >= maxBatchSize) {\n          await batch.commit();\n          batchCount = 0;\n          // Yeni batch oluştur\n          batch = writeBatch(db);\n        }\n      }\n    }\n\n    // Kalan batch'i commit et\n    if (batchCount > 0) {\n      await batch.commit();\n    }\n\n    // Delete role definition\n    await deleteDoc(doc(db, ROLES_COLLECTION, roleKey));\n\n    // Delete associated permissions\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    const q = query(permissionsRef, where(\"role\", \"==\", roleKey));\n    const permissionsSnapshot = await getDocs(q);\n\n    for (const docSnap of permissionsSnapshot.docs) {\n      await deleteDoc(doc(db, ROLE_PERMISSIONS_COLLECTION, docSnap.id));\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error deleting role:\", error);\n    }\n    throw new Error(error instanceof Error ? error.message : \"Rol silinemedi\");\n  }\n};\n\n/**\n * Initialize default permissions for all roles and resources\n */\nconst initializeDefaultPermissions = async (): Promise<void> => {\n  try {\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    const snapshot = await getDocs(permissionsRef);\n\n    const roles = await getRoles();\n    const existingPermissions = snapshot.docs.map(doc => doc.data() as RolePermission);\n\n    // Eksik permissions'ları kontrol et ve oluştur\n    const missingPermissions: Omit<RolePermission, \"id\">[] = [];\n\n    for (const roleDef of roles) {\n      const role = roleDef.key;\n      for (const resource of RESOURCES) {\n        // Bu rol ve kaynak için permission var mı kontrol et\n        const exists = existingPermissions.some(\n          (p) => p.role === role && p.resource === resource\n        );\n\n        if (!exists) {\n          // Eksik permission için varsayılan değerler\n          let canCreate = false;\n          let canRead = true;\n          let canUpdate = false;\n          let canDelete = false;\n          let subPermissions: SubPermissions = {};\n\n          // Alt yetkileri al\n          const subPerms = getSubPermissionsForResource(resource);\n          const subPermKeys = Object.keys(subPerms);\n\n          if (role === \"super_admin\") {\n            canCreate = true;\n            canRead = true;\n            canUpdate = true;\n            canDelete = true;\n            // Süper yönetici ve admin için tüm alt yetkileri true yap\n            subPermKeys.forEach(key => {\n              subPermissions[key] = true;\n            });\n          } else if (role === \"team_leader\") {\n            // Ekip lideri için tüm kaynaklarda oluşturma, okuma ve güncelleme yetkisi (role_permissions hariç)\n            canCreate = resource !== \"role_permissions\";\n            canRead = true;\n            canUpdate = resource !== \"role_permissions\";\n            // Ekip lideri için silme yetkisi (role_permissions ve audit_logs hariç)\n            canDelete = resource !== \"role_permissions\" && resource !== \"audit_logs\";\n            // Ekip lideri için tüm alt yetkileri true yap (role_permissions hariç)\n            if (resource !== \"role_permissions\") {\n              subPermKeys.forEach(key => {\n                subPermissions[key] = true;\n              });\n            }\n          } else if (role === \"personnel\") {\n            // Personnel tasks oluşturamaz, sadece production_orders oluşturabilir\n            canCreate = [\"production_orders\"].includes(resource);\n            canRead = true;\n            // Personnel sadece atanan görevlerin durumunu güncelleyebilir (canUpdate kontrolü taskService'de yapılır)\n            canUpdate = [\"tasks\", \"production_orders\"].includes(resource);\n            canDelete = false;\n            // Personel için sınırlı alt yetkiler\n            if (resource === \"tasks\") {\n              // Personnel sadece atanan görevlerde bu yetkilere sahip\n              subPermissions.canAddComment = true;\n              subPermissions.canAddAttachment = true;\n              subPermissions.canChangeStatus = true; // Sadece atanan görevler için\n            } else if (resource === \"production_orders\") {\n              subPermissions.canViewSchedule = true;\n            }\n          }\n\n          const permissionData: Omit<RolePermission, \"id\"> & { subPermissions?: SubPermissions } = {\n            role,\n            resource,\n            canCreate,\n            canRead,\n            canUpdate,\n            canDelete,\n            createdAt: Timestamp.now(),\n            updatedAt: Timestamp.now(),\n          };\n\n          // subPermissions sadece varsa ekle (undefined değerleri Firestore kabul etmez)\n          if (Object.keys(subPermissions).length > 0) {\n            permissionData.subPermissions = subPermissions;\n          }\n\n          missingPermissions.push(permissionData);\n        }\n      }\n    }\n\n    // Eksik permissions'ları oluştur\n    if (missingPermissions.length > 0) {\n      for (const permission of missingPermissions) {\n        // undefined değerleri kaldır (Firestore undefined kabul etmez)\n        const cleanPermission: Record<string, unknown> = {};\n        for (const [key, value] of Object.entries(permission)) {\n          if (value !== undefined) {\n            // Eğer value bir obje ise, içindeki undefined değerleri de temizle\n            if (typeof value === 'object' && value !== null && !(value instanceof Timestamp)) {\n              const cleanValue = Object.fromEntries(\n                Object.entries(value).filter(([_, v]) => v !== undefined)\n              );\n              if (Object.keys(cleanValue).length > 0) {\n                cleanPermission[key] = cleanValue;\n              }\n            } else {\n              cleanPermission[key] = value;\n            }\n          }\n        }\n        await addDoc(permissionsRef, cleanPermission);\n      }\n    }\n\n    // Eğer hiç permission yoksa, tüm roller için oluştur\n    if (snapshot.size === 0 && missingPermissions.length === 0) {\n      const defaultPermissions: Omit<RolePermission, \"id\">[] = [];\n\n      for (const roleDef of roles) {\n        const role = roleDef.key;\n        for (const resource of RESOURCES) {\n          // Alt yetkileri al\n          const subPerms = getSubPermissionsForResource(resource);\n          const subPermKeys = Object.keys(subPerms);\n          let subPermissions: SubPermissions = {};\n\n          // Super Admin and Admin have all permissions\n          if (role === \"super_admin\") {\n            // Süper yönetici ve admin için tüm alt yetkileri true yap\n            subPermKeys.forEach(key => {\n              subPermissions[key] = true;\n            });\n            const permissionData: Omit<RolePermission, \"id\"> & { subPermissions?: SubPermissions } = {\n              role,\n              resource,\n              canCreate: true,\n              canRead: true,\n              canUpdate: true,\n              canDelete: true,\n              createdAt: Timestamp.now(),\n              updatedAt: Timestamp.now(),\n            };\n\n            // subPermissions sadece varsa ekle (undefined değerleri Firestore kabul etmez)\n            if (Object.keys(subPermissions).length > 0) {\n              permissionData.subPermissions = subPermissions;\n            }\n\n            defaultPermissions.push(permissionData);\n          }\n          // Team Leader has most permissions except role_permissions\n          else if (role === \"team_leader\") {\n            // Ekip lideri için tüm alt yetkileri true yap (role_permissions hariç)\n            if (resource !== \"role_permissions\") {\n              subPermKeys.forEach(key => {\n                subPermissions[key] = true;\n              });\n            }\n            const permissionData: Omit<RolePermission, \"id\"> & { subPermissions?: SubPermissions } = {\n              role,\n              resource,\n              canCreate: resource !== \"role_permissions\",\n              canRead: true,\n              canUpdate: resource !== \"role_permissions\",\n              canDelete: resource !== \"role_permissions\" && resource !== \"audit_logs\",\n              createdAt: Timestamp.now(),\n              updatedAt: Timestamp.now(),\n            };\n\n            // subPermissions sadece varsa ekle (undefined değerleri Firestore kabul etmez)\n            if (Object.keys(subPermissions).length > 0) {\n              permissionData.subPermissions = subPermissions;\n            }\n\n            defaultPermissions.push(permissionData);\n          }\n          // Personnel has limited permissions\n          else if (role === \"personnel\") {\n            // Personel için sınırlı alt yetkiler\n            if (resource === \"tasks\") {\n              subPermissions.canEditOwn = true;\n              subPermissions.canDeleteOwn = true;\n              subPermissions.canAddComment = true;\n              subPermissions.canAddAttachment = true;\n            } else if (resource === \"production_orders\") {\n              subPermissions.canViewSchedule = true;\n            }\n            const permissionData: Omit<RolePermission, \"id\"> & { subPermissions?: SubPermissions } = {\n              role,\n              resource,\n              canCreate: [\"tasks\", \"production_orders\"].includes(resource),\n              canRead: true,\n              canUpdate: [\"tasks\", \"production_orders\"].includes(resource),\n              canDelete: false,\n              createdAt: Timestamp.now(),\n              updatedAt: Timestamp.now(),\n            };\n\n            // subPermissions sadece varsa ekle (undefined değerleri Firestore kabul etmez)\n            if (Object.keys(subPermissions).length > 0) {\n              permissionData.subPermissions = subPermissions;\n            }\n\n            defaultPermissions.push(permissionData);\n          }\n          // Other roles (viewer, custom roles) have read-only permissions\n          else {\n            defaultPermissions.push({\n              role,\n              resource,\n              canCreate: false,\n              canRead: true,\n              canUpdate: false,\n              canDelete: false,\n              // subPermissions eklenmiyor (undefined değerleri Firestore kabul etmez)\n              createdAt: Timestamp.now(),\n              updatedAt: Timestamp.now(),\n            });\n          }\n        }\n      }\n\n      // Add all permissions to Firestore\n      for (const permission of defaultPermissions) {\n        // undefined değerleri kaldır (Firestore undefined kabul etmez)\n        const cleanPermission: Record<string, unknown> = {};\n        for (const [key, value] of Object.entries(permission)) {\n          if (value !== undefined) {\n            // Eğer value bir obje ise, içindeki undefined değerleri de temizle\n            if (typeof value === 'object' && value !== null && !(value instanceof Timestamp)) {\n              const cleanValue = Object.fromEntries(\n                Object.entries(value).filter(([_, v]) => v !== undefined)\n              );\n              if (Object.keys(cleanValue).length > 0) {\n                cleanPermission[key] = cleanValue;\n              }\n            } else {\n              cleanPermission[key] = value;\n            }\n          }\n        }\n        await addDoc(permissionsRef, cleanPermission);\n      }\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error initializing default permissions:\", error);\n    }\n  }\n};\n\n/**\n * Update existing permissions to include missing sub-permissions\n * Bu fonksiyon mevcut izinleri kontrol edip eksik alt yetkileri ekler\n */\nexport const updatePermissionsWithSubPermissions = async (): Promise<void> => {\n  try {\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    const snapshot = await getDocs(permissionsRef);\n\n    for (const docSnap of snapshot.docs) {\n      const permission = docSnap.data() as RolePermission;\n      const subPerms = getSubPermissionsForResource(permission.resource);\n      const subPermKeys = Object.keys(subPerms);\n\n      // Eğer alt yetkiler yoksa veya eksikse, ekle\n      let needsUpdate = false;\n      let updatedSubPermissions: SubPermissions = { ...(permission.subPermissions || {}) };\n\n      // Süper yönetici için tüm alt yetkileri true yap\n      if (permission.role === \"super_admin\" && subPermKeys.length > 0) {\n        subPermKeys.forEach(key => {\n          if (updatedSubPermissions[key] !== true) {\n            updatedSubPermissions[key] = true;\n            needsUpdate = true;\n          }\n        });\n      }\n      // Ekip lideri için tüm alt yetkileri true yap (role_permissions hariç)\n      else if (permission.role === \"team_leader\" && permission.resource !== \"role_permissions\") {\n        if (subPermKeys.length > 0) {\n          subPermKeys.forEach(key => {\n            if (updatedSubPermissions[key] !== true) {\n              updatedSubPermissions[key] = true;\n              needsUpdate = true;\n            }\n          });\n        }\n\n        // Ekip lideri için canCreate, canUpdate ve canDelete yetkilerini de kontrol et\n        if (permission.canCreate !== true) {\n          needsUpdate = true;\n        }\n        if (permission.canUpdate !== true) {\n          needsUpdate = true;\n        }\n        // canDelete: role_permissions ve audit_logs hariç tüm kaynaklar için true\n        if (permission.resource !== \"audit_logs\" && permission.canDelete !== true) {\n          needsUpdate = true;\n        }\n      }\n      // Personel için sınırlı alt yetkiler\n      else if (permission.role === \"personnel\") {\n        if (permission.resource === \"tasks\") {\n          const taskSubPerms = [\"canEditOwn\", \"canDeleteOwn\", \"canAddComment\", \"canAddAttachment\"];\n          taskSubPerms.forEach(key => {\n            if (updatedSubPermissions[key] !== true) {\n              updatedSubPermissions[key] = true;\n              needsUpdate = true;\n            }\n          });\n        } else if (permission.resource === \"production_orders\") {\n          if (updatedSubPermissions.canViewSchedule !== true) {\n            updatedSubPermissions.canViewSchedule = true;\n            needsUpdate = true;\n          }\n        }\n      }\n\n      // Güncelleme gerekiyorsa yap\n      if (needsUpdate) {\n        const updateData: Partial<RolePermission> = {\n          updatedAt: Timestamp.now(),\n        };\n\n        // Ekip lideri için ana yetkileri de güncelle\n        if (permission.role === \"team_leader\" && permission.resource !== \"role_permissions\") {\n          if (permission.canCreate !== true) {\n            updateData.canCreate = true;\n          }\n          if (permission.canUpdate !== true) {\n            updateData.canUpdate = true;\n          }\n          // canDelete: role_permissions ve audit_logs hariç tüm kaynaklar için true\n          if (permission.resource !== \"audit_logs\" && permission.canDelete !== true) {\n            updateData.canDelete = true;\n          }\n        }\n\n        // subPermissions sadece varsa ekle (undefined değerleri Firestore kabul etmez)\n        if (Object.keys(updatedSubPermissions).length > 0) {\n          updateData.subPermissions = updatedSubPermissions;\n        }\n\n        // undefined değerleri kaldır\n        const cleanUpdateData = Object.fromEntries(\n          Object.entries(updateData).filter(([_, value]) => value !== undefined)\n        );\n\n        await updateDoc(doc(db, ROLE_PERMISSIONS_COLLECTION, docSnap.id), cleanUpdateData);\n      }\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error updating permissions with sub-permissions:\", error);\n    }\n  }\n};\n\n/**\n * Get all role permissions\n */\nexport const getRolePermissions = async (): Promise<RolePermission[]> => {\n  try {\n    // Initialize default roles first\n    await initializeDefaultRoles();\n\n    // Initialize default permissions if needed\n    await initializeDefaultPermissions();\n\n    // Mevcut izinleri alt yetkilerle güncelle\n    await updatePermissionsWithSubPermissions();\n\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    const snapshot = await getDocs(permissionsRef);\n\n    const permissions = snapshot.docs.map((docSnap) => ({\n      id: docSnap.id,\n      ...docSnap.data(),\n    })) as RolePermission[];\n\n    // Pre-populate cache with all permissions for faster access\n    permissions.forEach(permission => {\n      const cacheKey = `${permission.role}:${permission.resource}`;\n      if (!permissionCache.has(cacheKey) || isCacheExpired(cacheKey)) {\n        permissionCache.set(cacheKey, permission);\n        updateCacheTimestamp(cacheKey);\n      }\n    });\n\n    return permissions;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting role permissions:\", error);\n    }\n    throw new Error(error instanceof Error ? error.message : \"Rol yetkileri yüklenemedi\");\n  }\n};\n\n/**\n * Get permission for a specific role and resource\n * Uses cache and real-time listener for dynamic updates\n * IMPORTANT: Always returns the latest value from cache (updated by real-time listener)\n */\nexport const getPermission = async (\n  role: string,\n  resource: string,\n  useCache: boolean = true\n): Promise<RolePermission | null> => {\n  const cacheKey = `${role}:${resource}`;\n\n  try {\n    const permissionsRef = collection(db, ROLE_PERMISSIONS_COLLECTION);\n    const q = query(\n      permissionsRef,\n      where(\"role\", \"==\", role),\n      where(\"resource\", \"==\", resource)\n    );\n\n    // If cache is disabled, get directly from Firestore\n    if (!useCache) {\n      const snapshot = await getDocs(q);\n      if (snapshot.empty) {\n        return null;\n      }\n      const docSnap = snapshot.docs[0];\n      return {\n        id: docSnap.id,\n        ...docSnap.data(),\n      } as RolePermission;\n    }\n\n    // If cache already has value, return it immediately if not expired\n    if (permissionCache.has(cacheKey)) {\n      if (!isCacheExpired(cacheKey)) {\n        return permissionCache.get(cacheKey) || null;\n      }\n      // If expired, assume listener will refresh it or we just update timestamp if listener is active\n      // Since we have real-time listener, treat as fresh but update timestamp\n      updateCacheTimestamp(cacheKey);\n      return permissionCache.get(cacheKey) || null;\n    }\n\n    // Set up real-time listener if not already set\n    if (!permissionListeners.has(cacheKey)) {\n      // First, get initial value synchronously to avoid race condition\n      const initialSnapshot = await getDocs(q);\n      let initialPermission: RolePermission | null = null;\n\n      if (!initialSnapshot.empty) {\n        const docSnap = initialSnapshot.docs[0];\n        initialPermission = {\n          id: docSnap.id,\n          ...docSnap.data(),\n        } as RolePermission;\n      }\n\n      // Cache the initial value immediately\n      permissionCache.set(cacheKey, initialPermission);\n      updateCacheTimestamp(cacheKey);\n\n      // Then set up real-time listener for future updates\n      const unsubscribe = onSnapshot(q, (snapshot) => {\n        if (snapshot.empty) {\n          permissionCache.set(cacheKey, null);\n        } else {\n          const docSnap = snapshot.docs[0];\n          const permission = {\n            id: docSnap.id,\n            ...docSnap.data(),\n          } as RolePermission;\n          permissionCache.set(cacheKey, permission);\n        }\n        updateCacheTimestamp(cacheKey);\n        // Notify all callbacks about cache change\n        cacheCallbacks.forEach(callback => callback());\n      }, (error) => {\n        if (import.meta.env.DEV) {\n          console.error(`Error listening to permission ${cacheKey}:`, error);\n        }\n      });\n\n      permissionListeners.set(cacheKey, unsubscribe);\n\n      // Return the initial value we just cached\n      return initialPermission;\n    }\n\n    // Listener already exists, return cached value (should be available now)\n    updateCacheTimestamp(cacheKey);\n    return permissionCache.get(cacheKey) || null;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting permission:\", error);\n    }\n    throw new Error(error instanceof Error ? error.message : \"Yetki yüklenemedi\");\n  }\n};\n\n/**\n * Cleanup all permission listeners\n */\nexport const cleanupPermissionListeners = (): void => {\n  permissionListeners.forEach(unsubscribe => unsubscribe());\n  permissionListeners.clear();\n  permissionCache.clear();\n  cacheCallbacks.clear();\n};\n\n/**\n * Get sub-permissions for a resource\n */\nexport const getSubPermissionsForResource = (resource: string): Record<string, string> => {\n  const subPermissions: Record<string, Record<string, string>> = {\n    tasks: {\n      canAssign: \"Görev atama\",\n      canChangeStatus: \"Durum değiştirme\",\n      canAddComment: \"Yorum ekleme\",\n      canAddAttachment: \"Dosya ekleme\",\n      canViewAll: \"Tüm görevleri görme\",\n      canEditOwn: \"Kendi görevlerini düzenleme\",\n      canDeleteOwn: \"Kendi görevlerini silme\",\n      canApprove: \"Görev onaylama\",\n      canAddChecklist: \"Checklist ekleme\",\n      canEditChecklist: \"Checklist düzenleme/silme\",\n      canViewPrivate: \"Gizli görevleri görme\",\n    },\n    users: {\n      canChangeRole: \"Rol değiştirme\",\n      canViewSensitiveData: \"Hassas verileri görme\",\n      canViewAuditLogs: \"Denetim kayıtlarını görme\",\n    },\n    departments: {\n      canAssignMembers: \"Üye atama\",\n      canChangeLeader: \"Lider değiştirme\",\n      canViewAll: \"Tüm departmanları görme\",\n      canApproveTeamRequest: \"Ekip taleplerini onaylama\",\n      canViewTeamManagement: \"Ekip yönetimi menüsünü görme\",\n    },\n    orders: {\n      canApprove: \"Onaylama\",\n      canCancel: \"İptal etme\",\n      canExport: \"Dışa aktarma\",\n      canViewFinancials: \"Finansal bilgileri görme\",\n      canEditPrice: \"Fiyat düzenleme\",\n    },\n    production_orders: {\n      canStartProduction: \"Üretimi başlatma\",\n      canCompleteProduction: \"Üretimi tamamlama\",\n      canViewSchedule: \"Üretim planını görme\",\n      canEditSchedule: \"Üretim planını düzenleme\",\n    },\n    customers: {\n      canViewFinancials: \"Finansal bilgileri görme\",\n      canEditFinancials: \"Finansal bilgileri düzenleme\",\n      canExport: \"Dışa aktarma\",\n      canViewHistory: \"Geçmiş kayıtları görme\",\n    },\n    products: {\n      canEditPrice: \"Fiyat düzenleme\",\n      canEditStock: \"Stok düzenleme\",\n      canViewCost: \"Maliyet görme\",\n      canEditCost: \"Maliyet düzenleme\",\n      canExport: \"Dışa aktarma\",\n    },\n    projects: {\n      canAssignMembers: \"Üye atama\",\n      canChangeStatus: \"Durum değiştirme\",\n      canViewAll: \"Tüm projeleri görme\",\n      canEditBudget: \"Bütçe düzenleme\",\n      canViewPrivate: \"Gizli projeleri görme\",\n    },\n    audit_logs: {\n      canViewAll: \"Tüm kayıtları görme\",\n      canExport: \"Dışa aktarma\",\n      canDelete: \"Kayıt silme\",\n    },\n    role_permissions: {\n      canCreateRoles: \"Rol oluşturma\",\n      canDeleteRoles: \"Rol silme\",\n      canEditSystemRoles: \"Sistem rollerini düzenleme\",\n      canViewAdminPanel: \"Admin paneli menüsünü görme\",\n    },\n    raw_materials: {\n      canEditStock: \"Stok düzenleme\",\n      canViewCost: \"Maliyet görme\",\n      canEditCost: \"Maliyet düzenleme\",\n      canExport: \"Dışa aktarma\",\n      canViewTransactions: \"İşlem geçmişini görme\",\n      canCreateTransactions: \"Stok işlemi oluşturma\",\n    },\n    warranty: {\n      canApprove: \"Garanti onaylama\",\n      canReject: \"Garanti reddetme\",\n      canViewFinancials: \"Finansal bilgileri görme\",\n      canExport: \"Dışa aktarma\",\n      canViewHistory: \"Geçmiş kayıtları görme\",\n    },\n  };\n\n  return subPermissions[resource] || {};\n};\n\n/**\n * Update a permission\n */\nexport const updatePermission = async (\n  permissionId: string,\n  updates: Partial<Omit<RolePermission, \"id\" | \"createdAt\" | \"updatedAt\">>\n): Promise<void> => {\n  try {\n    const permissionRef = doc(db, ROLE_PERMISSIONS_COLLECTION, permissionId);\n\n    // Get current permission to find cache key\n    const currentPermission = await getDoc(permissionRef);\n    if (currentPermission.exists()) {\n      const data = currentPermission.data() as RolePermission;\n      const cacheKey = `${data.role}:${data.resource}`;\n      // Invalidate cache for this permission - listener will update it\n      permissionCache.delete(cacheKey);\n    }\n\n    // undefined değerleri kaldır (Firestore undefined kabul etmez)\n    const cleanUpdates: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(updates)) {\n      if (value !== undefined) {\n        // Eğer value bir obje ise (subPermissions gibi), içindeki undefined değerleri de temizle\n        if (typeof value === 'object' && value !== null && !(value instanceof Timestamp)) {\n          const cleanValue = Object.fromEntries(\n            Object.entries(value).filter(([_, v]) => v !== undefined)\n          );\n          if (Object.keys(cleanValue).length > 0) {\n            cleanUpdates[key] = cleanValue;\n          }\n        } else {\n          cleanUpdates[key] = value;\n        }\n      }\n    }\n\n    await updateDoc(permissionRef, {\n      ...cleanUpdates,\n      updatedAt: Timestamp.now(),\n    });\n\n    // Cache will be updated by real-time listener automatically\n    // No need to manually update cache\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error updating permission:\", error);\n    }\n    throw new Error(error instanceof Error ? error.message : \"Yetki güncellenemedi\");\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\settingsService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\storageService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\taskService.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'q' is never reassigned. Use 'const' instead.","line":364,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":364,"endColumn":10,"fix":{"range":[13535,13556],"text":"const q = buildQuery();"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":532,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":532,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19856,19859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19856,19859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":533,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":533,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19899,19902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19899,19902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":722,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":722,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[26617,26620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[26617,26620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":897,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":897,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33221,33224],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33221,33224],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":908,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":908,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[33646,33649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[33646,33649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2019,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2019,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[75391,75394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[75391,75394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2122,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2122,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[78267,78270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[78267,78270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2518,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2518,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[90950,90953],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[90950,90953],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2524,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2524,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[91258,91261],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[91258,91261],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2849,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2849,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[104234,104237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[104234,104237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Firebase Task Service\n * Görev yönetimi işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  limit,\n  serverTimestamp,\n  Timestamp,\n  writeBatch,\n  onSnapshot,\n  Unsubscribe,\n  QueryConstraint,\n  FieldValue,\n} from \"firebase/firestore\";\nimport { firestore, auth } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\nimport { handlePermissionError, isPermissionError } from \"@/utils/errorLogger\";\nimport { createNotification, updateNotification } from \"./notificationService\";\nimport { getAllUsers, getUserProfile, UserProfile } from \"./authService\";\nimport { getDepartments } from \"./departmentService\";\nimport { getProjectById } from \"./projectService\";\n\nexport interface TaskAttachment {\n  id: string;\n  name: string;\n  url: string;\n  size: number;\n  type: string;\n  attachmentType?: \"file\" | \"drive_link\"; // Dosya tipi\n  driveLink?: string; // Google Drive linki\n  storageProvider?: \"firebase\" | \"google_drive\";\n  driveFileId?: string;\n  uploadedBy: string;\n  uploadedAt: Timestamp;\n}\n\nexport interface StatusHistoryEntry {\n  status: \"pending\" | \"in_progress\" | \"completed\" | \"cancelled\";\n  changedAt: Timestamp;\n  changedBy: string;\n}\n\nexport interface Task {\n  id: string;\n  title: string;\n  description?: string | null;\n  status: \"pending\" | \"in_progress\" | \"completed\" | \"cancelled\";\n  priority: 1 | 2 | 3 | 4 | 5; // 1: low, 5: critical (eski sistemle uyumlu)\n  dueDate?: Timestamp | null;\n  projectId?: string | null; // Proje ID'si\n  isPrivate?: boolean; // Gizli görev mi? (Sadece atananlar ve oluşturan görebilir)\n  productionOrderId?: string | null;\n  productionProcessId?: string | null;\n  labels?: string[] | null;\n  attachments?: TaskAttachment[] | null;\n  assignedUsers?: string[] | null; // Atanan kullanıcı ID'leri (Firestore rules için)\n  isInPool?: boolean; // Görev havuzunda mı?\n  poolRequests?: string[]; // Görev havuzuna eklenmek isteyen kullanıcılar\n  approvalStatus?: \"pending\" | \"approved\" | \"rejected\"; // Onay durumu\n  approvalRequestedBy?: string; // Onay isteyen\n  approvedBy?: string; // Onaylayan\n  approvedAt?: Timestamp; // Onay tarihi\n  rejectedBy?: string; // Reddeden\n  rejectedAt?: Timestamp; // Reddetme tarihi\n  rejectionReason?: string | null; // Reddetme nedeni\n  isArchived?: boolean; // Arşivlendi mi?\n  onlyInMyTasks?: boolean; // Sadece \"Benim Görevlerim\" sayfasında görünsün mü?\n  statusHistory?: StatusHistoryEntry[]; // Aşama geçmişi\n  statusUpdatedBy?: string; // Durum değiştiren kullanıcı\n  statusUpdatedAt?: Timestamp | FieldValue; // Durum değişiklik tarihi\n  updatedBy?: string; // Son güncelleyen kullanıcı (her türlü güncelleme için)\n  createdBy: string;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\nexport interface TaskAssignment {\n  id: string;\n  taskId: string;\n  assignedTo: string;\n  assignedBy: string;\n  status: \"pending\" | \"accepted\" | \"rejected\" | \"completed\";\n  rejectionReason?: string | null;\n  // Red onay/red sistemi\n  rejectionApprovedBy?: string | null; // Reddi onaylayan (görevi veren)\n  rejectionApprovedAt?: Timestamp | null; // Red onay tarihi\n  rejectionRejectedBy?: string | null; // Reddi reddeden (görevi veren)\n  rejectionRejectedAt?: Timestamp | null; // Red red tarihi\n  rejectionRejectionReason?: string | null; // Reddi reddetme nedeni (görevi veren)\n  notes?: string | null;\n  assignedAt: Timestamp;\n  acceptedAt?: Timestamp | null;\n  completedAt?: Timestamp | null;\n}\n\nexport interface ChecklistItem {\n  id: string;\n  text: string;\n  completed: boolean;\n  createdAt: Timestamp;\n  completedAt?: Timestamp | null;\n}\n\nexport interface Checklist {\n  id: string;\n  taskId: string;\n  title: string;\n  items: ChecklistItem[];\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\n/**\n * Tüm görevleri listele\n * Not: assignedTo filtresi için tüm task'ları alıp assignments'ları kontrol eder\n */\nexport const getTasks = async (filters?: {\n  assignedTo?: string;\n  createdBy?: string;\n  status?: string;\n  projectId?: string;\n  productionOrderId?: string;\n  approvalStatus?: \"pending\" | \"approved\" | \"rejected\";\n  limit?: number; // Pagination için limit desteği\n}): Promise<Task[]> => {\n  try {\n    const tasksRef = collection(firestore, \"tasks\");\n    const buildQuery = (options?: { skipOrder?: boolean }) => {\n      const constraints: QueryConstraint[] = [];\n      if (!options?.skipOrder) {\n        constraints.push(orderBy(\"createdAt\", \"desc\"));\n      }\n      if (filters?.createdBy) {\n        constraints.push(where(\"createdBy\", \"==\", filters.createdBy));\n      }\n      if (filters?.status) {\n        constraints.push(where(\"status\", \"==\", filters.status));\n      }\n      if (filters?.projectId) {\n        constraints.push(where(\"projectId\", \"==\", filters.projectId));\n      }\n      if (filters?.productionOrderId) {\n        constraints.push(where(\"productionOrderId\", \"==\", filters.productionOrderId));\n      }\n      if (filters?.approvalStatus) {\n        constraints.push(where(\"approvalStatus\", \"==\", filters.approvalStatus));\n      }\n      // Performans için limit ekle (varsayılan 100, maksimum 500)\n      const taskLimit = filters?.limit ? Math.min(filters.limit, 500) : 100;\n      constraints.push(limit(taskLimit));\n      return constraints.length ? query(tasksRef, ...constraints) : query(tasksRef, limit(taskLimit));\n    };\n\n    let snapshot;\n    try {\n      snapshot = await getDocs(buildQuery());\n    } catch (error: unknown) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      const requiresIndex = typeof errorMessage === \"string\" && errorMessage.includes(\"requires an index\");\n\n      if (requiresIndex) {\n        if (import.meta.env.DEV) {\n          console.warn(\n            \"⚠️ Firestore index gerekiyor, sıralama olmadan görevler getiriliyor. Index linki:\",\n            errorMessage.match(/https:\\/\\/[^\\s]+/)?.[0] || \"–\"\n          );\n        }\n        snapshot = await getDocs(buildQuery({ skipOrder: true }));\n      } else {\n        throw error;\n      }\n    }\n\n    let tasks = snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as Task[];\n\n    if (filters?.projectId) {\n      // KRİTİK: Sadece bu projeye ait görevleri göster\n      // projectId null, undefined veya farklı bir değer ise filtrelenmeli\n      tasks = tasks\n        .filter((task) => {\n          // projectId kesin olarak eşleşmeli, null veya undefined olmamalı\n          return task.projectId === filters.projectId && task.projectId !== null && task.projectId !== undefined;\n        })\n        .sort((a, b) => {\n          const aTime = a.createdAt instanceof Timestamp ? a.createdAt.toMillis() : 0;\n          const bTime = b.createdAt instanceof Timestamp ? b.createdAt.toMillis() : 0;\n          return bTime - aTime;\n        });\n    }\n\n    // assignedTo filtresi varsa, assignments'ları kontrol et\n    if (filters?.assignedTo) {\n      const tasksWithAssignments = await Promise.all(\n        tasks.map(async (task) => {\n          // Gizli görev kontrolü\n          if (task.isPrivate) {\n            // Eğer task oluşturan kişiyse görebilir\n            if (task.createdBy === filters.assignedTo) return task;\n            \n            // Eğer atanan kişiyse görebilir\n            const assignments = await getTaskAssignments(task.id);\n            const hasAssignment = assignments.some(\n              (a) => a.assignedTo === filters.assignedTo && a.status !== \"rejected\"\n            );\n            return hasAssignment ? task : null;\n          }\n          \n          // Normal görevler için assignment kontrolü\n          const assignments = await getTaskAssignments(task.id);\n          const hasAssignment = assignments.some(\n            (a) => a.assignedTo === filters.assignedTo && a.status !== \"rejected\"\n          );\n          return hasAssignment ? task : null;\n        })\n      );\n      tasks = tasksWithAssignments.filter((t) => t !== null) as Task[];\n    } else {\n      // Eğer assignedTo filtresi yoksa (genel liste), gizli görevleri ve onlyInMyTasks görevlerini filtrele\n      // Bu durumda auth.currentUser kullanılmalı ama parametre olarak gelmiyor\n      // Güvenlik kuralları zaten Firestore tarafında olmalı ama client-side filtreleme de yapalım\n      const currentUserId = auth?.currentUser?.uid;\n      if (currentUserId) {\n         // Personnel kullanıcıları için özel kontrol\n         let isPersonnel = false;\n         try {\n           const userProfile = await getUserProfile(currentUserId);\n           if (userProfile?.role) {\n             isPersonnel = userProfile.role.includes(\"personnel\") && \n                          !userProfile.role.includes(\"super_admin\") && \n                          !userProfile.role.includes(\"main_admin\") &&\n                          !userProfile.role.includes(\"team_leader\");\n           }\n         } catch (error: unknown) {\n           if (import.meta.env.DEV) {\n             console.error(\"Error checking user role:\", error);\n           }\n         }\n\n         tasks = await Promise.all(tasks.map(async (task) => {\n           // Personnel kullanıcıları sadece atanan görevleri görebilir\n           if (isPersonnel) {\n             // Gizli olmayan görevleri görebilir (ama sadece atananlar)\n             if (!task.isPrivate) {\n               // Gizli olmayan görevler için assignment kontrolü yap\n               const assignments = await getTaskAssignments(task.id);\n               const isAssigned = assignments.some(a => a.assignedTo === currentUserId && a.status !== \"rejected\");\n               // assignedUsers array'inde de kontrol et\n               const isInAssignedUsers = Array.isArray(task.assignedUsers) && task.assignedUsers.includes(currentUserId);\n               return (isAssigned || isInAssignedUsers) ? task : null;\n             } else {\n               // Gizli görevler için: sadece atananlar görebilir\n               const assignments = await getTaskAssignments(task.id);\n               const isAssigned = assignments.some(a => a.assignedTo === currentUserId && a.status !== \"rejected\");\n               const isInAssignedUsers = Array.isArray(task.assignedUsers) && task.assignedUsers.includes(currentUserId);\n               return (isAssigned || isInAssignedUsers) ? task : null;\n             }\n           }\n\n           // Diğer kullanıcılar için normal filtreleme\n           // onlyInMyTasks görevleri sadece oluşturan görebilir, diğer listelerde görünmez\n           if (task.onlyInMyTasks) {\n             return task.createdBy === currentUserId ? task : null;\n           }\n           \n           // Gizli görevler için canViewPrivateTask kontrolü\n           if (task.isPrivate) {\n             const { getUserProfile } = await import(\"./authService\");\n             const userProfile = await getUserProfile(currentUserId);\n             if (userProfile) {\n               const { canViewPrivateTask } = await import(\"@/utils/permissions\");\n               const assignments = await getTaskAssignments(task.id);\n               const assignedUserIds = assignments\n                 .filter((a) => a.status === \"accepted\" || a.status === \"pending\")\n                 .map((a) => a.assignedTo);\n               const canView = await canViewPrivateTask(task, userProfile, assignedUserIds);\n               return canView ? task : null;\n             }\n             return null;\n           }\n           \n           return task;\n         })).then(results => results.filter(t => t !== null) as Task[]);\n      } else {\n        // Kullanıcı yoksa onlyInMyTasks görevlerini filtrele\n        tasks = tasks.filter(task => !task.onlyInMyTasks);\n      }\n    }\n\n    return tasks;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get tasks error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"read\",\n        collection: \"tasks\",\n        userId: auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Görevleri gerçek zamanlı olarak dinle\n * @param filters Görev filtreleri\n * @param callback Görevler değiştiğinde çağrılacak callback\n * @returns Unsubscribe fonksiyonu\n */\nexport const subscribeToTasks = (\n  filters: {\n    assignedTo?: string;\n    createdBy?: string;\n    status?: string;\n    projectId?: string;\n    productionOrderId?: string;\n    approvalStatus?: \"pending\" | \"approved\" | \"rejected\";\n  } = {},\n  callback: (tasks: Task[]) => void\n): Unsubscribe => {\n  try {\n    const tasksRef = collection(firestore, \"tasks\");\n    const buildQuery = (options?: { skipOrder?: boolean }) => {\n      const constraints: QueryConstraint[] = [];\n      if (!options?.skipOrder) {\n        constraints.push(orderBy(\"createdAt\", \"desc\"));\n      }\n      if (filters?.createdBy) {\n        constraints.push(where(\"createdBy\", \"==\", filters.createdBy));\n      }\n      if (filters?.status) {\n        constraints.push(where(\"status\", \"==\", filters.status));\n      }\n      if (filters?.projectId) {\n        constraints.push(where(\"projectId\", \"==\", filters.projectId));\n      }\n      if (filters?.productionOrderId) {\n        constraints.push(where(\"productionOrderId\", \"==\", filters.productionOrderId));\n      }\n      if (filters?.approvalStatus) {\n        constraints.push(where(\"approvalStatus\", \"==\", filters.approvalStatus));\n      }\n      // Performans için limit ekle (varsayılan 100, maksimum 500)\n      const taskLimit = filters?.limit ? Math.min(filters.limit, 500) : 100;\n      constraints.push(limit(taskLimit));\n      return constraints.length ? query(tasksRef, ...constraints) : query(tasksRef, limit(taskLimit));\n    };\n\n    let q = buildQuery();\n    \n    // onSnapshot ile gerçek zamanlı dinleme\n    const unsubscribe = onSnapshot(\n      q,\n      async (snapshot) => {\n        try {\n          let tasks = snapshot.docs.map((doc) => ({\n            id: doc.id,\n            ...doc.data(),\n          })) as Task[];\n\n          // projectId filtresi zaten server-side'da uygulanıyor, client-side filtreleme gereksiz\n\n          // assignedTo filtresi varsa, assignments'ları kontrol et\n          if (filters?.assignedTo) {\n            const tasksWithAssignments = await Promise.all(\n              tasks.map(async (task) => {\n                // Gizli görev kontrolü\n                if (task.isPrivate) {\n                  if (task.createdBy === filters.assignedTo) return task;\n                  \n                  const assignments = await getTaskAssignments(task.id);\n                  const hasAssignment = assignments.some(\n                    (a) => a.assignedTo === filters.assignedTo && a.status !== \"rejected\"\n                  );\n                  return hasAssignment ? task : null;\n                }\n                \n                // Normal görevler için assignment kontrolü\n                const assignments = await getTaskAssignments(task.id);\n                const hasAssignment = assignments.some(\n                  (a) => a.assignedTo === filters.assignedTo && a.status !== \"rejected\"\n                );\n                return hasAssignment ? task : null;\n              })\n            );\n            tasks = tasksWithAssignments.filter((t) => t !== null) as Task[];\n          } else {\n            // assignedTo filtresi yoksa, gizli görevleri ve onlyInMyTasks görevlerini filtrele\n            const currentUserId = auth?.currentUser?.uid;\n            if (currentUserId) {\n              tasks = await Promise.all(tasks.map(async (task) => {\n                // onlyInMyTasks görevleri sadece oluşturan görebilir\n                if (task.onlyInMyTasks) {\n                  return task.createdBy === currentUserId ? task : null;\n                }\n                \n                if (!task.isPrivate) return task;\n                \n                if (task.createdBy === currentUserId) return task;\n                \n                const assignments = await getTaskAssignments(task.id);\n                const isAssigned = assignments.some(a => a.assignedTo === currentUserId);\n                \n                return isAssigned ? task : null;\n              })).then(results => results.filter(t => t !== null) as Task[]);\n            } else {\n              // Kullanıcı yoksa onlyInMyTasks görevlerini filtrele\n              tasks = tasks.filter(task => !task.onlyInMyTasks);\n            }\n          }\n\n          callback(tasks);\n        } catch (error: unknown) {\n          if (import.meta.env.DEV) {\n            console.error(\"Subscribe to tasks error:\", error);\n          }\n          // Hata durumunda boş array gönder\n          callback([]);\n        }\n      },\n      (error) => {\n        // 404 ve network hatalarını sessizce handle et (Firestore otomatik yeniden bağlanacak)\n        // Production'da da sessizce handle et - bu normal Firestore long-polling davranışı\n        if (error?.code === 'unavailable' || \n            error?.code === 'not-found' ||\n            error?.message?.includes('404') || \n            error?.message?.includes('network') ||\n            error?.message?.includes('transport errored')) {\n          // Sessizce handle et - Firestore otomatik olarak yeniden bağlanacak\n          // Production'da console'a yazma (performans ve gürültü azaltma)\n          callback([]);\n          return;\n        }\n        \n        // Sadece gerçek hataları logla\n        if (import.meta.env.DEV) {\n          console.error(\"Tasks snapshot error:\", error);\n        }\n        // Hata durumunda boş array gönder (uygulama çökmesin)\n        callback([]);\n      }\n    );\n\n    return unsubscribe;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Subscribe to tasks setup error:\", error);\n    }\n    // Hata durumunda boş unsubscribe fonksiyonu döndür\n    return () => {};\n  }\n};\n\n/**\n * Görev detayını al\n */\nexport const getTaskById = async (taskId: string): Promise<Task | null> => {\n  try {\n    const taskDoc = await getDoc(doc(firestore, \"tasks\", taskId));\n    \n    if (!taskDoc.exists()) {\n      return null;\n    }\n\n    return {\n      id: taskDoc.id,\n      ...taskDoc.data(),\n    } as Task;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get task by id error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"read\",\n        collection: \"tasks\",\n        documentId: taskId,\n        userId: auth?.currentUser?.uid,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni görev oluştur\n */\nexport const createTask = async (taskData: Omit<Task, \"id\" | \"createdAt\" | \"updatedAt\">): Promise<Task> => {\n  try {\n    // Projeye görev ekleme yetkisi kontrolü\n    if (taskData.projectId) {\n      const { getProjectById } = await import(\"@/services/firebase/projectService\");\n      const { getUserProfile } = await import(\"@/services/firebase/authService\");\n      const { canCreateTask, canEditProject } = await import(\"@/utils/permissions\");\n      \n      const project = await getProjectById(taskData.projectId);\n      if (project) {\n        const userProfile = await getUserProfile(taskData.createdBy);\n        if (userProfile) {\n          // Görev oluşturma yetkisi kontrolü\n          const canCreate = await canCreateTask(userProfile, []);\n          if (!canCreate) {\n            throw new Error(\"Görev oluşturma yetkiniz yok. Sadece yöneticiler ve ekip liderleri görev oluşturabilir.\");\n          }\n          \n          // Proje sahibi kontrolü - ekip lideri veya admin değilse, sadece proje sahibi görev ekleyebilir\n          const canEdit = await canEditProject(project, userProfile);\n          if (!canEdit && project.createdBy !== taskData.createdBy) {\n            throw new Error(\"Bu projeye görev ekleme yetkiniz yok. Sadece proje sahibi, yöneticiler veya ekip liderleri görev ekleyebilir.\");\n          }\n        }\n      }\n    }\n    \n    const taskDoc: Partial<Task> & { createdAt: FieldValue | Timestamp; updatedAt: FieldValue | Timestamp } = {\n      ...taskData,\n      createdAt: serverTimestamp() as any,\n      updatedAt: serverTimestamp() as any,\n    };\n    \n    // dueDate'i Timestamp'e çevir\n    if (taskData.dueDate !== undefined && taskData.dueDate !== null) {\n      if (taskData.dueDate instanceof Date) {\n        taskDoc.dueDate = Timestamp.fromDate(taskData.dueDate);\n      } else if (typeof taskData.dueDate === 'string') {\n        taskDoc.dueDate = Timestamp.fromDate(new Date(taskData.dueDate));\n      }\n    } else {\n      taskDoc.dueDate = null;\n    }\n    \n    const docRef = await addDoc(collection(firestore, \"tasks\"), taskDoc);\n\n    const createdTask = await getTaskById(docRef.id);\n    if (!createdTask) {\n      throw new Error(\"Görev oluşturulamadı\");\n    }\n\n    // Audit log\n    await logAudit(\"CREATE\", \"tasks\", docRef.id, taskData.createdBy, null, createdTask);\n\n    // Aktivite log ekle\n    if (taskData.createdBy) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(taskData.createdBy);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addTaskActivity(\n          docRef.id,\n          taskData.createdBy,\n          \"created\",\n          `bu görevi oluşturdu`,\n          { taskTitle: createdTask.title },\n          userName,\n          userEmail\n        );\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add task activity error:\", error);\n        }\n      }\n    }\n\n    // Görev oluşturulduğunda ekip liderlerine bildirim gönder\n    try {\n      const teamLeaders = await getTaskTeamLeaders(createdTask);\n      const { createNotification } = await import(\"@/services/firebase/notificationService\");\n      const { getUserProfile } = await import(\"@/services/firebase/authService\");\n      const creatorProfile = await getUserProfile(taskData.createdBy);\n      const creatorName = creatorProfile?.fullName || creatorProfile?.displayName || creatorProfile?.email || \"Bir kullanıcı\";\n      \n      await Promise.all(\n        teamLeaders.map(async (leaderId) => {\n          try {\n            // Görevi oluşturan kişi ekip lideri ise bildirim gönderme\n            if (leaderId === taskData.createdBy) return;\n            \n            await createNotification({\n              userId: leaderId,\n              type: \"task_created\",\n              title: \"Yeni görev oluşturuldu\",\n              message: `${creatorName} kullanıcısı tarafından \"${createdTask.title}\" başlıklı yeni bir görev oluşturuldu.\\n\\nYeni görev sisteme eklendi. Görev detaylarını görüntülemek için bildirime tıklayabilirsiniz.\\n\\nOluşturulma Zamanı: ${new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`,\n              read: false,\n              relatedId: docRef.id,\n              metadata: { createdBy: taskData.createdBy },\n            });\n          } catch (notifError) {\n            if (import.meta.env.DEV) {\n              console.error(\"Error sending task creation notification to team leader:\", leaderId, notifError);\n            }\n          }\n        })\n      );\n    } catch (notifError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Error sending task creation notifications:\", notifError);\n      }\n      // Bildirim hatası görev oluşturmayı engellemez\n    }\n\n    return createdTask;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Create task error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"create\",\n        collection: \"tasks\",\n        userId: taskData.createdBy,\n        data: taskData,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Görevin ekip liderlerini bul\n */\nconst getTaskTeamLeaders = async (task: Task | null): Promise<string[]> => {\n  if (!task) return [];\n  \n  try {\n    const departments = await getDepartments();\n    const teamLeaderIds: string[] = [];\n    \n    // Görevi oluşturan kişinin ekibini bul\n    if (task.createdBy) {\n      const creatorProfile = await getUserProfile(task.createdBy);\n      if (creatorProfile?.approvedTeams && creatorProfile.approvedTeams.length > 0) {\n        for (const teamId of creatorProfile.approvedTeams) {\n          const dept = departments.find(d => d.id === teamId);\n          if (dept?.managerId && !teamLeaderIds.includes(dept.managerId)) {\n            teamLeaderIds.push(dept.managerId);\n          }\n        }\n      }\n    }\n    \n    // Proje varsa projenin ekibini kontrol et\n    if (task.projectId) {\n      try {\n        const project = await getProjectById(task.projectId);\n        // Projelerde şimdilik departmentId yok, bu yüzden sadece creator'ın ekibini kullanıyoruz\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Error fetching project:\", error);\n        }\n      }\n    }\n    \n    return teamLeaderIds;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error getting team leaders:\", error);\n    }\n    return [];\n  }\n};\n\n/**\n * Görevi güncelle\n */\nexport const updateTask = async (\n  taskId: string,\n  updates: Partial<Omit<Task, \"id\" | \"createdAt\" | \"createdBy\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldTask = await getTaskById(taskId);\n    if (!oldTask) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    // Yetki kontrolü - sadece içerik güncellemeleri için (status, approvalStatus gibi alanlar için değil)\n    const isContentUpdate = updates.title !== undefined || \n                            updates.description !== undefined || \n                            updates.priority !== undefined || \n                            updates.dueDate !== undefined || \n                            updates.labels !== undefined ||\n                            updates.projectId !== undefined ||\n                            updates.isPrivate !== undefined;\n    \n    if (isContentUpdate && userId) {\n      const { getUserProfile } = await import(\"@/services/firebase/authService\");\n      const { canEditTask } = await import(\"@/utils/permissions\");\n      const userProfile = await getUserProfile(userId);\n      \n      if (!userProfile) {\n        throw new Error(\"Kullanıcı profili bulunamadı\");\n      }\n      \n      const canEdit = await canEditTask(oldTask, userProfile);\n      if (!canEdit) {\n        throw new Error(\"Bu görevi düzenlemek için yetkiniz yok. Sadece yöneticiler, ekip liderleri veya görevi oluşturan kişi düzenleyebilir.\");\n      }\n    }\n    \n    const currentUserId = userId || auth?.currentUser?.uid;\n    \n    const updateData: Partial<Task> & { updatedAt: FieldValue | Timestamp } = {\n      ...updates,\n      updatedAt: serverTimestamp() as any,\n    };\n    \n    // Son güncelleyen kullanıcıyı güncelle\n    if (currentUserId) {\n      (updateData as Partial<Task>).updatedBy = currentUserId;\n    }\n    \n    // dueDate'i Timestamp'e çevir\n    if (updates.dueDate !== undefined) {\n      if (updates.dueDate === null) {\n        updateData.dueDate = null;\n      } else if (updates.dueDate instanceof Date) {\n        updateData.dueDate = Timestamp.fromDate(updates.dueDate);\n      }\n    }\n    \n    await updateDoc(doc(firestore, \"tasks\", taskId), updateData);\n    \n    // Yeni veriyi al\n    const newTask = await getTaskById(taskId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"tasks\", taskId, userId, oldTask, newTask);\n    }\n\n    // Aktivite log ekle\n    if (userId && oldTask && newTask) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        const changedFields = Object.keys(updates).filter(key => {\n          const oldValue = (oldTask as unknown as Record<string, unknown>)[key];\n          const newValue = (updates as Record<string, unknown>)[key];\n          return oldValue !== newValue;\n        });\n        \n        if (changedFields.length > 0) {\n          await addTaskActivity(\n            taskId,\n            userId,\n            \"updated\",\n            `bu görevi güncelledi`,\n            { changedFields, taskTitle: newTask.title },\n            userName,\n            userEmail\n          );\n        }\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add task activity error:\", error);\n        }\n      }\n    }\n\n    // Görev güncellemelerinde atanan kullanıcılara bildirim gönder\n    if (newTask && userId) {\n      try {\n        const assignments = await getTaskAssignments(taskId);\n        const allUsers = await getAllUsers();\n        const updaterUser = allUsers.find(u => u.id === userId);\n        \n        // Atanan kullanıcılara bildirim gönder (güncelleyen kişi hariç)\n        const assignedUserIds = assignments\n          .filter(a => a.status === \"accepted\" || a.status === \"pending\")\n          .map(a => a.assignedTo)\n          .filter(id => id !== userId);\n        \n        await Promise.all(\n          assignedUserIds.map(async (assignedUserId) => {\n            try {\n              await createNotification({\n                userId: assignedUserId,\n                type: \"task_updated\",\n                title: \"Görev güncellendi\",\n                message: `${updaterUser?.fullName || updaterUser?.email || \"Bir kullanıcı\"} kullanıcısı tarafından \"${newTask.title}\" görevinde değişiklik yapıldı.\\n\\nGörev bilgileri güncellendi. Detayları görüntülemek için bildirime tıklayabilirsiniz.\\n\\nİşlem Zamanı: ${new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`,\n                read: false,\n                relatedId: taskId,\n                metadata: null,\n              });\n            } catch (notifError) {\n              // Bildirim hatası sessizce handle edilir - görev güncellemesini engellemez\n              if (import.meta.env.DEV) {\n                console.debug(\"Bildirim gönderilemedi (email servisi çalışmıyor olabilir):\", assignedUserId);\n              }\n            }\n          })\n        );\n      } catch (notifError) {\n        // Bildirim hatası sessizce handle edilir - görev güncellemesini engellemez\n        if (import.meta.env.DEV) {\n          console.debug(\"Görev güncelleme bildirimleri gönderilemedi (email servisi çalışmıyor olabilir)\");\n        }\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Update task error:\", error);\n    }\n    if (isPermissionError(error)) {\n      throw handlePermissionError(error, {\n        operation: \"update\",\n        collection: \"tasks\",\n        documentId: taskId,\n        userId: userId || auth?.currentUser?.uid,\n        data: updates,\n      });\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev durumunu güncelle\n */\nexport const updateTaskStatus = async (\n  taskId: string,\n  status: \"pending\" | \"in_progress\" | \"completed\" | \"cancelled\"\n): Promise<void> => {\n  try {\n    // Önce mevcut görevi al\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    const oldStatus = task.status;\n    const currentUserId = auth?.currentUser?.uid;\n    \n    // Yetki kontrolü: SADECE görev üyesi (rejected hariç) veya oluşturan durum değiştirebilir\n    // Yöneticiler için özel durum YOK\n    if (!currentUserId) {\n      throw new Error(\"Kullanıcı bilgisi bulunamadı\");\n    }\n    \n    const isCreator = task.createdBy === currentUserId;\n    \n    // Görev üyesi kontrolü (rejected hariç)\n    const assignments = await getTaskAssignments(taskId);\n    const isAssigned = assignments.some(a => a.assignedTo === currentUserId && a.status !== \"rejected\");\n    \n    // Fallback: task.assignedUsers array'inden kontrol\n    const isInTaskAssignedUsers = Array.isArray(task.assignedUsers) && task.assignedUsers.includes(currentUserId);\n    \n    const hasPermission = isCreator || isAssigned || isInTaskAssignedUsers;\n    \n    if (!hasPermission) {\n      throw new Error(\"Bu görevin durumunu değiştirme yetkiniz yok. Sadece görev üyesi olduğunuz görevlerin durumunu değiştirebilirsiniz.\");\n    }\n    \n    // ÖNEMLİ: Eğer kullanıcı assignments'da varsa ama task.assignedUsers array'inde yoksa,\n    // ÖNCE array'i güncelle (Firestore kuralları mevcut veri üzerinde çalıştığı için)\n    // Sonra durum güncellemesini yap\n    const currentAssignedUsers = Array.isArray(task.assignedUsers) ? task.assignedUsers : [];\n    const shouldUpdateAssignedUsers = isAssigned && !currentAssignedUsers.includes(currentUserId);\n    \n    if (shouldUpdateAssignedUsers) {\n      const taskRef = doc(firestore, \"tasks\", taskId);\n      await updateDoc(taskRef, {\n        assignedUsers: [...currentAssignedUsers, currentUserId],\n      });\n      if (import.meta.env.DEV) {\n        console.log(\"✅ task.assignedUsers array'i güncellendi (Firestore kuralları için):\", taskId, currentUserId);\n      }\n      // Array güncellendikten sonra task'ı tekrar al (Firestore kuralları için)\n      // Ama aslında gerek yok çünkü bir sonraki update'te zaten güncel olacak\n    }\n    \n    // Durumu güncelle\n    const updateData: Partial<Task> & { status: Task[\"status\"]; updatedAt: FieldValue | Timestamp } = {\n      status,\n      updatedAt: serverTimestamp() as any,\n    };\n    \n    // Son güncelleyen kullanıcıyı güncelle\n    if (currentUserId) {\n      (updateData as Partial<Task>).updatedBy = currentUserId;\n    }\n    \n    // Status değişikliği varsa statusUpdatedBy ve statusUpdatedAt ekle\n    if (oldStatus !== status && currentUserId) {\n      (updateData as Partial<Task>).statusUpdatedBy = currentUserId;\n      (updateData as Partial<Task>).statusUpdatedAt = serverTimestamp() as any;\n      \n      // Aşama geçmişine yeni kayıt ekle\n      const statusHistory: StatusHistoryEntry[] = task.statusHistory || [];\n      statusHistory.push({\n        status,\n        changedAt: Timestamp.now(),\n        changedBy: currentUserId,\n      });\n      updateData.statusHistory = statusHistory;\n    }\n    \n    await updateDoc(doc(firestore, \"tasks\", taskId), updateData);\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, auth?.currentUser?.uid || \"system\", { status: oldStatus }, { status });\n\n    // Aktivite log ekle (durum değişikliği)\n    if (oldStatus !== status && currentUserId) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(currentUserId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        const statusNames: Record<string, string> = {\n          pending: \"Beklemede\",\n          in_progress: \"Devam Ediyor\",\n          completed: \"Tamamlandı\",\n          cancelled: \"İptal Edildi\"\n        };\n        \n        const oldStatusName = statusNames[oldStatus] || oldStatus;\n        const newStatusName = statusNames[status] || status;\n        \n        await addTaskActivity(\n          taskId,\n          currentUserId,\n          \"status_changed\",\n          `görev durumunu \"${oldStatusName}\" → \"${newStatusName}\" olarak değiştirdi`,\n          { oldStatus, newStatus: status, taskTitle: task.title },\n          userName,\n          userEmail\n        );\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add task activity error:\", error);\n        }\n      }\n    }\n\n    // Durum değişikliği bildirimleri gönder (sadece durum gerçekten değiştiyse)\n    if (oldStatus !== status) {\n      try {\n        const assignments = await getTaskAssignments(taskId);\n        const allUsers = await getAllUsers();\n        const currentUser = auth?.currentUser;\n        const changerUser = allUsers.find(u => u.id === currentUser?.uid);\n        \n        // Durum isimlerini Türkçe'ye çevir\n        const statusNames: Record<string, string> = {\n          pending: \"Beklemede\",\n          in_progress: \"Devam Ediyor\",\n          completed: \"Tamamlandı\",\n          cancelled: \"İptal Edildi\"\n        };\n\n        const statusName = statusNames[status] || status;\n        const oldStatusName = statusNames[oldStatus] || oldStatus;\n\n        // Görevi oluşturan kişiye bildirim gönder (durum değiştiren kişi hariç)\n        if (task.createdBy && task.createdBy !== currentUser?.uid) {\n          try {\n            const changeTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            await createNotification({\n              userId: task.createdBy,\n              type: \"task_updated\",\n              title: \"Görev durumu değişti\",\n              message: `${changerUser?.fullName || changerUser?.email || \"Bir kullanıcı\"} kullanıcısı tarafından \"${task.title}\" görevinin durumu \"${oldStatusName}\" durumundan \"${statusName}\" durumuna güncellendi.\\n\\nİşlem Zamanı: ${changeTime}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                oldStatus, \n                newStatus: status,\n                updatedAt: new Date(),\n                priority: task.priority,\n                dueDate: task.dueDate,\n              },\n            });\n          } catch (notifError) {\n            console.error(\"Error sending notification to task creator:\", notifError);\n          }\n        }\n\n        // Atanan kullanıcılara bildirim gönder (durum değiştiren kişi hariç)\n        const assignedUserIds = assignments\n          .filter(a => (a.status === \"accepted\" || a.status === \"pending\") && a.assignedTo !== currentUser?.uid)\n          .map(a => a.assignedTo);\n\n        await Promise.all(\n          assignedUserIds.map(async (assignedUserId) => {\n            try {\n              const changeTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n              await createNotification({\n                userId: assignedUserId,\n                type: \"task_updated\",\n                title: \"Görev durumu değişti\",\n                message: `${changerUser?.fullName || changerUser?.email || \"Bir kullanıcı\"} tarafından \"${task.title}\" görevinin durumu \"${oldStatusName}\" durumundan \"${statusName}\" durumuna güncellendi.\\n\\nİşlem Zamanı: ${changeTime}`,\n                read: false,\n                relatedId: taskId,\n                metadata: { \n                  oldStatus, \n                  newStatus: status,\n                  updatedAt: new Date(),\n                  priority: task.priority,\n                  dueDate: task.dueDate,\n                },\n              });\n            } catch (notifError) {\n              console.error(\"Error sending notification to assigned user:\", assignedUserId, notifError);\n            }\n          })\n        );\n      } catch (notifError) {\n        console.error(\"Error sending task status change notifications:\", notifError);\n        // Bildirim hatası görev durumu güncellemesini engellemez\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Update task status error:\", error);\n    }\n    \n    // Firestore izin hatasını daha anlaşılır hale getir\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    if (errorMsg.includes(\"Missing or insufficient permissions\") || errorMsg.includes(\"permission-denied\")) {\n      // Frontend'de izin kontrolü yapıldı ama Firestore security rules izin vermiyor\n      // Bu durumda kullanıcıya açıklayıcı bir mesaj göster\n      throw new Error(\"Firestore güvenlik kuralları görev durumunu değiştirmenize izin vermiyor. Lütfen yöneticinizle iletişime geçin.\");\n    }\n    \n    throw error;\n  }\n};\n\n/**\n * Görevi sil\n */\nexport const deleteTask = async (taskId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldTask = await getTaskById(taskId);\n    if (!oldTask) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    // Yetki kontrolü\n    if (userId) {\n      const { getUserProfile } = await import(\"@/services/firebase/authService\");\n      const { canDeleteTask } = await import(\"@/utils/permissions\");\n      const userProfile = await getUserProfile(userId);\n      \n      if (!userProfile) {\n        throw new Error(\"Kullanıcı profili bulunamadı\");\n      }\n      \n      const canDelete = await canDeleteTask(oldTask, userProfile);\n      if (!canDelete) {\n        throw new Error(\"Bu görevi silmek için yetkiniz yok. Sadece yöneticiler, ekip liderleri veya görevi oluşturan kişi silebilir.\");\n      }\n    }\n    \n    // Aktivite log ekle (silmeden önce)\n    if (userId && oldTask) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addTaskActivity(\n          taskId,\n          userId,\n          \"deleted\",\n          `bu görevi sildi`,\n          { taskTitle: oldTask.title },\n          userName,\n          userEmail\n        );\n      } catch (error: unknown) {\n        if (import.meta.env.DEV) {\n          console.error(\"Add task activity error:\", error);\n        }\n      }\n    }\n\n    // Bildirim göndermek için gerekli bilgileri al\n    let assignments: TaskAssignment[] = [];\n    let allUsers: UserProfile[] = [];\n    let deleterUser: UserProfile | undefined;\n    \n    try {\n      assignments = await getTaskAssignments(taskId);\n      allUsers = await getAllUsers();\n      deleterUser = allUsers.find(u => u.id === userId);\n    } catch (notifError) {\n      console.error(\"Error fetching data for notifications:\", notifError);\n      // Bildirim hatası görev silinmesini engellemez\n    }\n    \n    // Önce subcollection'ları sil (assignments, checklists, attachments)\n    try {\n      // Assignments'ları sil\n      const assignmentsSnapshot = await getDocs(collection(firestore, \"tasks\", taskId, \"assignments\"));\n      const deleteAssignmentsPromises = assignmentsSnapshot.docs.map((doc) => deleteDoc(doc.ref));\n      await Promise.all(deleteAssignmentsPromises);\n      \n      // Checklists'leri sil\n      const checklistsSnapshot = await getDocs(collection(firestore, \"tasks\", taskId, \"checklists\"));\n      const deleteChecklistsPromises = checklistsSnapshot.docs.map((doc) => deleteDoc(doc.ref));\n      await Promise.all(deleteChecklistsPromises);\n      \n      // Attachments'ları sil (eğer varsa)\n      try {\n        const attachmentsSnapshot = await getDocs(collection(firestore, \"tasks\", taskId, \"attachments\"));\n        const deleteAttachmentsPromises = attachmentsSnapshot.docs.map((doc) => deleteDoc(doc.ref));\n        await Promise.all(deleteAttachmentsPromises);\n      } catch (attachmentsError) {\n        // Attachments collection'ı yoksa hata verme\n        if (import.meta.env.DEV) {\n          console.warn(\"Attachments collection not found or error:\", attachmentsError);\n        }\n      }\n    } catch (subcollectionError) {\n      console.error(\"Error deleting subcollections:\", subcollectionError);\n      // Subcollection silme hatası görev silinmesini engellemez, devam et\n    }\n    \n    // Ana görev document'ini sil\n    await deleteDoc(doc(firestore, \"tasks\", taskId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"tasks\", taskId, userId, oldTask, null);\n    }\n    \n    // Bildirim gönder (görev silindikten sonra)\n    try {\n      const currentUser = auth?.currentUser;\n      \n      // Görevi oluşturan kişiye bildirim gönder (silen kişi hariç)\n      if (oldTask.createdBy && oldTask.createdBy !== currentUser?.uid) {\n        try {\n          const deleteTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n          await createNotification({\n            userId: oldTask.createdBy,\n            type: \"task_deleted\",\n            title: \"Görev silindi\",\n            message: `${deleterUser?.fullName || deleterUser?.email || \"Bir kullanıcı\"} kullanıcısı tarafından \"${oldTask.title}\" görevi silindi.\\n\\nGörev sistemden kalıcı olarak kaldırıldı. Bu işlem geri alınamaz.\\n\\nSilme Zamanı: ${deleteTime}`,\n            read: false,\n            relatedId: taskId,\n            metadata: { \n              taskTitle: oldTask.title,\n              updatedAt: new Date(),\n            },\n          });\n        } catch (notifError) {\n          console.error(\"Error sending notification to task creator:\", notifError);\n        }\n      }\n      \n      // Atanan kullanıcılara bildirim gönder (silen kişi hariç)\n      const assignedUserIds = assignments\n        .filter(a => (a.status === \"accepted\" || a.status === \"pending\") && a.assignedTo !== currentUser?.uid)\n        .map(a => a.assignedTo);\n      \n      await Promise.all(\n        assignedUserIds.map(async (assignedUserId) => {\n          try {\n            const deleteTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            await createNotification({\n              userId: assignedUserId,\n              type: \"task_deleted\",\n              title: \"Görev silindi\",\n              message: `${deleterUser?.fullName || deleterUser?.email || \"Bir kullanıcı\"} kullanıcısı tarafından \"${oldTask.title}\" görevi silindi.\\n\\nGörev sistemden kalıcı olarak kaldırıldı. Bu işlem geri alınamaz.\\n\\nSilme Zamanı: ${deleteTime}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                taskTitle: oldTask.title,\n                updatedAt: new Date(),\n              },\n            });\n          } catch (notifError) {\n            console.error(\"Error sending notification to assigned user:\", assignedUserId, notifError);\n          }\n        })\n      );\n    } catch (notifError) {\n      console.error(\"Error sending task deletion notifications:\", notifError);\n      // Bildirim hatası görev silinmesini engellemez\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete task error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev ataması yap\n */\nexport const assignTask = async (\n  taskId: string,\n  userId: string,\n  assignedBy: string,\n  notes?: string\n): Promise<TaskAssignment> => {\n  try {\n    const assignmentData: Omit<TaskAssignment, \"id\"> = {\n      taskId,\n      assignedTo: userId,\n      assignedBy,\n      status: \"accepted\", // Otomatik kabul edildi - görevi oluşturan kişi kendisini atamışsa zaten kabul etmiş sayılır\n      notes: notes || null,\n      assignedAt: Timestamp.now(),\n      acceptedAt: Timestamp.now(), // Otomatik kabul edildiği için assignedAt ile aynı\n      completedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"tasks\", taskId, \"assignments\"),\n      assignmentData\n    );\n\n    // Task document'inde assignedUsers array'ini güncelle\n    const taskRef = doc(firestore, \"tasks\", taskId);\n    const taskSnap = await getDoc(taskRef);\n    if (taskSnap.exists()) {\n      const taskData = taskSnap.data();\n      const assignedUsers = taskData.assignedUsers || [];\n      if (!assignedUsers.includes(userId)) {\n        await updateDoc(taskRef, {\n          assignedUsers: [...assignedUsers, userId],\n        });\n      }\n    }\n\n    try {\n      const [task, assignerProfile] = await Promise.all([\n        getTaskById(taskId),\n        getUserProfile(assignedBy),\n      ]);\n\n      if (task) {\n        // Görev detaylarını topla\n        const taskDetails: string[] = [];\n        if (task.description) {\n          const desc = task.description.length > 100 ? task.description.substring(0, 100) + \"...\" : task.description;\n          taskDetails.push(`Açıklama: ${desc}`);\n        }\n        if (task.priority) {\n          const { getPriorityLabel, convertOldPriorityToNew } = await import(\"@/utils/priority\");\n          // TaskService hala 1-5 kullanıyor, yeni sisteme (0-5) çevir\n          const newPriority = convertOldPriorityToNew(task.priority);\n          const priorityLabel = getPriorityLabel(newPriority);\n          taskDetails.push(`Öncelik: ${priorityLabel}`);\n        }\n        if (task.dueDate) {\n          try {\n            const dueDate = task.dueDate instanceof Timestamp ? task.dueDate.toDate() : new Date(task.dueDate);\n            const formattedDate = dueDate.toLocaleDateString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            taskDetails.push(`Bitiş Tarihi: ${formattedDate}`);\n          } catch {\n            // Tarih formatı hatası durumunda sessizce devam et\n          }\n        }\n        \n        const detailsText = taskDetails.length > 0 ? `\\n\\nGörev Detayları:\\n${taskDetails.join('\\n')}` : '';\n        \n        // Metadata için Timestamp'leri Date'e çevir\n        let dueDateForMetadata: Date | null = null;\n        if (task.dueDate) {\n          try {\n            const dueDateValue = task.dueDate as unknown;\n            if (dueDateValue instanceof Timestamp) {\n              dueDateForMetadata = (dueDateValue as Timestamp).toDate();\n            } else if (dueDateValue instanceof Date) {\n              dueDateForMetadata = dueDateValue;\n            } else if (typeof dueDateValue === 'object' && dueDateValue !== null && 'seconds' in dueDateValue) {\n              // Firestore Timestamp objesi\n              const ts = dueDateValue as { seconds: number; nanoseconds?: number };\n              dueDateForMetadata = new Date(ts.seconds * 1000 + (ts.nanoseconds || 0) / 1000000);\n            }\n          } catch {\n            // Tarih formatı hatası durumunda null bırak\n            dueDateForMetadata = null;\n          }\n        }\n        \n        await createNotification({\n          userId,\n          type: \"task_assigned\",\n          title: \"Yeni görev atandı\",\n          message: `${assignerProfile?.fullName || assignerProfile?.email || \"Bir yönetici\"} kullanıcısı tarafından size \"${task.title}\" başlıklı yeni bir görev atandı.${detailsText}\\n\\nGörev detaylarını görüntülemek için bildirime tıklayabilirsiniz.`,\n          read: false,\n          relatedId: taskId,\n          metadata: { \n            assignment_id: docRef.id,\n            priority: task.priority,\n            dueDate: dueDateForMetadata, // Date objesi olarak gönder\n            updatedAt: new Date(),\n          },\n        });\n      }\n    } catch (notifError) {\n      // Bildirim hatası kritik değil, sessizce devam et\n      // Uygulama akışını bozma\n    }\n\n    // Audit log\n    if (assignedBy) {\n      await logAudit(\"CREATE\", \"task_assignments\", docRef.id, assignedBy, null, assignmentData);\n    }\n\n    return {\n      id: docRef.id,\n      ...assignmentData,\n    };\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Assign task error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev atamasını kabul et\n */\nexport const acceptTaskAssignment = async (taskId: string, assignmentId: string): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId), {\n      status: \"accepted\",\n      acceptedAt: serverTimestamp(),\n    });\n    \n    // Audit log\n    const userId = auth?.currentUser?.uid;\n    if (userId) {\n      const task = await getTaskById(taskId);\n      const assignmentDoc = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const oldAssignment = assignmentDoc.data();\n      await logAudit(\n        \"UPDATE\",\n        \"task_assignments\",\n        assignmentId,\n        userId,\n        oldAssignment || { status: \"pending\" },\n        { status: \"accepted\", taskId: taskId, taskTitle: task?.title },\n        { action: \"accept\", taskId }\n      );\n    }\n    \n    // Atanan kullanıcının bildirimini güncelle\n    try {\n      const assignment = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const assignmentData = assignment.data() as TaskAssignment;\n      \n      if (assignmentData) {\n        // Atanan kullanıcının bildirimlerini bul ve güncelle\n        const { getNotifications } = await import(\"./notificationService\");\n        const userNotifications = await getNotifications(assignmentData.assignedTo, { limit: 100 });\n        \n        // İlgili bildirimi bul: task_assigned tipinde, assignment_id metadata'sı eşleşen\n        const relatedNotification = userNotifications.find((notif) => {\n          if (notif.type !== \"task_assigned\" || notif.relatedId !== taskId) return false;\n          const meta = notif.metadata;\n          if (meta && typeof meta === \"object\" && \"assignment_id\" in meta) {\n            return (meta as Record<string, unknown>).assignment_id === assignmentId;\n          }\n          return false;\n        });\n        \n        if (relatedNotification) {\n          // Bildirimi güncelle: action metadata ekle ve okundu işaretle\n          const updatedMetadata = { \n            ...relatedNotification.metadata, \n            action: \"accepted\" \n          };\n          await updateNotification(relatedNotification.id, {\n            metadata: updatedMetadata,\n            read: true\n          });\n        }\n      }\n    } catch (notifUpdateError) {\n      console.error(\"Error updating assignment notification:\", notifUpdateError);\n      // Bildirim güncelleme hatası kabul işlemini engellemez\n    }\n    \n    // Ekip liderlerine bildirim gönder\n    try {\n      const task = await getTaskById(taskId);\n      const assignment = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const assignmentData = assignment.data() as TaskAssignment;\n      \n      if (task && assignmentData) {\n        const teamLeaders = await getTaskTeamLeaders(task);\n        const allUsers = await getAllUsers();\n        const assignedUser = allUsers.find(u => u.id === assignmentData.assignedTo);\n        \n        await Promise.all(\n          teamLeaders.map(async (leaderId) => {\n            try {\n              const acceptTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n              await createNotification({\n                userId: leaderId,\n                type: \"task_assigned\",\n                title: \"Görev kabul edildi\",\n                message: `${assignedUser?.fullName || assignedUser?.email || \"Bir kullanıcı\"} kullanıcısı \"${task.title}\" görevini kabul etti.\\n\\nGörev artık bu kullanıcının görev listesinde görünecek ve üzerinde çalışmaya başlayabilir.\\n\\nKabul Zamanı: ${acceptTime}`,\n                read: false,\n                relatedId: taskId,\n                metadata: { \n                  assignment_id: assignmentId, \n                  action: \"accepted\",\n                  updatedAt: new Date(),\n                  priority: task.priority,\n                  dueDate: task.dueDate,\n                },\n              });\n            } catch (notifError) {\n              console.error(\"Error sending notification to team leader:\", leaderId, notifError);\n            }\n          })\n        );\n      }\n    } catch (notifError) {\n      console.error(\"Error sending acceptance notifications:\", notifError);\n      // Bildirim hatası kabul işlemini engellemez\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Accept task assignment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev atamasını reddet\n */\nexport const rejectTaskAssignment = async (\n  taskId: string,\n  assignmentId: string,\n  reason: string\n): Promise<void> => {\n  try {\n    // Red sebebi en az 20 karakter olmalı\n    if (reason.trim().length < 20) {\n      throw new Error(\"Red sebebi en az 20 karakter olmalıdır\");\n    }\n    \n    await updateDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId), {\n      status: \"rejected\",\n      rejectionReason: reason.trim(),\n    });\n    \n    // Audit log\n    const userId = auth?.currentUser?.uid;\n    if (userId) {\n      const task = await getTaskById(taskId);\n      const assignmentDoc = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const oldAssignment = assignmentDoc.data();\n      await logAudit(\n        \"UPDATE\",\n        \"task_assignments\",\n        assignmentId,\n        userId,\n        oldAssignment || { status: \"pending\" },\n        { status: \"rejected\", rejectionReason: reason.trim(), taskId: taskId, taskTitle: task?.title },\n        { action: \"reject\", taskId, reason: reason.trim() }\n      );\n    }\n    \n    // Atanan kullanıcının bildirimini güncelle\n    try {\n      const assignment = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const assignmentData = assignment.data() as TaskAssignment;\n      \n      if (assignmentData) {\n        // Atanan kullanıcının bildirimlerini bul ve güncelle\n        const { getNotifications } = await import(\"./notificationService\");\n        const userNotifications = await getNotifications(assignmentData.assignedTo, { limit: 100 });\n        \n        // İlgili bildirimi bul: task_assigned tipinde, assignment_id metadata'sı eşleşen\n        const relatedNotification = userNotifications.find((notif) => {\n          if (notif.type !== \"task_assigned\" || notif.relatedId !== taskId) return false;\n          const meta = notif.metadata;\n          if (meta && typeof meta === \"object\" && \"assignment_id\" in meta) {\n            return (meta as Record<string, unknown>).assignment_id === assignmentId;\n          }\n          return false;\n        });\n        \n        if (relatedNotification) {\n          // Bildirimi güncelle: action metadata ekle ve okundu işaretle\n          const updatedMetadata = { \n            ...relatedNotification.metadata, \n            action: \"rejected\" \n          };\n          await updateNotification(relatedNotification.id, {\n            metadata: updatedMetadata,\n            read: true\n          });\n        }\n      }\n    } catch (notifUpdateError) {\n      console.error(\"Error updating assignment notification:\", notifUpdateError);\n      // Bildirim güncelleme hatası red işlemini engellemez\n    }\n    \n    // Bildirimler gönder\n    try {\n      const task = await getTaskById(taskId);\n      const assignment = await getDoc(doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId));\n      const assignmentData = assignment.data() as TaskAssignment;\n      \n      if (task && assignmentData) {\n        const allUsers = await getAllUsers();\n        const assignedUser = allUsers.find(u => u.id === assignmentData.assignedTo);\n        const taskCreator = allUsers.find(u => u.id === task.createdBy);\n        const assignerUser = allUsers.find(u => u.id === assignmentData.assignedBy);\n        \n        // 1. Görevi veren kişiye bildirim gönder (assignedBy) - ÖNEMLİ: Görevi veren kişi reddi bilmeli\n        if (assignmentData.assignedBy && assignmentData.assignedBy !== auth?.currentUser?.uid) {\n          try {\n            const rejectTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            await createNotification({\n              userId: assignmentData.assignedBy,\n              type: \"task_assigned\",\n              title: \"Görev reddedildi\",\n              message: `${assignedUser?.fullName || assignedUser?.email || \"Bir kullanıcı\"} kullanıcısı \"${task.title}\" görevini reddetti.\\n\\nReddetme Sebebi: ${reason.trim().substring(0, 200)}${reason.trim().length > 200 ? \"...\" : \"\"}\\n\\nReddetme Zamanı: ${rejectTime}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                assignment_id: assignmentId, \n                action: \"rejected\", \n                reason: reason.trim(),\n                assigned_user_id: assignmentData.assignedTo,\n                updatedAt: new Date(),\n                priority: task.priority,\n                dueDate: task.dueDate,\n              },\n            });\n          } catch (notifError) {\n            console.error(\"Error sending notification to task assigner:\", notifError);\n          }\n        }\n        \n        // 2. Görevi tanımlayan kişiye bildirim gönder (createdBy) - Eğer görevi veren kişi değilse\n        if (task.createdBy && task.createdBy !== auth?.currentUser?.uid && task.createdBy !== assignmentData.assignedBy) {\n          try {\n            const rejectTime2 = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            await createNotification({\n              userId: task.createdBy,\n              type: \"task_assigned\",\n              title: \"Görev reddedildi - Onayınız gerekiyor\",\n              message: `${assignedUser?.fullName || assignedUser?.email || \"Bir kullanıcı\"} kullanıcısı \"${task.title}\" görevini reddetti.\\n\\nReddetme Sebebi: ${reason.trim().substring(0, 200)}${reason.trim().length > 200 ? \"...\" : \"\"}\\n\\nReddetme Zamanı: ${rejectTime2}\\n\\nLütfen bu reddi onaylayın veya reddedin. Reddin onaylanması durumunda görev başka birine atanabilir.`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                assignment_id: assignmentId, \n                action: \"rejection_pending_approval\", \n                reason: reason.trim(),\n                assigned_user_id: assignmentData.assignedTo,\n                updatedAt: new Date(),\n                priority: task.priority,\n                dueDate: task.dueDate,\n              },\n            });\n          } catch (notifError) {\n            console.error(\"Error sending notification to task creator:\", notifError);\n          }\n        }\n        \n        // 3. Ekip liderlerine bildirim gönder\n        const teamLeaders = await getTaskTeamLeaders(task);\n        await Promise.all(\n          teamLeaders\n            .filter(leaderId => leaderId !== task.createdBy && leaderId !== assignmentData.assignedBy) // Görevi tanımlayan ve veren zaten bildirim aldı\n            .map(async (leaderId) => {\n              try {\n                await createNotification({\n                  userId: leaderId,\n                  type: \"task_assigned\",\n                  title: \"Görev reddedildi\",\n                  message: `${assignedUser?.fullName || assignedUser?.email || \"Bir kullanıcı\"} \"${task.title}\" görevini reddetti. Sebep: ${reason.trim().substring(0, 100)}${reason.trim().length > 100 ? \"...\" : \"\"}`,\n                  read: false,\n                  relatedId: taskId,\n                  metadata: { assignment_id: assignmentId, action: \"rejected\", reason: reason.trim() },\n                });\n              } catch (notifError) {\n                console.error(\"Error sending notification to team leader:\", leaderId, notifError);\n              }\n            })\n        );\n      }\n    } catch (notifError) {\n      console.error(\"Error sending rejection notifications:\", notifError);\n      // Bildirim hatası red işlemini engellemez\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Reject task assignment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev atamalarını al\n */\nexport const getTaskAssignments = async (taskId: string): Promise<TaskAssignment[]> => {\n  try {\n    const snapshot = await getDocs(collection(firestore, \"tasks\", taskId, \"assignments\"));\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as TaskAssignment[];\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get task assignments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev atamasını sil\n */\nexport const deleteTaskAssignment = async (taskId: string, assignmentId: string, deletedBy?: string): Promise<void> => {\n  try {\n    // Önce assignment bilgilerini al (bildirim için) - SİLME İŞLEMİNDEN ÖNCE\n    const assignmentRef = doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId);\n    const assignmentSnap = await getDoc(assignmentRef);\n    \n    if (!assignmentSnap.exists()) {\n      if (import.meta.env.DEV) {\n        console.warn(\"⚠️ Assignment bulunamadı, silme işlemi atlanıyor:\", assignmentId);\n      }\n      return;\n    }\n    \n    const assignmentData = assignmentSnap.data() as TaskAssignment | undefined;\n    \n    // Assignment'ı sil\n    await deleteDoc(assignmentRef);\n    \n    // Task document'inde assignedUsers array'ini güncelle\n    if (assignmentData) {\n      const taskRef = doc(firestore, \"tasks\", taskId);\n      const taskSnap = await getDoc(taskRef);\n      if (taskSnap.exists()) {\n        const taskData = taskSnap.data();\n        const assignedUsers = taskData.assignedUsers || [];\n        if (assignedUsers.includes(assignmentData.assignedTo)) {\n          await updateDoc(taskRef, {\n            assignedUsers: assignedUsers.filter((uid: string) => uid !== assignmentData.assignedTo),\n          });\n        }\n      }\n      \n      // Bildirim gönder - kaldırılan kullanıcıya\n      if (assignmentData) {\n        try {\n          const [task, deleterProfile, removedUser] = await Promise.all([\n            getTaskById(taskId),\n            deletedBy ? getUserProfile(deletedBy) : Promise.resolve(null),\n            getUserProfile(assignmentData.assignedTo),\n          ]);\n          \n          if (task && removedUser) {\n            // Kaldırılan kullanıcıya bildirim\n            const removeTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            const removedUserNotification = await createNotification({\n              userId: assignmentData.assignedTo,\n              type: \"task_updated\",\n              title: \"Görev atamanız kaldırıldı\",\n              message: `${deleterProfile?.fullName || deleterProfile?.email || \"Bir yönetici\"} kullanıcısı tarafından siz \"${task.title}\" görevinden kaldırıldınız.\\n\\nArtık bu görevle ilgili bildirimler almayacaksınız ve görev üzerinde işlem yapamayacaksınız.\\n\\nKaldırılma Zamanı: ${removeTime}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                assignment_id: assignmentId, \n                action: \"removed\",\n                updatedAt: new Date(),\n                priority: task.priority,\n                dueDate: task.dueDate,\n              },\n            });\n            \n            if (import.meta.env.DEV) {\n              console.log(\"✅ Kaldırılan kullanıcıya bildirim gönderildi:\", removedUserNotification.id);\n            }\n            \n            // Görevi oluşturan kişiye bildirim (eğer kaldıran kişi değilse)\n            if (task.createdBy && task.createdBy !== deletedBy && task.createdBy !== assignmentData.assignedTo) {\n              const removeTime2 = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n              const creatorNotification = await createNotification({\n                userId: task.createdBy,\n                type: \"task_updated\",\n                title: \"Görev ataması kaldırıldı\",\n                message: `${deleterProfile?.fullName || deleterProfile?.email || \"Bir yönetici\"} kullanıcısı tarafından \"${removedUser?.fullName || removedUser?.email || \"bir kullanıcı\"}\" kullanıcısı \"${task.title}\" görevinden kaldırıldı.\\n\\nBu kullanıcı artık görevle ilgili bildirimler almayacak ve görev üzerinde işlem yapamayacak.\\n\\nKaldırılma Zamanı: ${removeTime2}`,\n                read: false,\n                relatedId: taskId,\n                metadata: { \n                  assignment_id: assignmentId, \n                  action: \"removed\", \n                  removed_user_id: assignmentData.assignedTo,\n                  updatedAt: new Date(),\n                  priority: task.priority,\n                  dueDate: task.dueDate,\n                },\n              });\n              \n              if (import.meta.env.DEV) {\n                console.log(\"✅ Görev oluşturucuya bildirim gönderildi:\", creatorNotification.id);\n              }\n            }\n          } else {\n            if (import.meta.env.DEV) {\n              console.warn(\"⚠️ Bildirim gönderilemedi: task veya removedUser bulunamadı\", { task: !!task, removedUser: !!removedUser });\n            }\n          }\n        } catch (notifError) {\n          // Bildirim hatası silme işlemini engellemez\n          // Email servisi çalışmıyor olabilir, bu normal\n          if (import.meta.env.DEV) {\n            console.debug(\"Bildirim gönderilemedi (email servisi çalışmıyor olabilir)\");\n          }\n        }\n      }\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete task assignment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist oluştur\n */\nexport const createChecklist = async (\n  taskId: string,\n  title: string,\n  items: Array<{ text: string; completed?: boolean }>\n): Promise<Checklist> => {\n  try {\n    const checklistData: Omit<Checklist, \"id\"> = {\n      taskId,\n      title,\n      items: items.map((item) => ({\n        id: `${Date.now()}-${Math.random()}`,\n        text: item.text,\n        completed: item.completed || false,\n        createdAt: Timestamp.now(),\n        completedAt: null,\n      })),\n      createdAt: Timestamp.now(),\n      updatedAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"tasks\", taskId, \"checklists\"),\n      checklistData\n    );\n\n    return {\n      id: docRef.id,\n      ...checklistData,\n    };\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Create checklist error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist item'ını güncelle (tik atma)\n * Sadece göreve atanan kullanıcılar ve yöneticiler işaretleyebilir\n */\nexport const updateChecklistItem = async (\n  taskId: string,\n  checklistId: string,\n  itemId: string,\n  completed: boolean,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Yetki kontrolü: Sadece atanan kullanıcılar ve yöneticiler işaretleyebilir\n    if (userId) {\n      const task = await getTaskById(taskId);\n      if (!task) {\n        throw new Error(\"Görev bulunamadı\");\n      }\n\n      // Yetki kontrolü: Firestore'dan kontrol et\n      const { getUserProfile } = await import(\"./authService\");\n      const userProfile = await getUserProfile(userId);\n      \n      if (userProfile) {\n        const { canAddChecklist } = await import(\"@/utils/permissions\");\n        const assignments = await getTaskAssignments(taskId);\n        const assignedUserIds = assignments\n          .filter((a) => a.status === \"accepted\" || a.status === \"pending\")\n          .map((a) => a.assignedTo);\n        \n        const canAdd = await canAddChecklist(task, userProfile, assignedUserIds);\n        if (!canAdd) {\n          throw new Error(\"Checklist işaretleme yetkiniz yok. Sadece size atanan görevlerin checklist'lerini işaretleyebilirsiniz.\");\n        }\n      }\n    }\n\n    const checklistRef = doc(firestore, \"tasks\", taskId, \"checklists\", checklistId);\n    const checklistDoc = await getDoc(checklistRef);\n    \n    if (!checklistDoc.exists()) {\n      throw new Error(\"Checklist bulunamadı\");\n    }\n\n    const checklist = checklistDoc.data() as Checklist;\n    const updatedItems = checklist.items.map((item) =>\n      item.id === itemId\n        ? {\n            ...item,\n            completed,\n            completedAt: completed ? Timestamp.now() : null,\n          }\n        : item\n    );\n\n    await updateDoc(checklistRef, {\n      items: updatedItems,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\n      \"UPDATE\",\n      \"checklist_items\",\n      `${taskId}/${checklistId}/${itemId}`,\n      userId || auth?.currentUser?.uid || \"system\",\n      { completed: !completed },\n      { completed }\n    );\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Update checklist item error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist'leri al\n */\nexport const getChecklists = async (taskId: string): Promise<Checklist[]> => {\n  try {\n    const snapshot = await getDocs(collection(firestore, \"tasks\", taskId, \"checklists\"));\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as Checklist[];\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get checklists error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist item ekle\n */\nexport const addChecklistItem = async (\n  taskId: string,\n  checklistId: string,\n  text: string\n): Promise<void> => {\n  try {\n    const checklistRef = doc(firestore, \"tasks\", taskId, \"checklists\", checklistId);\n    const checklistDoc = await getDoc(checklistRef);\n    \n    if (!checklistDoc.exists()) {\n      throw new Error(\"Checklist bulunamadı\");\n    }\n\n    const checklist = checklistDoc.data() as Checklist;\n    const newItem: ChecklistItem = {\n      id: `${Date.now()}-${Math.random()}`,\n      text,\n      completed: false,\n      createdAt: Timestamp.now(),\n      completedAt: null,\n    };\n\n    await updateDoc(checklistRef, {\n      items: [...checklist.items, newItem],\n      updatedAt: serverTimestamp(),\n    });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add checklist item error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist sil\n */\nexport const deleteChecklist = async (taskId: string, checklistId: string, userId?: string): Promise<void> => {\n  try {\n    // Yetki kontrolü: Firestore'dan kontrol et\n    if (userId) {\n      const task = await getTaskById(taskId);\n      if (!task) {\n        throw new Error(\"Görev bulunamadı\");\n      }\n      \n      const { getUserProfile } = await import(\"./authService\");\n      const userProfile = await getUserProfile(userId);\n      \n      if (userProfile) {\n        const { canEditChecklist } = await import(\"@/utils/permissions\");\n        const assignments = await getTaskAssignments(taskId);\n        const assignedUserIds = assignments\n          .filter((a) => a.status === \"accepted\" || a.status === \"pending\")\n          .map((a) => a.assignedTo);\n        \n        const canEdit = await canEditChecklist(task, userProfile, assignedUserIds);\n        if (!canEdit) {\n          throw new Error(\"Checklist silme yetkiniz yok. Sadece göreve atanan kullanıcılar veya yöneticiler silebilir.\");\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, \"tasks\", taskId, \"checklists\", checklistId));\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete checklist error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Checklist item sil\n */\nexport const deleteChecklistItem = async (\n  taskId: string,\n  checklistId: string,\n  itemId: string\n): Promise<void> => {\n  try {\n    const checklistRef = doc(firestore, \"tasks\", taskId, \"checklists\", checklistId);\n    const checklistDoc = await getDoc(checklistRef);\n    \n    if (!checklistDoc.exists()) {\n      throw new Error(\"Checklist bulunamadı\");\n    }\n\n    const checklist = checklistDoc.data() as Checklist;\n    const updatedItems = checklist.items.filter((item) => item.id !== itemId);\n\n    await updateDoc(checklistRef, {\n      items: updatedItems,\n      updatedAt: serverTimestamp(),\n    });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete checklist item error:\", error);\n    }\n    throw error;\n  }\n};\n\nexport interface TaskComment {\n  id: string;\n  taskId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp;\n  updatedAt?: Timestamp | null;\n}\n\nexport interface TaskActivity {\n  id: string;\n  taskId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp;\n}\n\n/**\n * Yorum ekle\n */\nexport const addTaskComment = async (\n  taskId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<TaskComment> => {\n  try {\n    const commentData: Omit<TaskComment, \"id\"> = {\n      taskId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"tasks\", taskId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addTaskActivity(taskId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Görevi oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const task = await getTaskById(taskId);\n      if (task?.createdBy && task.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: task.createdBy,\n          type: \"comment_added\",\n          title: \"Görevinize Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} kullanıcısı \"${task.title || \"Görev\"}\" görevinize yorum ekledi.\\n\\nYorum: ${content.substring(0, 200)}${content.length > 200 ? \"...\" : \"\"}\\n\\nYorumu görüntülemek ve yanıtlamak için bildirime tıklayabilirsiniz.\\n\\nYorum Zamanı: ${new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`,\n          read: false,\n          relatedId: taskId,\n          metadata: { \n            commentId: docRef.id, \n            commenterId: userId, \n            commenterName: userName, \n            commenterEmail: userEmail,\n            updatedAt: new Date(),\n          },\n        });\n      }\n    } catch (error: unknown) {\n      if (import.meta.env.DEV) {\n        console.error(\"Send comment notification error:\", error);\n      }\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add task comment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Yorumları al\n */\nexport const getTaskComments = async (taskId: string): Promise<TaskComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"tasks\", taskId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as TaskComment[];\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get task comments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Aktivite log ekle\n */\nexport const addTaskActivity = async (\n  taskId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<TaskActivity, \"id\"> = {\n      taskId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"tasks\", taskId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error: unknown) {\n    // Firestore security rules hatası normal - sessizce handle et\n    // Bu hata görev güncellemesini engellemez\n    if (import.meta.env.DEV) {\n      // Sadece development'ta debug log göster\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      if (!errorMsg.includes(\"Missing or insufficient permissions\")) {\n        // İzin hatası değilse log göster (gerçek bir sorun olabilir)\n        console.debug(\"Add task activity error:\", error);\n      }\n    }\n    return \"\";\n  }\n};\n\n/**\n * Aktivite loglarını al\n */\nexport const getTaskActivities = async (taskId: string): Promise<TaskActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"tasks\", taskId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as TaskActivity[];\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get task activities error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev ekini ekle\n * ÖNEMLİ: Sadece göreve atanan kullanıcılar veya görevi oluşturan kişi dosya ekleyebilir\n */\nexport const addTaskAttachment = async (\n  taskId: string,\n  attachment: Omit<TaskAttachment, \"id\" | \"uploadedAt\">\n): Promise<TaskAttachment> => {\n  try {\n    // Önce görevi kontrol et\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    // Kullanıcı kontrolü\n    const currentUserId = auth?.currentUser?.uid;\n    if (!currentUserId) {\n      throw new Error(\"Kullanıcı oturumu bulunamadı\");\n    }\n\n    // Kullanıcı profilini al (admin kontrolü için)\n    const userProfile = await getUserProfile(currentUserId);\n    if (!userProfile) {\n      throw new Error(\"Kullanıcı profili bulunamadı\");\n    }\n\n    // Admin kontrolü - adminler her zaman dosya ekleyebilir\n    const { isAdmin: checkIsAdmin, isMainAdmin } = await import(\"@/utils/permissions\");\n    const isAdmin = await checkIsAdmin(userProfile) || await isMainAdmin(userProfile);\n\n    // Eğer admin değilse, göreve atanmış olup olmadığını veya görevi oluşturmuş olup olmadığını kontrol et\n    if (!isAdmin) {\n      const isCreator = task.createdBy === currentUserId;\n      \n      if (!isCreator) {\n        // Göreve atanmış olup olmadığını kontrol et\n        const assignments = await getTaskAssignments(taskId);\n        const assignedUserIds = assignments\n          .filter(a => a.status === \"accepted\") // Sadece kabul edilen atamalar\n          .map(a => a.assignedTo);\n        \n        const isAssigned = assignedUserIds.includes(currentUserId);\n        \n        if (!isAssigned) {\n          throw new Error(\"Bu göreve dosya eklemek için yetkiniz yok. Sadece size atanan görevlere veya oluşturduğunuz görevlere dosya ekleyebilirsiniz.\");\n        }\n      }\n    }\n\n    const attachmentData = {\n      ...attachment,\n      uploadedAt: serverTimestamp(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, \"tasks\", taskId, \"attachments\"),\n      attachmentData\n    );\n\n    const createdAttachment = await getDoc(docRef);\n    return {\n      id: docRef.id,\n      ...createdAttachment.data(),\n      uploadedAt: createdAttachment.data()?.uploadedAt || Timestamp.now(),\n    } as TaskAttachment;\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add task attachment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev eklerini al\n */\nexport const getTaskAttachments = async (taskId: string): Promise<TaskAttachment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, \"tasks\", taskId, \"attachments\"),\n        orderBy(\"uploadedAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as TaskAttachment[];\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get task attachments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev ekini sil\n * ÖNEMLİ: Sadece göreve atanan kullanıcılar, görevi oluşturan kişi veya adminler dosya silebilir\n */\nexport const deleteTaskAttachment = async (taskId: string, attachmentId: string): Promise<void> => {\n  try {\n    // Önce görevi kontrol et\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    // Kullanıcı kontrolü\n    const currentUserId = auth?.currentUser?.uid;\n    if (!currentUserId) {\n      throw new Error(\"Kullanıcı oturumu bulunamadı\");\n    }\n\n    // Kullanıcı profilini al (admin kontrolü için)\n    const userProfile = await getUserProfile(currentUserId);\n    if (!userProfile) {\n      throw new Error(\"Kullanıcı profili bulunamadı\");\n    }\n\n    // Admin kontrolü - adminler her zaman dosya silebilir\n    const { isAdmin: checkIsAdmin, isMainAdmin } = await import(\"@/utils/permissions\");\n    const isAdmin = await checkIsAdmin(userProfile) || await isMainAdmin(userProfile);\n\n    // Eğer admin değilse, göreve atanmış olup olmadığını veya görevi oluşturmuş olup olmadığını kontrol et\n    if (!isAdmin) {\n      const isCreator = task.createdBy === currentUserId;\n      \n      if (!isCreator) {\n        // Göreve atanmış olup olmadığını kontrol et\n        const assignments = await getTaskAssignments(taskId);\n        const assignedUserIds = assignments\n          .filter(a => a.status === \"accepted\") // Sadece kabul edilen atamalar\n          .map(a => a.assignedTo);\n        \n        const isAssigned = assignedUserIds.includes(currentUserId);\n        \n        if (!isAssigned) {\n          throw new Error(\"Bu görevden dosya silmek için yetkiniz yok. Sadece size atanan görevlerden veya oluşturduğunuz görevlerden dosya silebilirsiniz.\");\n        }\n      }\n    }\n\n    await deleteDoc(doc(firestore, \"tasks\", taskId, \"attachments\", attachmentId));\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete task attachment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görevi havuza ekle\n */\nexport const addTaskToPool = async (taskId: string): Promise<void> => {\n  try {\n    // Önce görev bilgilerini al\n    const taskRef = doc(firestore, \"tasks\", taskId);\n    const taskSnap = await getDoc(taskRef);\n    \n    if (!taskSnap.exists()) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    const taskData = taskSnap.data() as Task;\n    \n    // Görevi havuza ekle\n    await updateDoc(taskRef, {\n      isInPool: true,\n      poolRequests: [],\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, auth?.currentUser?.uid || \"system\", { isInPool: false }, { isInPool: true });\n\n    // Tüm üyelere bildirim gönder\n    try {\n      const allUsers = await getAllUsers();\n      const currentUserId = auth?.currentUser?.uid;\n      const currentUser = await getUserProfile(currentUserId || \"\");\n      const currentUserName = currentUser?.fullName || currentUser?.displayName || currentUser?.email || \"Bir kullanıcı\";\n      \n      // Görevi oluşturan hariç tüm kullanıcılara bildirim gönder\n      const notificationPromises = allUsers\n        .filter(user => user.id && user.id !== currentUserId && user.id !== taskData.createdBy)\n        .map(user => \n          createNotification({\n            userId: user.id,\n            type: \"task_pool_request\",\n            title: \"Görev Havuzuna Yeni Görev Eklendi\",\n            message: `${currentUserName} \"${taskData.title}\" görevini görev havuzuna ekledi. Bu görevi talep edebilirsiniz.`,\n            read: false,\n            metadata: {\n              taskId: taskId,\n              taskTitle: taskData.title,\n              addedBy: currentUserId,\n              addedByName: currentUserName,\n              link: `/tasks?taskId=${taskId}&view=list`,\n            },\n          })\n        );\n      \n      await Promise.all(notificationPromises);\n    } catch (notificationError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Bildirim gönderme hatası:\", notificationError);\n      }\n      // Bildirim hatası görevi havuza eklemeyi engellemez\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add task to pool error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görevi havuzdan çıkar\n */\nexport const removeTaskFromPool = async (taskId: string): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      isInPool: false,\n      poolRequests: [],\n      updatedAt: serverTimestamp(),\n    });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Remove task from pool error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev havuzundan görev talep et\n */\nexport const requestTaskFromPool = async (taskId: string, userId: string): Promise<void> => {\n  try {\n    const taskRef = doc(firestore, \"tasks\", taskId);\n    const taskSnap = await getDoc(taskRef);\n    \n    if (!taskSnap.exists()) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    const taskData = taskSnap.data();\n    const poolRequests = taskData.poolRequests || [];\n    \n    if (poolRequests.includes(userId)) {\n      throw new Error(\"Bu görev için zaten talep yaptınız\");\n    }\n    \n    await updateDoc(taskRef, {\n      poolRequests: [...poolRequests, userId],\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, userId, { poolRequests }, { poolRequests: [...poolRequests, userId] });\n\n    // Görevi havuza ekleyen kişiye bildirim gönder (görevi oluşturan kişi)\n    // Not: Görev havuzuna ekleme işlemi genellikle görevi oluşturan kişi tarafından yapılır\n    const taskCreatorId = taskData.createdBy;\n    if (taskCreatorId && taskCreatorId !== userId) {\n      try {\n        const requestingUser = await getUserProfile(userId);\n        const requestingUserName = requestingUser?.fullName || requestingUser?.displayName || requestingUser?.email || \"Bir kullanıcı\";\n        \n        await createNotification({\n          userId: taskCreatorId,\n          type: \"task_pool_request\",\n          title: \"Görev Havuzu Talebi\",\n          message: `${requestingUserName} \"${taskData.title}\" görevi için talep gönderdi. Talebi onaylayabilirsiniz.`,\n          read: false,\n          relatedId: taskId, // Yönlendirme için gerekli\n          metadata: {\n            taskId: taskId,\n            taskTitle: taskData.title,\n            requestedBy: userId,\n            requestedByName: requestingUserName,\n            link: `/tasks?taskId=${taskId}&view=list`,\n          },\n        });\n      } catch (notificationError) {\n        if (import.meta.env.DEV) {\n          console.error(\"Bildirim gönderme hatası:\", notificationError);\n        }\n        // Bildirim hatası görev talebini engellemez\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Request task from pool error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev havuzu talebini onayla\n */\nexport const approvePoolRequest = async (taskId: string, userId: string, approvedBy: string, keepInPool: boolean = false): Promise<void> => {\n  try {\n    const taskRef = doc(firestore, \"tasks\", taskId);\n    const taskSnap = await getDoc(taskRef);\n    \n    if (!taskSnap.exists()) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    const taskData = taskSnap.data() as Task;\n    const poolRequests = taskData.poolRequests || [];\n    \n    if (!poolRequests.includes(userId)) {\n      throw new Error(\"Bu kullanıcı için talep bulunamadı\");\n    }\n    \n    // Görevi havuza ekleyen kişi kontrolü (genellikle görevi oluşturan kişi)\n    // Not: Görev havuzuna ekleme işlemi genellikle görevi oluşturan kişi tarafından yapılır\n    if (taskData.createdBy !== approvedBy) {\n      throw new Error(\"Sadece görevi havuza ekleyen kişi talepleri onaylayabilir\");\n    }\n    \n    // Kullanıcıyı göreve ata\n    const assignment = await assignTask(taskId, userId, approvedBy);\n\n    // Görev havuzu talebi onaylandığında görev otomatik olarak kabul edilir\n    // Assignment'ı direkt \"accepted\" olarak güncelle\n    const assignmentRef = doc(firestore, \"tasks\", taskId, \"assignments\", assignment.id);\n    await updateDoc(assignmentRef, {\n      status: \"accepted\",\n      acceptedAt: serverTimestamp() as any,\n    });\n\n    // Havuz durumunu güncelle\n    const updates: Partial<Task> & { poolRequests?: string[]; updatedAt?: FieldValue | Timestamp } = {\n      poolRequests: poolRequests.filter((id: string) => id !== userId), // Sadece onaylanan kullanıcıyı taleplerden çıkar\n      updatedAt: serverTimestamp() as any,\n    };\n\n    if (!keepInPool) {\n      updates.isInPool = false;\n      updates.poolRequests = []; // Havuzdan çıkıyorsa tüm talepleri temizle\n    }\n\n    await updateDoc(taskRef, updates);\n\n    // assignTask'ın gönderdiği bildirimi bulup güncelle - \"Talebiniz onaylandı, bu göreve atandınız\"\n    try {\n      const { getNotifications, updateNotification } = await import(\"./notificationService\");\n      const [task, approverProfile, notifications] = await Promise.all([\n        getTaskById(taskId),\n        getUserProfile(approvedBy),\n        getNotifications(userId, { limit: 10 }), // Son 10 bildirimi al\n      ]);\n\n      if (task) {\n        // assignTask'ın gönderdiği bildirimi bul (assignment_id ve relatedId ile eşleşen)\n        const assignmentNotification = notifications.find(\n          (n) => \n            n.type === \"task_assigned\" && \n            n.relatedId === taskId && \n            n.metadata?.assignment_id === assignment.id &&\n            !n.read\n        );\n\n        if (assignmentNotification) {\n          // Bildirimi güncelle\n          await updateNotification(assignmentNotification.id, {\n            title: \"Görev havuzu talebiniz onaylandı\",\n            message: `${approverProfile?.fullName || approverProfile?.email || \"Bir yönetici\"} kullanıcısı görev havuzu talebinizi onayladı. \"${task.title}\" görevine atandınız ve görev otomatik olarak kabul edildi.`,\n            metadata: {\n              ...assignmentNotification.metadata,\n              action: \"pool_request_approved\",\n            },\n          });\n        } else {\n          // Bildirim bulunamadıysa yeni bir bildirim gönder\n          await createNotification({\n            userId,\n            type: \"task_assigned\",\n            title: \"Görev havuzu talebiniz onaylandı\",\n            message: `${approverProfile?.fullName || approverProfile?.email || \"Bir yönetici\"} kullanıcısı görev havuzu talebinizi onayladı. \"${task.title}\" görevine atandınız ve görev otomatik olarak kabul edildi.`,\n            read: false,\n            relatedId: taskId,\n            metadata: { \n              assignment_id: assignment.id,\n              action: \"pool_request_approved\",\n              priority: task.priority,\n              dueDate: task.dueDate,\n              updatedAt: new Date(),\n            },\n          });\n        }\n      }\n    } catch (notifError) {\n      // Bildirim hatası kritik değil, sessizce devam et\n      if (import.meta.env.DEV) {\n        console.error(\"Error updating pool request approval notification:\", notifError);\n      }\n    }\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, approvedBy, { isInPool: true, poolRequests }, { isInPool: keepInPool, poolRequests: updates.poolRequests, assignedTo: userId });\n    await logAudit(\"UPDATE\", \"task_assignments\", assignment.id, approvedBy, { status: \"pending\" }, { status: \"accepted\", taskId: taskId, taskTitle: taskData.title });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Approve pool request error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev havuzu talebini reddet\n */\nexport const rejectPoolRequest = async (taskId: string, userId: string): Promise<void> => {\n  try {\n    const taskRef = doc(firestore, \"tasks\", taskId);\n    const taskSnap = await getDoc(taskRef);\n    \n    if (!taskSnap.exists()) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n    \n    const taskData = taskSnap.data();\n    const poolRequests = taskData.poolRequests || [];\n    \n    if (!poolRequests.includes(userId)) {\n      throw new Error(\"Bu kullanıcı için talep bulunamadı\");\n    }\n    \n    await updateDoc(taskRef, {\n      poolRequests: poolRequests.filter((id: string) => id !== userId),\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, auth?.currentUser?.uid || \"system\", { poolRequests }, { poolRequests: poolRequests.filter((id: string) => id !== userId), rejectedUser: userId });\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Reject pool request error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev onay isteği gönder (completed → pending approval)\n * ÖNEMLİ: Sadece göreve atanan kullanıcılar onaya gönderebilir\n */\nexport const requestTaskApproval = async (taskId: string, requestedBy: string): Promise<void> => {\n  try {\n    // Önce görevi ve atamaları kontrol et\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    // Eğer zaten onay bekleniyorsa, tekrar bildirim gönderme\n    if (task.approvalStatus === \"pending\") {\n      // Zaten pending durumunda, sadece güncelleme yapma\n      return;\n    }\n\n    // Eğer zaten onaylandıysa, hata fırlat\n    if (task.approvalStatus === \"approved\") {\n      throw new Error(\"Bu görev zaten onaylanmış.\");\n    }\n\n    // Kullanıcı profilini al (admin kontrolü için)\n    const requesterProfile = await getUserProfile(requestedBy);\n    if (!requesterProfile) {\n      throw new Error(\"Kullanıcı profili bulunamadı\");\n    }\n\n    // Admin kontrolü - adminler her zaman onaya gönderebilir\n    const { isAdmin: checkIsAdmin, isMainAdmin } = await import(\"@/utils/permissions\");\n    const isAdmin = await checkIsAdmin(requesterProfile) || await isMainAdmin(requesterProfile);\n    \n    // Eğer admin değilse, göreve atanmış olup olmadığını kontrol et\n    if (!isAdmin) {\n      const assignments = await getTaskAssignments(taskId);\n      const assignedUserIds = assignments\n        .filter(a => a.status === \"accepted\") // Sadece kabul edilen atamalar\n        .map(a => a.assignedTo);\n      \n      const isAssigned = assignedUserIds.includes(requestedBy);\n      \n      if (!isAssigned) {\n        throw new Error(\"Bu görevi onaya göndermek için yetkiniz yok. Sadece size atanan görevleri onaya gönderebilirsiniz.\");\n      }\n    }\n\n    // Görev oluşturan kişi direkt tamamlayabilir, onaya göndermesine gerek yok\n    // Ama eğer zaten onaya gönderiyorsa, bu durumda izin ver (belki bir hata durumu)\n    \n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      approvalStatus: \"pending\",\n      approvalRequestedBy: requestedBy,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log for approval request\n    await logAudit(\"UPDATE\", \"tasks\", taskId, requestedBy, { approvalStatus: task.approvalStatus || \"none\" }, { approvalStatus: \"pending\" });\n\n    // Görev sahibine (yöneticiye) bildirim gönder - sadece duplicate kontrolü ile\n    try {\n      if (task && task.createdBy) {\n        // Aynı türde ve aynı görev için okunmamış bildirim var mı kontrol et\n        let duplicateExists = false;\n        try {\n          const { getNotifications } = await import(\"./notificationService\");\n          const existingNotifications = await getNotifications(task.createdBy, { unreadOnly: true });\n          duplicateExists = existingNotifications.some(\n            n => n.type === \"task_approval\" && \n                 n.relatedId === taskId && \n                 n.metadata?.action === \"approval_requested\"\n          );\n        } catch (getNotifError) {\n          // Index hatası veya başka bir hata - duplicate kontrolünü atla ve bildirim oluşturmayı dene\n          if (import.meta.env.DEV) {\n            console.warn(\"Bildirim duplicate kontrolü yapılamadı, bildirim oluşturulacak:\", getNotifError);\n          }\n          duplicateExists = false; // Hata durumunda duplicate kontrolünü atla\n        }\n\n        if (!duplicateExists) {\n          try {\n            await createNotification({\n              userId: task.createdBy,\n              type: \"task_approval\",\n              title: \"Görev onayı bekleniyor\",\n              message: `${requesterProfile?.fullName || requesterProfile?.email || \"Bir kullanıcı\"} kullanıcısı \"${task.title}\" görevini tamamladı ve onayınızı bekliyor.\\n\\n\"${task.title}\" başlıklı görev için onay talebi gönderildi. Lütfen görevi inceleyip onaylayın veya gerekirse geri gönderin.\\n\\nİşlem Zamanı: ${new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' })}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                action: \"approval_requested\",\n                updatedAt: new Date(),\n                priority: task.priority,\n                dueDate: task.dueDate,\n              },\n            });\n          } catch (createNotifError) {\n            // Bildirim oluşturma hatası (email CORS hatası vb.) - kritik değil, sadece logla\n            if (import.meta.env.DEV) {\n              console.warn(\"Bildirim oluşturulamadı (email hatası vb. kritik değil):\", createNotifError);\n            }\n          }\n        }\n      }\n    } catch (notifError) {\n      // Genel bildirim hatası - kritik değil, sadece logla\n      if (import.meta.env.DEV) {\n        console.warn(\"Bildirim gönderme hatası (kritik değil):\", notifError);\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Request task approval error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev onayını onayla - Onaylandığında \"Onaylandı\" (approved) durumuna geçer ve status \"completed\" olur\n * Sadece yönetici veya görevi veren ekip lideri onaylayabilir\n */\nexport const approveTask = async (taskId: string, approvedBy: string): Promise<void> => {\n  try {\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    // Eğer zaten onaylandıysa, hata fırlat\n    if (task.approvalStatus === \"approved\") {\n      throw new Error(\"Bu görev zaten onaylanmış. Tekrar onaylanamaz.\");\n    }\n\n    // Eğer onay beklenmiyorsa, hata fırlat\n    if (task.approvalStatus !== \"pending\") {\n      throw new Error(\"Bu görev onay beklenmiyor.\");\n    }\n\n    // Yetki kontrolü: Sadece yönetici veya görevi veren ekip lideri onaylayabilir\n    const approverProfile = await getUserProfile(approvedBy);\n    if (!approverProfile) {\n      throw new Error(\"Kullanıcı profili bulunamadı\");\n    }\n\n    const { isAdmin: checkIsAdmin, isMainAdmin } = await import(\"@/utils/permissions\");\n    const isAdmin = await checkIsAdmin(approverProfile) || await isMainAdmin(approverProfile);\n    const isTeamLeader = approverProfile.role?.includes(\"team_leader\");\n    const isCreator = task.createdBy === approvedBy;\n\n    // Yönetici veya görevi veren ekip lideri onaylayabilir\n    // Ekip lideri kontrolü için role_permissions sisteminden kontrol et\n    const { canPerformSubPermission } = await import(\"@/utils/permissions\");\n    const canApprove = await canPerformSubPermission(approverProfile, \"tasks\", \"canApprove\");\n    const hasTeamLeaderPermission = isTeamLeader && (canApprove || isCreator);\n\n    if (!isAdmin && !hasTeamLeaderPermission) {\n      throw new Error(\"Bu görevi onaylamak için yetkiniz yok. Sadece yöneticiler veya görevi veren ekip liderleri onaylayabilir.\");\n    }\n\n    const oldStatus = task.status;\n    const currentUser = auth?.currentUser;\n\n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      approvalStatus: \"approved\",\n      status: \"completed\", // Onaylanınca \"Tamamlandı\" durumuna geçer\n      approvedBy: approvedBy,\n      approvedAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    });\n\n    // Status değiştiyse güncelleyen bilgisi ekle\n    if (oldStatus !== \"completed\" && currentUser?.uid) {\n      await updateDoc(doc(firestore, \"tasks\", taskId), {\n        statusUpdatedBy: currentUser.uid,\n        statusUpdatedAt: serverTimestamp(),\n      });\n    }\n\n    // Audit log for approval\n    await logAudit(\"UPDATE\", \"tasks\", taskId, approvedBy, { approvalStatus: \"pending\", status: oldStatus }, { approvalStatus: \"approved\", status: \"completed\" });\n\n    // Onay isteyene ve atanan kişilere bildirim gönder\n    try {\n      const updatedTask = await getTaskById(taskId);\n      const approverProfile = await getUserProfile(approvedBy);\n      const approverName = approverProfile?.fullName || approverProfile?.email || \"Yönetici\";\n      \n      // Atanan kişileri bul\n      const assignments = await getTaskAssignments(taskId);\n      const assignedUserIds = assignments\n        .filter(a => a.status === \"accepted\") // Sadece kabul edilen atamalar\n        .map(a => a.assignedTo);\n      \n      // Bildirim gönderilecek kullanıcıları topla\n      const notificationUserIds = new Set<string>();\n      \n      // Onay isteyen kişiye bildirim gönder\n      if (updatedTask && updatedTask.approvalRequestedBy) {\n        notificationUserIds.add(updatedTask.approvalRequestedBy);\n      }\n      \n      // Atanan kişilere bildirim gönder\n      assignedUserIds.forEach(userId => {\n        if (userId !== updatedTask?.approvalRequestedBy) {\n          notificationUserIds.add(userId);\n        }\n      });\n      \n      // Her kullanıcıya bildirim gönder\n      const { getNotifications } = await import(\"./notificationService\");\n      \n      for (const userId of notificationUserIds) {\n        try {\n          // Duplicate kontrolü - index hatası durumunda sessizce devam et\n          let existingNotifications: any[] = [];\n          try {\n            existingNotifications = await getNotifications(userId, { unreadOnly: true });\n          } catch (notifError) {\n            // Index hatası veya diğer hatalar - sessizce devam et\n            // getNotifications zaten boş array döndürüyor, burada da sessizce handle et\n            if (import.meta.env.DEV) {\n              // Sadece gerçek hataları logla (index hatası değilse)\n              const isIndexError = \n                typeof notifError === \"object\" &&\n                notifError !== null &&\n                \"code\" in notifError &&\n                (notifError as { code?: string }).code === \"failed-precondition\";\n              if (!isIndexError) {\n                console.debug(\"Get notifications error in approveTask:\", notifError);\n              }\n            }\n          }\n          \n          const duplicateExists = existingNotifications.some(\n            n => n.type === \"task_approval\" && \n                 n.relatedId === taskId && \n                 n.metadata?.action === \"approved\"\n          );\n\n          if (!duplicateExists) {\n            const approvalTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n            await createNotification({\n              userId: userId,\n              type: \"task_approval\",\n              title: \"Görev onaylandı\",\n              message: `${approverName} kullanıcısı tarafından \"${updatedTask?.title || \"görev\"}\" görevi onaylandı ve \"Onaylandı\" durumuna geçirildi.\\n\\nGörev başarıyla onaylanmış olarak işaretlendi. Tüm görev üyeleri bu durumu görebilir.\\n\\nOnay Zamanı: ${approvalTime}`,\n              read: false,\n              relatedId: taskId,\n              metadata: { \n                action: \"approved\",\n                updatedAt: new Date(),\n                priority: updatedTask?.priority,\n                dueDate: updatedTask?.dueDate,\n              },\n            });\n          }\n        } catch (userNotifError) {\n          console.error(`Error sending notification to user ${userId}:`, userNotifError);\n        }\n      }\n    } catch (notifError) {\n      console.error(\"Error sending approval notification:\", notifError);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Approve task error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev onayını reddet - Reddedildiğinde \"Devam Ediyor\" (in_progress) durumuna döner\n */\nexport const rejectTaskApproval = async (taskId: string, rejectedBy: string, rejectionReason?: string | null): Promise<void> => {\n  try {\n    const task = await getTaskById(taskId);\n    if (!task) {\n      throw new Error(\"Görev bulunamadı\");\n    }\n\n    const oldStatus = task.status;\n    const currentUser = auth?.currentUser;\n\n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      approvalStatus: \"rejected\",\n      status: \"in_progress\", // Reddedilince \"Devam Ediyor\" durumuna döner\n      rejectedBy: rejectedBy,\n      rejectedAt: serverTimestamp(),\n      rejectionReason: rejectionReason || null,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Status değiştiyse güncelleyen bilgisi ekle\n    if (oldStatus !== \"in_progress\" && currentUser?.uid) {\n      await updateDoc(doc(firestore, \"tasks\", taskId), {\n        statusUpdatedBy: currentUser.uid,\n        statusUpdatedAt: serverTimestamp(),\n      });\n    }\n\n    // Audit log for rejection\n    await logAudit(\"UPDATE\", \"tasks\", taskId, rejectedBy, { approvalStatus: \"pending\", status: oldStatus }, { approvalStatus: \"rejected\", status: \"in_progress\", rejectionReason });\n\n    // Görevdeki tüm kişilere (atananlar, görev oluşturan, onay isteyen) bildirim gönder\n    try {\n      const task = await getTaskById(taskId);\n      const rejecterProfile = await getUserProfile(rejectedBy);\n      \n      if (task) {\n        const assignments = await getTaskAssignments(taskId);\n        // Statusu rejected olmayan tüm atanmış kullanıcıları al\n        const assignedUserIds = assignments\n          .filter(a => a.status !== \"rejected\")\n          .map(a => a.assignedTo);\n        \n        // Görevdeki tüm kişileri topla (atananlar + görev oluşturan + onay isteyen)\n        const allTaskUserIds = new Set<string>();\n        \n        // Atanan kullanıcıları ekle\n        assignedUserIds.forEach(id => allTaskUserIds.add(id));\n        \n        // Görev oluşturan kişiyi ekle (eğer varsa ve listede yoksa)\n        if (task.createdBy && !allTaskUserIds.has(task.createdBy)) {\n          allTaskUserIds.add(task.createdBy);\n        }\n        \n        // Onay isteyen kişiyi ekle (eğer varsa ve listede yoksa)\n        if (task.approvalRequestedBy && !allTaskUserIds.has(task.approvalRequestedBy)) {\n          allTaskUserIds.add(task.approvalRequestedBy);\n        }\n        \n        const rejectionMessage = rejectionReason \n          ? `${rejecterProfile?.fullName || rejecterProfile?.email || \"Yönetici\"} \"${task.title}\" görevi için tamamlanma onayını reddetti. Not: ${rejectionReason}`\n          : `${rejecterProfile?.fullName || rejecterProfile?.email || \"Yönetici\"} \"${task.title}\" görevi için tamamlanma onayını reddetti.`;\n        \n        // Görevdeki tüm kişilere bildirim gönder (her biri mail alacak - createNotification otomatik mail gönderir)\n        await Promise.all(\n          Array.from(allTaskUserIds).map(async (userId) => {\n            try {\n              const rejectTime3 = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n              const detailedRejectionMessage = rejectionReason \n                ? `${rejecterProfile?.fullName || rejecterProfile?.email || \"Yönetici\"} kullanıcısı tarafından \"${task.title}\" görevi için tamamlanma onayı reddedildi.\\n\\nReddetme Notu: ${rejectionReason}\\n\\nGörev tekrar \"Devam Ediyor\" durumuna alındı. Lütfen gerekli düzeltmeleri yapıp tekrar onay talebi gönderin.\\n\\nReddetme Zamanı: ${rejectTime3}`\n                : `${rejecterProfile?.fullName || rejecterProfile?.email || \"Yönetici\"} kullanıcısı tarafından \"${task.title}\" görevi için tamamlanma onayı reddedildi.\\n\\nGörev tekrar \"Devam Ediyor\" durumuna alındı. Lütfen gerekli düzeltmeleri yapıp tekrar onay talebi gönderin.\\n\\nReddetme Zamanı: ${rejectTime3}`;\n              await createNotification({\n                userId: userId,\n                type: \"task_approval\",\n                title: \"Görev onayı reddedildi\",\n                message: detailedRejectionMessage,\n                read: false,\n                relatedId: taskId,\n                metadata: { \n                  action: \"rejected\", \n                  rejectionReason,\n                  updatedAt: new Date(),\n                  priority: task.priority,\n                  dueDate: task.dueDate,\n                },\n              });\n            } catch (notifError) {\n              if (import.meta.env.DEV) {\n                console.error(\"Error sending notification to task user:\", userId, notifError);\n              }\n            }\n          })\n        );\n      }\n    } catch (notifError) {\n      if (import.meta.env.DEV) {\n        console.error(\"Error sending rejection notification:\", notifError);\n      }\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Reject task approval error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev reddi onayla (görevi veren kişi reddi kabul eder)\n */\nexport const approveTaskRejection = async (\n  taskId: string,\n  assignmentId: string\n): Promise<void> => {\n  try {\n    const userId = auth?.currentUser?.uid;\n    if (!userId) {\n      throw new Error(\"Kullanıcı kimliği bulunamadı\");\n    }\n\n    const assignmentRef = doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId);\n    const assignmentDoc = await getDoc(assignmentRef);\n    \n    if (!assignmentDoc.exists()) {\n      throw new Error(\"Görev ataması bulunamadı\");\n    }\n\n    const assignmentData = assignmentDoc.data() as TaskAssignment;\n    \n    if (assignmentData.status !== \"rejected\") {\n      throw new Error(\"Görev reddedilmemiş\");\n    }\n\n    // Reddi onayla\n    await updateDoc(assignmentRef, {\n      rejectionApprovedBy: userId,\n      rejectionApprovedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    const task = await getTaskById(taskId);\n    await logAudit(\n      \"UPDATE\",\n      \"task_assignments\",\n      assignmentId,\n      userId,\n      { rejectionApprovedBy: null },\n      { rejectionApprovedBy: userId, taskId, taskTitle: task?.title }\n    );\n\n    // Bildirim gönder\n    try {\n      const allUsers = await getAllUsers();\n      const assignedUser = allUsers.find(u => u.id === assignmentData.assignedTo);\n      const approverUser = allUsers.find(u => u.id === userId);\n\n      if (assignedUser) {\n        const approvalTime2 = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n        await createNotification({\n          userId: assignmentData.assignedTo,\n          type: \"task_assigned\",\n          title: \"Görev reddi onaylandı\",\n          message: `${approverUser?.fullName || approverUser?.email || \"Yönetici\"} kullanıcısı tarafından \"${task?.title}\" görevi için reddiniz onaylandı.\\n\\nGörev artık başka birine atanabilir veya iptal edilebilir. Bu görevle ilgili artık bildirim almayacaksınız.\\n\\nOnay Zamanı: ${approvalTime2}`,\n          read: false,\n          relatedId: taskId,\n          metadata: { \n            assignment_id: assignmentId, \n            action: \"rejection_approved\",\n            updatedAt: new Date(),\n            priority: task?.priority,\n            dueDate: task?.dueDate,\n          },\n        });\n      }\n    } catch (notifError) {\n      console.error(\"Error sending approval notification:\", notifError);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Approve task rejection error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev reddi reddet (görevi veren kişi reddi reddeder, görev tekrar atanan kişiye döner)\n */\nexport const rejectTaskRejection = async (\n  taskId: string,\n  assignmentId: string,\n  reason: string\n): Promise<void> => {\n  try {\n    const userId = auth?.currentUser?.uid;\n    if (!userId) {\n      throw new Error(\"Kullanıcı kimliği bulunamadı\");\n    }\n\n    // Red sebebi en az 20 karakter olmalı\n    if (reason.trim().length < 20) {\n      throw new Error(\"Red sebebi en az 20 karakter olmalıdır\");\n    }\n\n    const assignmentRef = doc(firestore, \"tasks\", taskId, \"assignments\", assignmentId);\n    const assignmentDoc = await getDoc(assignmentRef);\n    \n    if (!assignmentDoc.exists()) {\n      throw new Error(\"Görev ataması bulunamadı\");\n    }\n\n    const assignmentData = assignmentDoc.data() as TaskAssignment;\n    \n    if (assignmentData.status !== \"rejected\") {\n      throw new Error(\"Görev reddedilmemiş\");\n    }\n\n    // Reddi reddet - görevi tekrar pending durumuna getir\n    await updateDoc(assignmentRef, {\n      status: \"pending\",\n      rejectionRejectedBy: userId,\n      rejectionRejectedAt: serverTimestamp(),\n      rejectionRejectionReason: reason.trim(),\n      rejectionReason: null, // İlk red sebebini temizle (yeni red sebebi için)\n    });\n\n    // Audit log\n    const task = await getTaskById(taskId);\n    await logAudit(\n      \"UPDATE\",\n      \"task_assignments\",\n      assignmentId,\n      userId,\n      { status: \"rejected\" },\n      { \n        status: \"pending\", \n        rejectionRejectedBy: userId,\n        rejectionRejectionReason: reason.trim(),\n        taskId, \n        taskTitle: task?.title \n      }\n    );\n\n    // Bildirim gönder - görevi alan kişiye\n    try {\n      const allUsers = await getAllUsers();\n      const assignedUser = allUsers.find(u => u.id === assignmentData.assignedTo);\n      const rejecterUser = allUsers.find(u => u.id === userId);\n\n      if (assignedUser) {\n        const rejectionTime = new Date().toLocaleString('tr-TR', { day: 'numeric', month: 'long', year: 'numeric', hour: '2-digit', minute: '2-digit' });\n        await createNotification({\n          userId: assignmentData.assignedTo,\n          type: \"task_assigned\",\n          title: \"Görev reddi reddedildi\",\n          message: `${rejecterUser?.fullName || rejecterUser?.email || \"Yönetici\"} kullanıcısı tarafından \"${task?.title}\" görevi için reddiniz reddedildi.\\n\\nGörev tekrar size atandı ve üzerinde çalışmaya devam etmeniz bekleniyor.\\n\\nYönetici Notu: ${reason.trim().substring(0, 200)}${reason.trim().length > 200 ? \"...\" : \"\"}\\n\\nReddetme Zamanı: ${rejectionTime}`,\n          read: false,\n          relatedId: taskId,\n          metadata: { \n            assignment_id: assignmentId, \n            action: \"rejection_rejected\",\n            reason: reason.trim()\n          },\n        });\n      }\n    } catch (notifError) {\n      console.error(\"Error sending rejection notification:\", notifError);\n    }\n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Reject task rejection error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görev düzenleme yetkisi kontrolü\n */\nexport const canEditTask = (task: Task, userId: string): boolean => {\n  return task.createdBy === userId;\n};\n\n/**\n * Görevi arşivle\n */\nexport const archiveTask = async (taskId: string, userId: string): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      isArchived: true,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, userId, { isArchived: false }, { isArchived: true });\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Archive task error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Görevi arşivden çıkar\n */\nexport const unarchiveTask = async (taskId: string, userId: string): Promise<void> => {\n  try {\n    await updateDoc(doc(firestore, \"tasks\", taskId), {\n      isArchived: false,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Audit log\n    await logAudit(\"UPDATE\", \"tasks\", taskId, userId, { isArchived: true }, { isArchived: false });\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Unarchive task error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Kullanıcıyı tüm görevlerden çıkar ve eğer göreve kimse kalmamışsa havuza al\n */\nexport const removeUserFromAllTasks = async (userId: string): Promise<void> => {\n  try {\n    // Kullanıcının atandığı tüm görevleri bul\n    const tasksRef = collection(firestore, \"tasks\");\n    const allTasksSnapshot = await getDocs(tasksRef);\n    \n    let batch = writeBatch(firestore);\n    let batchCount = 0;\n    const maxBatchSize = 500;\n    \n    for (const taskDoc of allTasksSnapshot.docs) {\n      const taskData = taskDoc.data();\n      const taskId = taskDoc.id;\n      \n      // assignedUsers array'inden kullanıcıyı çıkar\n      const assignedUsers = taskData.assignedUsers || [];\n      if (assignedUsers.includes(userId)) {\n        const updatedAssignedUsers = assignedUsers.filter((uid: string) => uid !== userId);\n        \n        // Eğer göreve kimse kalmamışsa havuza al\n        const shouldMoveToPool = updatedAssignedUsers.length === 0;\n        \n        const updates: Partial<Task> & { assignedUsers?: string[]; isInPool?: boolean; poolRequests?: string[] } = {\n          assignedUsers: updatedAssignedUsers,\n        };\n        \n        if (shouldMoveToPool) {\n          updates.isInPool = true;\n          updates.poolRequests = [];\n        }\n        \n        batch.update(taskDoc.ref, updates);\n        batchCount++;\n        \n        // Batch size limit\n        if (batchCount >= maxBatchSize) {\n          await batch.commit();\n          batchCount = 0;\n          // Yeni batch oluştur\n          batch = writeBatch(firestore);\n        }\n      }\n      \n      // Task assignments collection'ından kullanıcının atamalarını sil\n      const assignmentsRef = collection(firestore, `tasks/${taskId}/assignments`);\n      const assignmentsSnapshot = await getDocs(\n        query(assignmentsRef, where(\"assignedTo\", \"==\", userId))\n      );\n      \n      for (const assignmentDoc of assignmentsSnapshot.docs) {\n        batch.delete(assignmentDoc.ref);\n        batchCount++;\n        \n        if (batchCount >= maxBatchSize) {\n          await batch.commit();\n          batchCount = 0;\n          // Yeni batch oluştur\n          batch = writeBatch(firestore);\n        }\n      }\n    }\n    \n    // Kalan batch'i commit et\n    if (batchCount > 0) {\n      await batch.commit();\n    }\n    \n    // Kullanıcının oluşturduğu görevlerin createdBy'sini \"deleted_user\" olarak güncelle\n    const createdTasksSnapshot = await getDocs(\n      query(tasksRef, where(\"createdBy\", \"==\", userId))\n    );\n    \n    let updateBatch = writeBatch(firestore);\n    let updateBatchCount = 0;\n    \n    for (const taskDoc of createdTasksSnapshot.docs) {\n      updateBatch.update(taskDoc.ref, {\n        createdBy: \"deleted_user\",\n        createdByName: \"Silinmiş Kullanıcı\",\n      });\n      updateBatchCount++;\n      \n      if (updateBatchCount >= maxBatchSize) {\n        await updateBatch.commit();\n        updateBatchCount = 0;\n        // Yeni batch oluştur\n        updateBatch = writeBatch(firestore);\n      }\n    }\n    \n    if (updateBatchCount > 0) {\n      await updateBatch.commit();\n    }\n    \n  } catch (error: unknown) {\n    if (import.meta.env.DEV) {\n      console.error(\"Error removing user from tasks:\", error);\n    }\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\teamApprovalService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":64,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1747,1750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1747,1750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":129,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3856,3859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3856,3859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":357,"column":72,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":357,"endColumn":75,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11468,11471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11468,11471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-const","severity":2,"message":"'requests' is never reassigned. Use 'const' instead.","line":362,"column":15,"nodeType":"Identifier","messageId":"useConst","endLine":362,"endColumn":46,"fix":{"range":[11589,11630],"text":"const requests: TeamApprovalRequest[] = [];"}}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"/**\n * Team Approval Service\n * Ekip onay işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  updateDoc,\n  query,\n  where,\n  serverTimestamp,\n  Timestamp,\n  onSnapshot,\n  Unsubscribe,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { getUserProfile, getAllUsers, UserProfile } from \"./authService\";\nimport { getDepartmentById, Department, getDepartments } from \"./departmentService\";\nimport { createNotification } from \"./notificationService\";\n\nexport interface TeamApprovalRequest {\n  userId: string;\n  userName: string;\n  userEmail: string;\n  teamId: string;\n  teamName: string;\n  requestedAt: Timestamp;\n  status: \"pending\" | \"approved\" | \"rejected\";\n  approvedBy?: string;\n  approvedAt?: Timestamp;\n  rejectedReason?: string;\n}\n\n/**\n * Onay bekleyen ekip taleplerini al (ekip lideri için)\n */\nexport const getPendingTeamRequests = async (teamLeaderId: string): Promise<TeamApprovalRequest[]> => {\n  try {\n    // Ekip liderinin yönettiği ekipleri bul\n    const departmentsRef = collection(firestore, \"departments\");\n    const departmentsQuery = query(departmentsRef, where(\"managerId\", \"==\", teamLeaderId));\n    const departmentsSnapshot = await getDocs(departmentsQuery);\n    \n    const teamIds = departmentsSnapshot.docs.map(doc => doc.id);\n    \n    if (teamIds.length === 0) {\n      return [];\n    }\n\n    // Bu ekiplere ait onay bekleyen kullanıcıları bul\n    const allUsers = await getAllUsers();\n    \n    const requests: TeamApprovalRequest[] = [];\n    \n    for (const user of allUsers) {\n      // Silinen veya geçersiz kullanıcıları atla\n      if (!user || !user.id || !user.email) {\n        continue;\n      }\n      // Silinmiş kullanıcıları atla (deleted flag kontrolü)\n      if ((user as any).deleted === true) {\n        continue;\n      }\n      if (user.pendingTeams && user.pendingTeams.length > 0) {\n        for (const teamId of user.pendingTeams) {\n          if (teamIds.includes(teamId)) {\n            const team = await getDepartmentById(teamId);\n            if (team) {\n              requests.push({\n                userId: user.id,\n                userName: user.fullName || user.displayName || user.email,\n                userEmail: user.email,\n                teamId: teamId,\n                teamName: team.name,\n                requestedAt: user.createdAt || Timestamp.now(),\n                status: \"pending\",\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    return requests.sort((a, b) => {\n      const aTime = a.requestedAt?.toMillis() || 0;\n      const bTime = b.requestedAt?.toMillis() || 0;\n      return bTime - aTime;\n    });\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get pending team requests error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Ana yöneticiler için tüm onay bekleyen talepleri al\n * Sadece ekip lideri olmayan (managerId yok veya null olan) ekiplerin taleplerini gösterir\n */\nexport const getAllPendingTeamRequests = async (): Promise<TeamApprovalRequest[]> => {\n  try {\n    // Tüm departmanları al\n    const departmentsRef = collection(firestore, \"departments\");\n    const departmentsSnapshot = await getDocs(departmentsRef);\n    \n    // Ekip lideri olan ekipleri bul (managerId var ve null değil)\n    const teamsWithLeader = new Set<string>();\n    departmentsSnapshot.docs.forEach(doc => {\n      const data = doc.data();\n      if (data.managerId && data.managerId.trim() !== '') {\n        teamsWithLeader.add(doc.id);\n      }\n    });\n    \n    // Tüm kullanıcıları al\n    const allUsers = await getAllUsers();\n    const requests: TeamApprovalRequest[] = [];\n    \n    for (const user of allUsers) {\n      // Silinen veya geçersiz kullanıcıları atla\n      if (!user || !user.id || !user.email) {\n        continue;\n      }\n      // Silinmiş kullanıcıları atla (deleted flag kontrolü)\n      if ((user as any).deleted === true) {\n        continue;\n      }\n      if (user.pendingTeams && user.pendingTeams.length > 0) {\n        for (const teamId of user.pendingTeams) {\n          // Sadece ekip lideri olmayan ekiplerin taleplerini ekle\n          if (!teamsWithLeader.has(teamId)) {\n            const team = await getDepartmentById(teamId);\n            if (team) {\n              requests.push({\n                userId: user.id,\n                userName: user.fullName || user.displayName || user.email,\n                userEmail: user.email,\n                teamId: teamId,\n                teamName: team.name,\n                requestedAt: user.createdAt || Timestamp.now(),\n                status: \"pending\",\n              });\n            }\n          }\n        }\n      }\n    }\n    \n    return requests.sort((a, b) => {\n      const aTime = a.requestedAt?.toMillis() || 0;\n      const bTime = b.requestedAt?.toMillis() || 0;\n      return bTime - aTime;\n    });\n  } catch (error) {\n    console.error(\"Get all pending team requests error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Ekip talebini onayla\n */\nexport const approveTeamRequest = async (\n  userId: string,\n  teamId: string,\n  approvedBy: string\n): Promise<void> => {\n  try {\n    // Yetki kontrolü: Firestore'dan kontrol et\n    const { getUserProfile } = await import(\"./authService\");\n    const approverProfile = await getUserProfile(approvedBy);\n    if (approverProfile) {\n      const { canApproveTeamRequest } = await import(\"@/utils/permissions\");\n      const departments = await getDepartments();\n      const canApprove = await canApproveTeamRequest(approverProfile, departments);\n      if (!canApprove) {\n        throw new Error(\"Ekip talebi onaylama yetkiniz yok.\");\n      }\n    }\n    const userRef = doc(firestore, \"users\", userId);\n    const userDoc = await getDoc(userRef);\n    \n    if (!userDoc.exists()) {\n      throw new Error(\"Kullanıcı bulunamadı\");\n    }\n    \n    const userData = userDoc.data() as UserProfile;\n    const pendingTeams = userData.pendingTeams || [];\n    const approvedTeams = userData.approvedTeams || [];\n    const currentRoles = userData.role || [];\n    \n    // Ekip pendingTeams'den çıkar ve approvedTeams'e ekle\n    // Eğer talep zaten onaylanmış veya reddedilmişse (pendingTeams'de yoksa), sessizce başarılı dön\n    if (!pendingTeams.includes(teamId)) {\n      // Talep zaten onaylanmış olabilir, kontrol et\n      if (approvedTeams.includes(teamId)) {\n        // Talep zaten onaylanmış, sessizce başarılı dön\n        return;\n      }\n      // Talep bulunamadı - muhtemelen zaten işlenmiş veya kaldırılmış\n      throw new Error(\"Bu ekip talebi bulunamadı. Talep zaten işlenmiş olabilir.\");\n    }\n    \n    const updatedPendingTeams = pendingTeams.filter(id => id !== teamId);\n    const updatedApprovedTeams = [...approvedTeams, teamId];\n    \n    // Eğer kullanıcının rolü \"viewer\" (izleyici) ise, \"personnel\" (personel) olarak güncelle\n    let updatedRoles = [...currentRoles];\n    if (currentRoles.includes(\"viewer\") && !currentRoles.includes(\"personnel\")) {\n      // viewer rolünü kaldır ve personnel ekle\n      updatedRoles = currentRoles.filter((r: string) => r !== \"viewer\");\n      if (!updatedRoles.includes(\"personnel\")) {\n        updatedRoles.push(\"personnel\");\n      }\n      // Eğer hiç rol kalmadıysa, en azından personnel olsun\n      if (updatedRoles.length === 0) {\n        updatedRoles = [\"personnel\"];\n      }\n    }\n    \n    await updateDoc(userRef, {\n      pendingTeams: updatedPendingTeams,\n      approvedTeams: updatedApprovedTeams,\n      role: updatedRoles,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Kullanıcıya bildirim gönder\n    try {\n      const team = await getDepartmentById(teamId);\n      const approverProfile = await getUserProfile(approvedBy);\n      const approverName = approverProfile?.fullName || approverProfile?.displayName || approverProfile?.email || \"Yönetici\";\n      \n      await createNotification({\n        userId: userId,\n        type: \"system\",\n        title: \"Ekip talebi onaylandı\",\n        message: `${approverName} \"${team?.name || \"ekip\"}\" ekibine katılım talebinizi onayladı.`,\n        read: false,\n        metadata: {\n          teamId: teamId,\n          teamName: team?.name,\n          approvedBy: approvedBy,\n        },\n      });\n    } catch (notifError) {\n      console.error(\"Error sending approval notification:\", notifError);\n      // Bildirim hatası onay işlemini engellemez\n    }\n  } catch (error) {\n    console.error(\"Approve team request error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Ekip talebini reddet\n */\nexport const rejectTeamRequest = async (\n  userId: string,\n  teamId: string,\n  rejectedReason?: string,\n  rejectedBy?: string\n): Promise<void> => {\n  try {\n    // Yetki kontrolü: Firestore'dan kontrol et\n    if (rejectedBy) {\n      const { getUserProfile } = await import(\"./authService\");\n      const rejecterProfile = await getUserProfile(rejectedBy);\n      if (rejecterProfile) {\n        const { canApproveTeamRequest, getDepartments } = await import(\"@/utils/permissions\");\n        const departments = await getDepartments();\n        const canApprove = await canApproveTeamRequest(rejecterProfile, departments);\n        if (!canApprove) {\n          throw new Error(\"Ekip talebi reddetme yetkiniz yok.\");\n        }\n      }\n    }\n    const userRef = doc(firestore, \"users\", userId);\n    const userDoc = await getDoc(userRef);\n    \n    if (!userDoc.exists()) {\n      throw new Error(\"Kullanıcı bulunamadı\");\n    }\n    \n    const userData = userDoc.data() as UserProfile;\n    const pendingTeams = userData.pendingTeams || [];\n    \n    // Ekip pendingTeams'den çıkar\n    if (!pendingTeams.includes(teamId)) {\n      throw new Error(\"Bu ekip talebi bulunamadı\");\n    }\n    \n    const updatedPendingTeams = pendingTeams.filter(id => id !== teamId);\n    \n    await updateDoc(userRef, {\n      pendingTeams: updatedPendingTeams,\n      updatedAt: serverTimestamp(),\n    });\n\n    // Kullanıcıya bildirim gönder\n    try {\n      const team = await getDepartmentById(teamId);\n      \n      await createNotification({\n        userId: userId,\n        type: \"system\",\n        title: \"Ekip talebi reddedildi\",\n        message: `\"${team?.name || \"ekip\"}\" ekibine katılım talebiniz reddedildi.${rejectedReason ? ` Sebep: ${rejectedReason}` : \"\"}`,\n        read: false,\n        metadata: {\n          teamId: teamId,\n          teamName: team?.name,\n          rejectedReason: rejectedReason,\n        },\n      });\n    } catch (notifError) {\n      console.error(\"Error sending rejection notification:\", notifError);\n      // Bildirim hatası red işlemini engellemez\n    }\n  } catch (error) {\n    console.error(\"Reject team request error:\", error);\n    throw error;\n  }\n};\n\n/**\n * Katılım isteklerini gerçek zamanlı olarak dinle\n * @param isAdmin Admin mi?\n * @param teamLeaderId Ekip lideri ID'si (admin değilse)\n * @param callback İstekler değiştiğinde çağrılacak callback\n * @returns Unsubscribe fonksiyonu\n */\nexport const subscribeToTeamRequests = (\n  isAdmin: boolean,\n  teamLeaderId: string | null,\n  callback: (requests: TeamApprovalRequest[]) => void\n): Unsubscribe => {\n  try {\n    const usersRef = collection(firestore, \"users\");\n    \n    // Tüm kullanıcıları dinle (pendingTeams alanı olanları filtreleyeceğiz)\n    const unsubscribe = onSnapshot(\n      usersRef,\n      async (snapshot) => {\n        try {\n          // Tüm kullanıcıları al\n          const allUsers = snapshot.docs\n            .map(doc => ({\n              id: doc.id,\n              ...doc.data(),\n            } as UserProfile))\n            .filter(user => user && user.id && user.email && !(user as any).deleted);\n\n          // Departmanları al\n          const departments = await getDepartments();\n          \n          let requests: TeamApprovalRequest[] = [];\n\n          if (isAdmin) {\n            // Admin için: Ekip lideri olmayan ekiplerin taleplerini göster\n            const teamsWithLeader = new Set<string>();\n            departments.forEach(dept => {\n              if (dept.managerId && dept.managerId.trim() !== '') {\n                teamsWithLeader.add(dept.id);\n              }\n            });\n\n            for (const user of allUsers) {\n              if (user.pendingTeams && user.pendingTeams.length > 0) {\n                for (const teamId of user.pendingTeams) {\n                  if (!teamsWithLeader.has(teamId)) {\n                    const team = departments.find(d => d.id === teamId);\n                    if (team) {\n                      requests.push({\n                        userId: user.id,\n                        userName: user.fullName || user.displayName || user.email,\n                        userEmail: user.email,\n                        teamId: teamId,\n                        teamName: team.name,\n                        requestedAt: user.createdAt || Timestamp.now(),\n                        status: \"pending\",\n                      });\n                    }\n                  }\n                }\n              }\n            }\n          } else if (teamLeaderId) {\n            // Ekip lideri için: Yönettiği ekiplerin taleplerini göster\n            const managedDepartments = departments.filter(d => d.managerId === teamLeaderId);\n            const teamIds = managedDepartments.map(d => d.id);\n\n            if (teamIds.length > 0) {\n              for (const user of allUsers) {\n                if (user.pendingTeams && user.pendingTeams.length > 0) {\n                  for (const teamId of user.pendingTeams) {\n                    if (teamIds.includes(teamId)) {\n                      const team = departments.find(d => d.id === teamId);\n                      if (team) {\n                        requests.push({\n                          userId: user.id,\n                          userName: user.fullName || user.displayName || user.email,\n                          userEmail: user.email,\n                          teamId: teamId,\n                          teamName: team.name,\n                          requestedAt: user.createdAt || Timestamp.now(),\n                          status: \"pending\",\n                        });\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n\n          // Tarihe göre sırala\n          requests.sort((a, b) => {\n            const aTime = a.requestedAt?.toMillis() || 0;\n            const bTime = b.requestedAt?.toMillis() || 0;\n            return bTime - aTime;\n          });\n\n          callback(requests);\n        } catch (error) {\n          if (import.meta.env.DEV) {\n            console.error(\"Subscribe to team requests error:\", error);\n          }\n          callback([]);\n        }\n      },\n      (error) => {\n        if (import.meta.env.DEV) {\n          console.error(\"Team requests snapshot error:\", error);\n        }\n        callback([]);\n      }\n    );\n\n    return unsubscribe;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Subscribe to team requests setup error:\", error);\n    }\n    // Hata durumunda boş callback döndür\n    callback([]);\n    return () => {}; // Boş unsubscribe fonksiyonu\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\firebase\\warrantyService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":59,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1263,1266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1263,1266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":401,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":401,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11052,11055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11052,11055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Warranty/After-Sales Service\n * Satış sonrası takip işlemleri\n */\n\nimport {\n  collection,\n  doc,\n  getDoc,\n  getDocs,\n  addDoc,\n  updateDoc,\n  deleteDoc,\n  query,\n  where,\n  orderBy,\n  serverTimestamp,\n  Timestamp,\n} from \"firebase/firestore\";\nimport { firestore } from \"@/lib/firebase\";\nimport { logAudit } from \"@/utils/auditLogger\";\n\nexport interface WarrantyRecord {\n  id: string;\n  customerId: string;\n  productId: string;\n  orderId?: string | null;\n  reason: string; // Neden geldi\n  receivedDate: Timestamp;\n  status: \"received\" | \"in_repair\" | \"completed\" | \"returned\";\n  repairDescription?: string | null; // Nasıl bir işlem yapıldı\n  cost: number; // Maliyet\n  completedDate?: Timestamp | null;\n  returnedDate?: Timestamp | null;\n  createdBy: string;\n  createdAt: Timestamp;\n  updatedAt: Timestamp;\n}\n\nexport interface WarrantyComment {\n  id: string;\n  warrantyId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  content: string;\n  createdAt: Timestamp | Date | string;\n  updatedAt?: Timestamp | Date | string | null;\n}\n\nexport interface WarrantyActivity {\n  id: string;\n  warrantyId: string;\n  userId: string;\n  userName?: string;\n  userEmail?: string;\n  action: string;\n  description: string;\n  metadata?: Record<string, any>;\n  createdAt: Timestamp | Date | string;\n}\n\nconst WARRANTY_COLLECTION = \"warranty\";\n\n/**\n * Tüm garanti kayıtlarını al\n */\nexport const getWarrantyRecords = async (filters?: {\n  customerId?: string;\n  status?: string;\n}): Promise<WarrantyRecord[]> => {\n  try {\n    let q = query(collection(firestore, WARRANTY_COLLECTION), orderBy(\"receivedDate\", \"desc\"));\n\n    if (filters?.customerId) {\n      q = query(q, where(\"customerId\", \"==\", filters.customerId));\n    }\n\n    if (filters?.status) {\n      q = query(q, where(\"status\", \"==\", filters.status));\n    }\n\n    const snapshot = await getDocs(q);\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as WarrantyRecord[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get warranty records error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydı detayını al\n */\nexport const getWarrantyRecordById = async (warrantyId: string): Promise<WarrantyRecord | null> => {\n  try {\n    const warrantyDoc = await getDoc(doc(firestore, WARRANTY_COLLECTION, warrantyId));\n    \n    if (!warrantyDoc.exists()) {\n      return null;\n    }\n\n    return {\n      id: warrantyDoc.id,\n      ...warrantyDoc.data(),\n    } as WarrantyRecord;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Get warranty record by id error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Yeni garanti kaydı oluştur\n */\nexport const createWarrantyRecord = async (\n  warrantyData: Omit<WarrantyRecord, \"id\" | \"createdAt\" | \"updatedAt\">\n): Promise<WarrantyRecord> => {\n  try {\n    const warrantyDoc: Partial<WarrantyRecord> & { receivedDate: Timestamp; createdAt: ReturnType<typeof serverTimestamp>; updatedAt: ReturnType<typeof serverTimestamp> } = {\n      ...warrantyData,\n      receivedDate: warrantyData.receivedDate || Timestamp.now(),\n      createdAt: serverTimestamp(),\n      updatedAt: serverTimestamp(),\n    };\n    \n    const docRef = await addDoc(collection(firestore, WARRANTY_COLLECTION), warrantyDoc);\n\n    const createdWarranty = await getWarrantyRecordById(docRef.id);\n    if (!createdWarranty) {\n      throw new Error(\"Garanti kaydı oluşturulamadı\");\n    }\n\n    // Audit log\n    await logAudit(\"CREATE\", \"warranty\", docRef.id, warrantyData.createdBy, null, createdWarranty);\n\n    // Aktivite log ekle\n    if (warrantyData.createdBy) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(warrantyData.createdBy);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addWarrantyActivity(\n          docRef.id,\n          warrantyData.createdBy,\n          \"created\",\n          `bu garanti kaydını oluşturdu`,\n          { reason: warrantyData.reason },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add warranty activity error:\", error);\n          }\n        }\n      }\n    }\n\n    return createdWarranty;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      if (import.meta.env.DEV) {\n        console.error(\"Create warranty record error:\", error);\n      }\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydını güncelle\n */\nexport const updateWarrantyRecord = async (\n  warrantyId: string,\n  updates: Partial<Omit<WarrantyRecord, \"id\" | \"createdAt\" | \"createdBy\">>,\n  userId?: string\n): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldWarranty = await getWarrantyRecordById(warrantyId);\n    \n    const updateData: Partial<WarrantyRecord> & { updatedAt: ReturnType<typeof serverTimestamp> } = {\n      ...updates,\n      updatedAt: serverTimestamp(),\n    };\n\n    // Status güncellemelerinde tarih alanlarını güncelle\n    if (updates.status === \"completed\" && !oldWarranty?.completedDate) {\n      updateData.completedDate = serverTimestamp();\n    }\n    if (updates.status === \"returned\" && !oldWarranty?.returnedDate) {\n      updateData.returnedDate = serverTimestamp();\n    }\n    \n    await updateDoc(doc(firestore, WARRANTY_COLLECTION, warrantyId), updateData);\n    \n    // Yeni veriyi al\n    const newWarranty = await getWarrantyRecordById(warrantyId);\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"UPDATE\", \"warranty\", warrantyId, userId, oldWarranty, newWarranty);\n    }\n\n    // Aktivite log ekle\n    if (userId && oldWarranty && newWarranty) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n\n        const changedFields = Object.keys(updates).filter(key => {\n          const oldValue = (oldWarranty as Record<string, unknown>)[key];\n          const newValue = (updates as Record<string, unknown>)[key];\n          return oldValue !== newValue;\n        });\n        \n        if (changedFields.length > 0) {\n          await addWarrantyActivity(\n            warrantyId,\n            userId,\n            \"updated\",\n            `bu garanti kaydını güncelledi`,\n            { changedFields },\n            userName,\n            userEmail\n          );\n        }\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add warranty activity error:\", error);\n          }\n        }\n      }\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Update warranty record error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydını sil\n */\nexport const deleteWarrantyRecord = async (warrantyId: string, userId?: string): Promise<void> => {\n  try {\n    // Eski veriyi al\n    const oldWarranty = await getWarrantyRecordById(warrantyId);\n    \n    // Aktivite log ekle (silmeden önce)\n    if (userId && oldWarranty) {\n      try {\n        const { getUserProfile } = await import(\"./authService\");\n        const userProfile = await getUserProfile(userId);\n        const userName = userProfile?.fullName || userProfile?.displayName || userProfile?.email;\n        const userEmail = userProfile?.email;\n        \n        await addWarrantyActivity(\n          warrantyId,\n          userId,\n          \"deleted\",\n          `bu garanti kaydını sildi`,\n          { reason: oldWarranty.reason },\n          userName,\n          userEmail\n        );\n      } catch (error) {\n        if (import.meta.env.DEV) {\n          if (import.meta.env.DEV) {\n            console.error(\"Add warranty activity error:\", error);\n          }\n        }\n      }\n    }\n    \n    await deleteDoc(doc(firestore, WARRANTY_COLLECTION, warrantyId));\n    \n    // Audit log\n    if (userId) {\n      await logAudit(\"DELETE\", \"warranty\", warrantyId, userId, oldWarranty, null);\n    }\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Delete warranty record error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydına yorum ekle\n */\nexport const addWarrantyComment = async (\n  warrantyId: string,\n  userId: string,\n  content: string,\n  userName?: string,\n  userEmail?: string\n): Promise<WarrantyComment> => {\n  try {\n    const commentData: Omit<WarrantyComment, \"id\"> = {\n      warrantyId,\n      userId,\n      userName,\n      userEmail,\n      content,\n      createdAt: Timestamp.now(),\n      updatedAt: null,\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, WARRANTY_COLLECTION, warrantyId, \"comments\"),\n      commentData\n    );\n\n    // Activity log ekle\n    await addWarrantyActivity(warrantyId, userId, \"commented\", `yorum ekledi`, { commentId: docRef.id }, userName, userEmail);\n\n    // Garanti kaydını oluşturan kişiye bildirim gönder (yorum ekleyen kişi hariç)\n    try {\n      const warranty = await getWarrantyRecordById(warrantyId);\n      if (warranty?.createdBy && warranty.createdBy !== userId) {\n        const { createNotification } = await import(\"@/services/firebase/notificationService\");\n        await createNotification({\n          userId: warranty.createdBy,\n          type: \"comment_added\",\n          title: \"Garanti Kaydınıza Yorum Eklendi\",\n          message: `${userName || userEmail || \"Bir kullanıcı\"} garanti kaydınıza yorum ekledi: ${content.substring(0, 100)}${content.length > 100 ? \"...\" : \"\"}`,\n          read: false,\n          relatedId: warrantyId,\n          metadata: { commentId: docRef.id, commenterId: userId, commenterName: userName, commenterEmail: userEmail },\n        });\n      }\n    } catch (error) {\n      if (import.meta.env.DEV) {\n        console.error(\"Send comment notification error:\", error);\n      }\n    }\n\n    return {\n      id: docRef.id,\n      ...commentData,\n    };\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add warranty comment error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydı yorumlarını al\n */\nexport const getWarrantyComments = async (warrantyId: string): Promise<WarrantyComment[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, WARRANTY_COLLECTION, warrantyId, \"comments\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as WarrantyComment[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get warranty comments error:\", error);\n    }\n    throw error;\n  }\n};\n\n/**\n * Garanti kaydı aktivite log ekle\n */\nexport const addWarrantyActivity = async (\n  warrantyId: string,\n  userId: string,\n  action: string,\n  description: string,\n  metadata?: Record<string, any>,\n  userName?: string,\n  userEmail?: string\n): Promise<string> => {\n  try {\n    const activityData: Omit<WarrantyActivity, \"id\"> = {\n      warrantyId,\n      userId,\n      userName,\n      userEmail,\n      action,\n      description,\n      metadata: metadata || {},\n      createdAt: Timestamp.now(),\n    };\n\n    const docRef = await addDoc(\n      collection(firestore, WARRANTY_COLLECTION, warrantyId, \"activities\"),\n      activityData\n    );\n\n    return docRef.id;\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Add warranty activity error:\", error);\n    }\n    return \"\";\n  }\n};\n\n/**\n * Garanti kaydı aktivite loglarını al\n */\nexport const getWarrantyActivities = async (warrantyId: string): Promise<WarrantyActivity[]> => {\n  try {\n    const snapshot = await getDocs(\n      query(\n        collection(firestore, WARRANTY_COLLECTION, warrantyId, \"activities\"),\n        orderBy(\"createdAt\", \"desc\")\n      )\n    );\n    return snapshot.docs.map((doc) => ({\n      id: doc.id,\n      ...doc.data(),\n    })) as WarrantyActivity[];\n  } catch (error) {\n    if (import.meta.env.DEV) {\n      console.error(\"Get warranty activities error:\", error);\n    }\n    throw error;\n  }\n};\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\pdfGenerator.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'nextY' is never reassigned. Use 'const' instead.","line":572,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":572,"endColumn":14,"fix":{"range":[22811,22835],"text":"const nextY = margin + 30;"}},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":1033,"column":60,"nodeType":"BlockStatement","messageId":"unexpected","endLine":1034,"endColumn":8,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[38985,38992],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"prefer-const","severity":2,"message":"'nextY' is never reassigned. Use 'const' instead.","line":1370,"column":9,"nodeType":"Identifier","messageId":"useConst","endLine":1370,"endColumn":14,"fix":{"range":[49397,49421],"text":"const nextY = margin + 30;"}},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":1809,"column":23,"nodeType":"BlockStatement","messageId":"unexpected","endLine":1810,"endColumn":4,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[65975,65978],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2596,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2596,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[95185,95188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[95185,95188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2597,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2597,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[95247,95250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[95247,95250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2785,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2785,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[101261,101264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[101261,101264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2825,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2825,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[102900,102903],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[102900,102903],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2826,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2826,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[102990,102993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[102990,102993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":2827,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":2827,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[103079,103082],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[103079,103082],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3041,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3041,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[112283,112286],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[112283,112286],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3042,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3042,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[112378,112381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[112378,112381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3043,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3043,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[112476,112479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[112476,112479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3057,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3057,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[113149,113152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[113149,113152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3058,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3058,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[113237,113240],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[113237,113240],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3059,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3059,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[113328,113331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[113328,113331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3413,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3413,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[126044,126047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[126044,126047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3413,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3413,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[126075,126078],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[126075,126078],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3423,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3423,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[126587,126590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[126587,126590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":3423,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3423,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[126618,126621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[126618,126621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":3950,"column":89,"nodeType":"BlockStatement","messageId":"unexpected","endLine":3951,"endColumn":4,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[147241,147244],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":4000,"column":31,"nodeType":"BlockStatement","messageId":"unexpected","endLine":4001,"endColumn":8,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[149012,149019],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":4022,"column":19,"nodeType":"BlockStatement","messageId":"unexpected","endLine":4023,"endColumn":4,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[149637,149640],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":4086,"column":19,"nodeType":"BlockStatement","messageId":"unexpected","endLine":4087,"endColumn":4,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[152087,152090],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]},{"ruleId":"prefer-const","severity":2,"message":"'currentY' is never reassigned. Use 'const' instead.","line":4180,"column":7,"nodeType":"Identifier","messageId":"useConst","endLine":4180,"endColumn":15,"fix":{"range":[155809,155840],"text":"const currentY = maxBottomY + 30;"}},{"ruleId":"no-empty","severity":2,"message":"Empty block statement.","line":4485,"column":19,"nodeType":"BlockStatement","messageId":"unexpected","endLine":4486,"endColumn":4,"suggestions":[{"messageId":"suggestComment","data":{"type":"block"},"fix":{"range":[167547,167550],"text":" /* empty */ "},"desc":"Add comment inside empty block statement."}]}],"suppressedMessages":[],"errorCount":26,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":3,"fixableWarningCount":0,"source":"import jsPDF, { jsPDFOptions } from \"jspdf\";\nimport autoTable, { CellHookData as AutoTableCellHookData } from \"jspdf-autotable\";\nimport { REV_LOGO_DATA_URI } from \"@/assets/rev-logo-base64\";\nimport { ROBOTO_REGULAR_BASE64, ROBOTO_BOLD_BASE64 } from \"@/assets/fonts/roboto-base64\";\n\n// Sabit şirket bilgileri - cache'lenmiş, değişmeyen değerler\nconst COMPANY_INFO = {\n  name: \"Revium Ltd. Şti.\",\n  address: \"Fevzi Cakmak Mah. Milenyum Cad. No:81\",\n  city: \"Karatay/KONYA\",\n  email: \"info@reviumtech.com\",\n  website: \"www.reviumtech.com\",\n  phone: \"+90 (551) 829-1613\",\n  fullAddress: \"Fevzi Cakmak Mah. Milenyum Cad. No:81, Karatay/KONYA\",\n  contactInfo: \"info@reviumtech.com | www.reviumtech.com | +90 (551) 829-1613\",\n  headerAddress: \"Fevzi Cakmak Mah. Milenyum Cad. No:81\",\n} as const;\n\n// PDF sabit değerleri - cache'lenmiş\nconst PDF_CONSTANTS = {\n  margin: 50,\n  headerHeight: 120, // Header içeriği için yeterli yükseklik\n  footerHeight: 50,\n  logoSize: 40, // 50 → 40 (daha küçük)\n  footerLogoSize: 28, // 32 → 28 (daha küçük)\n  // Profesyonel renk paleti - modern ve minimal\n  primaryColor: [30, 58, 138] as [number, number, number], // Koyu mavi - profesyonel\n  mutedColor: [71, 85, 105] as [number, number, number], // Koyu gri-mavi\n  accentColor: [59, 130, 246] as [number, number, number], // Açık mavi vurgu\n  successColor: [16, 185, 129] as [number, number, number], // Yeşil - başarı\n  warningColor: [245, 158, 11] as [number, number, number], // Turuncu - uyarı\n  errorColor: [239, 68, 68] as [number, number, number], // Kırmızı - hata\n  // Kart boyutları ve spacing - Web sayfasındaki değerler (küçültülmüş)\n  cardHeight: 95, // 120 → 95 (daha kompakt)\n  cardGap: 12, // 16 → 12 (daha az boşluk)\n  cardPadding: 14, // 18 → 14 (daha kompakt)\n  cardHeaderPadding: 10, // 12 → 10 (daha az padding)\n  // Tablo başlık boyutları\n  tableHeaderHeight: 32, // 36 → 32 (daha kompakt)\n  tableHeaderPadding: 8, // 10 → 8\n  tableHeaderSpacing: 24, // 30 → 24\n  // Section spacing - Web sayfasındaki gibi (space-y-6 = 24px)\n  sectionSpacing: 20, // 24 → 20 (daha kompakt)\n  tableSpacing: 20, // 24 → 20 (daha kompakt)\n  // Font boyutları - Web sayfasındaki değerler (küçültülmüş)\n  fontSizeCardTitle: 12, // 14 → 12 (daha küçük)\n  fontSizeCardValue: 24, // 30 → 24 (daha küçük)\n  fontSizeCardDescription: 11, // 12 → 11 (daha küçük)\n  fontSizeTableHeader: 16, // 18 → 16 (daha küçük)\n  fontSizeTableBody: 11,\n  fontSizeTableHeaderText: 12,\n} as const;\n\n// Profesyonel renk paleti - modern, minimal ve sofistike\nconst TAILWIND_COLORS = {\n  // Profesyonel kart renkleri - nötr ve minimal\n  cardBackground: [248, 250, 252] as [number, number, number], // Çok açık gri - kart arka planı\n  cardBorder: [226, 232, 240] as [number, number, number], // Açık gri - kart border\n  cardText: [71, 85, 105] as [number, number, number], // Koyu gri-mavi - kart metin\n  // Primary kart (vurgulu) - Web sayfasındaki renkler\n  primaryCardBg: [255, 255, 255] as [number, number, number], // Beyaz (rgba(221, 83, 53, 0.05) overlay ile)\n  primaryCardBorder: [221, 83, 53] as [number, number, number], // Kırmızı-turuncu (web: border-[rgb(221,83,53)])\n  primaryCardValue: [221, 83, 53] as [number, number, number], // Kırmızı-turuncu (text-primary)\n  // Success kart (yeşil tonları) - Web sayfasındaki renkler\n  successCardBg: [240, 253, 244] as [number, number, number], // Çok açık yeşil (web: bg-[rgb(240,253,244)])\n  successCardBorder: [187, 247, 208] as [number, number, number], // Açık yeşil (web: border-[rgb(187,247,208)])\n  successCardValue: [22, 163, 74] as [number, number, number], // Yeşil (web: text-green-600)\n  // Info kart (mavi tonları) - Web sayfasındaki renkler\n  infoCardBg: [239, 246, 255] as [number, number, number], // Çok açık mavi (web: bg-[rgb(239,246,255)])\n  infoCardBorder: [191, 219, 254] as [number, number, number], // Açık mavi (web: border-[rgb(191,219,254)])\n  infoCardValue: [37, 99, 235] as [number, number, number], // Koyu mavi (web: text-blue-600)\n  // Warning kart (turuncu tonları - daha yumuşak)\n  warningCardBg: [255, 251, 235] as [number, number, number], // Çok açık turuncu\n  warningCardBorder: [253, 230, 138] as [number, number, number], // Açık turuncu\n  warningCardValue: [217, 119, 6] as [number, number, number], // Koyu turuncu\n  // Error kart (kırmızı tonları - daha yumuşak)\n  errorCardBg: [254, 242, 242] as [number, number, number], // Çok açık kırmızı\n  errorCardBorder: [254, 202, 202] as [number, number, number], // Açık kırmızı\n  errorCardValue: [220, 38, 38] as [number, number, number], // Koyu kırmızı\n  // Gray palette - profesyonel tonlar\n  gray50: [249, 250, 251] as [number, number, number],\n  gray100: [243, 244, 246] as [number, number, number],\n  gray200: [229, 231, 235] as [number, number, number],\n  gray300: [209, 213, 219] as [number, number, number],\n  gray500: [107, 114, 128] as [number, number, number],\n  gray600: [71, 85, 105] as [number, number, number], // Güncellenmiş - daha profesyonel\n  gray700: [51, 65, 85] as [number, number, number], // Yeni - orta koyu\n  gray800: [30, 41, 59] as [number, number, number], // Güncellenmiş - daha koyu\n  gray900: [15, 23, 42] as [number, number, number], // Güncellenmiş - çok koyu\n  // White\n  white: [255, 255, 255] as [number, number, number],\n  // Eski renkler - geriye dönük uyumluluk için (kullanılmıyor ama referans için)\n  green50: [240, 253, 250] as [number, number, number],\n  green200: [167, 243, 208] as [number, number, number],\n  green500: [16, 185, 129] as [number, number, number],\n  green600: [5, 150, 105] as [number, number, number],\n  blue50: [239, 246, 255] as [number, number, number],\n  blue200: [191, 219, 254] as [number, number, number],\n  blue500: [59, 130, 246] as [number, number, number],\n  blue600: [37, 99, 235] as [number, number, number],\n  red50: [254, 242, 242] as [number, number, number],\n  red200: [254, 202, 202] as [number, number, number],\n  red500: [239, 68, 68] as [number, number, number],\n  red600: [220, 38, 38] as [number, number, number],\n  emerald50: [240, 253, 250] as [number, number, number],\n  emerald200: [167, 243, 208] as [number, number, number],\n  emerald500: [16, 185, 129] as [number, number, number],\n  emerald600: [5, 150, 105] as [number, number, number],\n  purple50: [250, 245, 255] as [number, number, number],\n  purple200: [233, 213, 255] as [number, number, number],\n  purple500: [168, 85, 247] as [number, number, number],\n  purple600: [147, 51, 234] as [number, number, number],\n} as const;\n\n// PDF Template Layout - Sabit alanlar ve dinamik içerik alanları\ninterface PDFTemplateLayout {\n  // Sabit alanlar (her sayfada aynı)\n  background: {\n    startY: number;\n    endY: number;\n  };\n  header: {\n    startY: number;\n    endY: number;\n    contentStartY: number; // Dinamik içeriğin başlayacağı Y pozisyonu\n  };\n  footer: {\n    startY: number;\n    endY: number;\n  };\n  // Dinamik içerik alanı\n  contentArea: {\n    startY: number;\n    endY: number;\n    width: number;\n    leftMargin: number;\n    rightMargin: number;\n  };\n}\n\n// İstatistik Kartı Tipi - sabit tasarım, dinamik değerler\ninterface StatCardConfig {\n  title: string;\n  value: string | number;\n  description?: string;\n  color: {\n    background: [number, number, number];\n    border: [number, number, number];\n    text: [number, number, number];\n    value: [number, number, number];\n  };\n}\n\n// Tablo Başlık Konfigürasyonu - sabit tasarım\ninterface TableHeaderConfig {\n  title: string;\n  backgroundColor?: [number, number, number];\n  textColor?: [number, number, number];\n  borderColor?: [number, number, number];\n}\n\n// PDF Template oluştur - sabit layout hesaplamaları\nconst createPDFTemplate = (doc: jsPDFWithFontStatus): PDFTemplateLayout => {\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const pageHeight = doc.internal.pageSize.getHeight();\n  const mar = PDF_CONSTANTS.margin;\n\n  return {\n    background: {\n      startY: 0,\n      endY: pageHeight,\n    },\n    header: {\n      startY: 0,\n      endY: PDF_CONSTANTS.headerHeight,\n      contentStartY: PDF_CONSTANTS.headerHeight + 50, // Header'dan sonra 50px boşluk (30 → 50, altında ek boşluk)\n    },\n    footer: {\n      startY: pageHeight - PDF_CONSTANTS.footerHeight,\n      endY: pageHeight,\n    },\n    contentArea: {\n      startY: PDF_CONSTANTS.headerHeight + 50, // Header'dan sonra başlar (30 → 50, altında ek boşluk)\n      endY: pageHeight - PDF_CONSTANTS.footerHeight - 20, // Footer'dan önce biter (20px boşluk)\n      width: pageWidth - (mar * 2),\n      leftMargin: mar,\n      rightMargin: mar,\n    },\n  };\n};\n\n// Kart boyutlarını hesapla - standardize edilmiş helper fonksiyon\nconst calculateCardDimensions = (contentWidth: number, cardCount: number): { width: number; gap: number } => {\n  const gap = PDF_CONSTANTS.cardGap;\n  if (cardCount === 3) {\n    return {\n      width: (contentWidth - (2 * gap)) / 3,\n      gap: gap,\n    };\n  } else if (cardCount === 4) {\n    // 4 kart için gap'i daha da küçült (taşmayı önlemek için)\n    const reducedGap = 8; // 12 → 8 (daha kompakt)\n    return {\n      width: (contentWidth - (3 * reducedGap)) / 4,\n      gap: reducedGap,\n    };\n  } else {\n    // Varsayılan: 3 kart\n    return {\n      width: (contentWidth - (2 * gap)) / 3,\n      gap: gap,\n    };\n  }\n};\n\n// Ortak safeText helper fonksiyonu - tüm raporlarda kullanılabilir\n// Türkçe karakterleri ASCII'ye çevir (sadece Helvetica için, Roboto destekliyor)\nconst transliterateTurkish = (text: string): string => {\n  const turkishMap: Record<string, string> = {\n    'ç': 'c', 'Ç': 'C',\n    'ğ': 'g', 'Ğ': 'G',\n    'ı': 'i', 'İ': 'I',\n    'ö': 'o', 'Ö': 'O',\n    'ş': 's', 'Ş': 'S',\n    'ü': 'u', 'Ü': 'U',\n  };\n  return text.replace(/[çÇğĞıİöÖşŞüÜ]/g, (char) => turkishMap[char] || char);\n};\n\n// AutoTable verilerini transliterate et - sadece Helvetica kullanılırken\n// Roboto font Türkçe karakterleri destekliyor, bu yüzden font yüklüyse transliterate yapma\nconst transliterateTableData = (\n  data: (string | number)[][] | null | undefined,\n  doc?: jsPDFWithFontStatus\n): (string | number)[][] => {\n  if (!data || !Array.isArray(data)) {\n    return [];\n  }\n\n  // Roboto font yüklüyse transliterate yapma\n  if (doc && doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    return data.map((row) => {\n      if (!Array.isArray(row)) {\n        return [];\n      }\n      return row.map((cell) => cell);\n    });\n  }\n\n  // Helvetica kullanılıyorsa transliterate et\n  return data.map((row) => {\n    if (!Array.isArray(row)) {\n      return [];\n    }\n    return row.map((cell) => {\n      if (typeof cell === 'string') {\n        return transliterateTurkish(cell);\n      }\n      return cell;\n    });\n  });\n};\n\nconst createSafeText = (doc: jsPDFWithFontStatus) => {\n  // Roboto font Türkçe karakterleri destekliyor\n  // Sadece Helvetica kullanılırken transliterate et\n  return (text: string, x: number, y: number, fontSize: number, isBold: boolean = false) => {\n    // null/undefined kontrolü\n    if (text == null || text === '') {\n      return;\n    }\n\n    const textStr = String(text);\n\n    // ÖNCE translitere edilmiş versiyonu hazırla (yedek olarak)\n    const transliteratedText = transliterateTurkish(textStr);\n\n    // Font yüklenmemişse veya yükleme başarısızsa direkt helvetica kullan ve transliterate et\n    if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n      try {\n        doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\n        doc.setFontSize(fontSize);\n        doc.text(transliteratedText, x, y);\n      } catch (error: unknown) {\n        // Hata durumunda sessizce devam et - ama loglayalım\n        console.warn('createSafeText: Helvetica ile yazılamadı:', error);\n      }\n      return;\n    }\n\n    // Roboto kullanmayı dene\n    let robotoSuccess = false;\n    try {\n      doc.setFont(\"Roboto\", isBold ? \"bold\" : \"normal\");\n      doc.setFontSize(fontSize);\n      const currentFont = doc.getFont();\n\n      if (currentFont && isRobotoName(currentFont.fontName)) {\n        // Roboto font başarıyla ayarlandı, Türkçe karakterleri koruyarak yaz\n        try {\n          doc.text(textStr, x, y);\n          robotoSuccess = true;\n        } catch (writeError) {\n          // Text yazma hatası - robotoSuccess false kalacak, fallback'e geçilecek\n          console.warn('createSafeText: Roboto textStr yazılamadı, fallback deneniyor:', writeError);\n        }\n      }\n    } catch (fontError) {\n      // Font ayarlama hatası\n      console.warn('createSafeText: Roboto font ayarlanamadı:', fontError);\n    }\n\n    // Roboto başarısız olduysa, Helvetica ile translitere edilmiş text'i yaz\n    if (!robotoSuccess) {\n      try {\n        doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\n        doc.setFontSize(fontSize);\n        doc.text(transliteratedText, x, y);\n      } catch (fallbackError) {\n        // Son çare: loglayıp devam et\n        console.error('createSafeText: Fallback da başarısız:', fallbackError);\n      }\n    }\n  };\n};\n\n// Arka plan template'i - sabit, her sayfada aynı\nconst drawPDFBackground = (doc: jsPDFWithFontStatus, template: PDFTemplateLayout) => {\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n\n  // Header background - profesyonel ve minimal (daha hafif)\n  doc.setFillColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.04 })); // Daha hafif: 0.08 → 0.04\n  doc.rect(0, 0, pageWidth, PDF_CONSTANTS.headerHeight, \"F\");\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  // Footer background - sabit (profesyonel gri)\n  const footerY = doc.internal.pageSize.getHeight() - PDF_CONSTANTS.footerHeight;\n  doc.setFillColor(TAILWIND_COLORS.gray50[0], TAILWIND_COLORS.gray50[1], TAILWIND_COLORS.gray50[2]);\n  doc.rect(0, footerY, pageWidth, PDF_CONSTANTS.footerHeight, \"F\");\n};\n\n// Sabit İstatistik Kartı Çizme Fonksiyonu - profesyonel ve sade tasarım\nconst drawStatCard = (\n  doc: jsPDFWithFontStatus,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  config: StatCardConfig\n): void => {\n  const safeText = createSafeText(doc);\n  const [bgR, bgG, bgB] = config.color.background;\n  const [borderR, borderG, borderB] = config.color.border;\n  const [textR, textG, textB] = config.color.text;\n  const [valueR, valueG, valueB] = config.color.value;\n\n  // Primary kart için özel arka plan (opacity ile) - Web sayfasındaki gibi\n  const isPrimaryCard = borderR === TAILWIND_COLORS.primaryCardBorder[0] &&\n    borderG === TAILWIND_COLORS.primaryCardBorder[1] &&\n    borderB === TAILWIND_COLORS.primaryCardBorder[2] &&\n    bgR === TAILWIND_COLORS.white[0] &&\n    bgG === TAILWIND_COLORS.white[1] &&\n    bgB === TAILWIND_COLORS.white[2];\n\n  if (isPrimaryCard) {\n    // Primary kart için hafif arka plan (web: rgba(221, 83, 53, 0.05))\n    doc.setFillColor(borderR, borderG, borderB);\n    doc.setGState(doc.GState({ opacity: 0.05 }));\n    doc.roundedRect(x, y, width, height, 6, 6, \"F\");\n    doc.setGState(doc.GState({ opacity: 1 }));\n  } else {\n    // Normal kart arka planı\n    doc.setFillColor(bgR, bgG, bgB);\n    doc.roundedRect(x, y, width, height, 6, 6, \"F\");\n  }\n\n  // Border - Web sayfasındaki gibi (2pt kalınlık - border-2)\n  doc.setDrawColor(borderR, borderG, borderB);\n  doc.setLineWidth(2);\n  doc.roundedRect(x, y, width, height, 6, 6, \"S\");\n\n  // Başlık - Web sayfasındaki gibi (küçültülmüş spacing)\n  // Title: y + cardPadding (14px) + title baseline (~12px) = y + 26\n  doc.setTextColor(textR, textG, textB);\n  safeText(config.title, x + PDF_CONSTANTS.cardPadding, y + 26, PDF_CONSTANTS.fontSizeCardTitle, true);\n\n  // Değer - Web sayfasındaki gibi (küçültülmüş spacing)\n  // Value: title'dan sonra (10px) + value baseline (~24px) = y + 26 + 10 + 24 = y + 60\n  const valueText = typeof config.value === 'number' ? config.value.toString() : config.value;\n  doc.setTextColor(valueR, valueG, valueB);\n  safeText(valueText, x + PDF_CONSTANTS.cardPadding, y + 60, PDF_CONSTANTS.fontSizeCardValue, true);\n\n  // Açıklama - Web sayfasındaki gibi (küçültülmüş spacing)\n  // Description: value'dan sonra (4px) + description baseline (~11px) = y + 60 + 4 + 11 = y + 75\n  if (config.description) {\n    doc.setTextColor(textR, textG, textB);\n    safeText(config.description, x + PDF_CONSTANTS.cardPadding, y + 75, PDF_CONSTANTS.fontSizeCardDescription, false);\n  }\n\n  doc.setTextColor(0, 0, 0);\n};\n\n// Profesyonel Tablo Başlığı Çizme Fonksiyonu - profesyonel ve sade tasarım\nconst drawProfessionalTableHeader = (\n  doc: jsPDFWithFontStatus,\n  x: number,\n  y: number,\n  width: number,\n  config: TableHeaderConfig\n): number => {\n  const safeText = createSafeText(doc);\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n\n  // Web sayfasındaki renkler - bg-[rgb(249,250,251)] border-b\n  const bgColor = config.backgroundColor || TAILWIND_COLORS.gray50; // Web: bg-[rgb(249,250,251)]\n  const textColor = config.textColor || PDF_CONSTANTS.primaryColor; // Web: text-primary\n  const borderColor = config.borderColor || [229, 231, 235]; // Web: border-b (gray200)\n\n  // Başlık için arka plan - Web sayfasındaki gibi (bg-[rgb(249,250,251)])\n  doc.setFillColor(bgColor[0], bgColor[1], bgColor[2]);\n  doc.roundedRect(x, y - PDF_CONSTANTS.tableHeaderPadding, width, PDF_CONSTANTS.tableHeaderHeight, 4, 4, \"F\");\n\n  // Alt border - Web sayfasındaki gibi (border-b)\n  doc.setDrawColor(borderColor[0], borderColor[1], borderColor[2]);\n  doc.setLineWidth(1);\n  doc.line(x, y + PDF_CONSTANTS.tableHeaderHeight - PDF_CONSTANTS.tableHeaderPadding, x + width, y + PDF_CONSTANTS.tableHeaderHeight - PDF_CONSTANTS.tableHeaderPadding);\n\n  // Başlık text - Web sayfasındaki gibi (text-lg font-bold = 18px, bold)\n  doc.setTextColor(textColor[0], textColor[1], textColor[2]);\n  // Font'u bold yap\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    doc.setFont(\"Roboto\", \"bold\");\n  } else {\n    doc.setFont(\"helvetica\", \"bold\");\n  }\n  safeText(config.title, x + 10, y + PDF_CONSTANTS.tableHeaderPadding, PDF_CONSTANTS.fontSizeTableHeader, true); // Küçültülmüş: 18 → 16\n  doc.setTextColor(0, 0, 0);\n\n  // Başlıktan sonraki Y pozisyonu: headerHeight + padding + spacing (iyileştirilmiş)\n  // Yeterli boşluk için optimize edildi\n  return y + PDF_CONSTANTS.tableHeaderHeight + PDF_CONSTANTS.tableHeaderSpacing - 2; // Daha kompakt (-2px)\n};\n\n// Eski fonksiyon için alias (geriye dönük uyumluluk)\nconst drawTableHeader = drawProfessionalTableHeader;\n\n// Profesyonel Tablo Stil Konfigürasyonu - tüm tablolarda kullanılacak\ninterface ProfessionalTableStyles {\n  headStyles: Record<string, unknown>;\n  bodyStyles: Record<string, unknown>;\n  styles: Record<string, unknown>;\n  alternateRowStyles: Record<string, unknown>;\n}\n\nconst createProfessionalTableStyles = (\n  doc: jsPDFWithFontStatus,\n  options?: {\n    headerFontSize?: number;\n    bodyFontSize?: number;\n    cellPadding?: { top: number; right: number; bottom: number; left: number };\n  }\n): ProfessionalTableStyles => {\n  // Standardize edilmiş varsayılan değerler\n  const headerFontSize = options?.headerFontSize || PDF_CONSTANTS.fontSizeTableHeaderText;\n  const bodyFontSize = options?.bodyFontSize || PDF_CONSTANTS.fontSizeTableBody;\n  const cellPadding = options?.cellPadding || { top: 10, right: 12, bottom: 10, left: 12 };\n\n  // Font'u zorla Roboto yap - ÇOK AGRESİF YAKLAŞIM\n  // Font'un gerçekten yüklü olduğunu kontrol et ve MUTLAKA Roboto kullan\n  let fontName = \"helvetica\";\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    // Font'u zorla Roboto olarak ayarla - daha fazla deneme\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          fontName = \"Roboto\";\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n\n    // Font listesinde Roboto var mı kontrol et\n    if (fontName === \"helvetica\") {\n      try {\n        const fontList = doc.getFontList();\n        if (fontList && Object.keys(fontList).some((key) => isRobotoName(key))) {\n          // Font listesinde var, zorla kullan\n          fontName = \"Roboto\";\n          // Font'u tekrar ayarla\n          for (let i = 0; i < 5; i++) {\n            try {\n              doc.setFont(\"Roboto\", \"normal\");\n              const currentFont = doc.getFont();\n              if (currentFont && isRobotoName(currentFont.fontName)) {\n                break;\n              }\n            } catch {\n              // Tekrar dene\n            }\n          }\n        }\n      } catch {\n        // Font listesi alınamadı\n      }\n    }\n  }\n\n  return {\n    headStyles: {\n      fillColor: [249, 250, 251], // Web: bg-gray-50/50 (gray50 with opacity, PDF'te tam gray50)\n      textColor: [30, 41, 59], // Koyu gri-mavi - Web: text-muted-foreground\n      fontStyle: \"bold\", // Web: font-semibold (bold kullanıyoruz)\n      fontSize: headerFontSize,\n      font: fontName, // Zorla Roboto veya helvetica\n      halign: \"center\", // Başlıklar ortalanmış\n      lineColor: TAILWIND_COLORS.gray200, // gray-200\n      lineWidth: { top: 0, bottom: 1, left: 0, right: 0 }, // Sadece alt border - Web: border-b\n      cellPadding: cellPadding,\n      minCellHeight: 40, // Minimum satır yüksekliği\n      overflow: 'linebreak', // Metin taşmasını önle\n      wrap: true, // Metin sarmalama\n    },\n    bodyStyles: {\n      fillColor: [255, 255, 255], // Web: beyaz arka plan\n      textColor: [30, 41, 59], // Koyu gri-mavi - Web: text-foreground\n      fontSize: bodyFontSize,\n      font: fontName, // Zorla Roboto veya helvetica\n      fontStyle: \"normal\", // Web: font-medium (normal kullanıyoruz)\n      lineColor: TAILWIND_COLORS.gray200, // gray-200\n      lineWidth: { bottom: 1, top: 0, left: 0, right: 0 }, // Sadece alt border\n      cellPadding: cellPadding,\n      minCellHeight: 40, // Minimum satır yüksekliği\n      overflow: 'linebreak', // Metin taşmasını önle\n      wrap: true, // Metin sarmalama\n    },\n    styles: {\n      font: fontName, // Zorla Roboto veya helvetica\n      fontStyle: \"normal\",\n      fontSize: bodyFontSize,\n      cellPadding: cellPadding,\n      minCellHeight: 40, // Minimum satır yüksekliği\n      overflow: 'linebreak', // Metin taşmasını önle\n      wrap: true, // Metin sarmalama\n    },\n    alternateRowStyles: {\n      fillColor: TAILWIND_COLORS.gray50, // gray-50 - alternatif satırlar (çok açık)\n    },\n  };\n};\n\n// Tablo sayfa sığmazsa yeni sayfa ekle\nconst ensureTableFitsPage = (\n  doc: jsPDFWithFontStatus,\n  currentY: number,\n  requiredHeight: number,\n  margin: number = 40,\n  titleForNextPage?: string\n): number => {\n  const pageHeight = doc.internal.pageSize.getHeight();\n  const footerHeight = PDF_CONSTANTS.footerHeight;\n\n  // Eğer tablo sayfa sığmazsa yeni sayfa ekle (daha fazla boşluk bırak)\n  const minSpaceNeeded = requiredHeight + 70; // 70pt ekstra boşluk (50pt'den artırıldı)\n  if (currentY + minSpaceNeeded > pageHeight - footerHeight - margin) {\n    doc.addPage();\n    let nextY = margin + 30; // Üstten 30pt daha fazla boşluk (20pt'den artırıldı)\n\n    // Yeni sayfada template'i uygula\n    const template = createPDFTemplate(doc);\n    drawPDFBackground(doc, template);\n\n    // \"(devam)\" etiketi kaldırıldı - kullanıcı isteği\n\n    return nextY;\n  }\n\n  return currentY;\n};\n\n// Sabit Özet Bölümü Çizme Fonksiyonu - tasarım sabit, veriler dinamik\nconst drawSummarySection = (\n  doc: jsPDFWithFontStatus,\n  x: number,\n  y: number,\n  width: number,\n  title: string,\n  data: Array<[string, string]>,\n  headerColor: [number, number, number] = PDF_CONSTANTS.primaryColor\n): number => {\n  const safeText = createSafeText(doc);\n  const [headerR, headerG, headerB] = headerColor;\n\n  // Özet başlık arka planı - sabit tasarım\n  doc.setFillColor(headerR, headerG, headerB);\n  doc.roundedRect(x, y, width, 40, 5, 5, \"F\");\n  doc.setDrawColor(headerR, headerG, headerB);\n  doc.roundedRect(x, y, width, 40, 5, 5, \"S\");\n\n  // Dekoratif çizgi - sabit tasarım\n  doc.setDrawColor(255, 255, 255);\n  doc.setGState(doc.GState({ opacity: 0.3 }));\n  doc.setLineWidth(1);\n  const pageWidth = doc.internal.pageSize.getWidth();\n  doc.line(x + 5, y + 38, pageWidth - x - 5, y + 38);\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  // Başlık text - dinamik (daha okunabilir font size)\n  doc.setTextColor(255, 255, 255);\n  safeText(title, x + 15, y + 26, 19, true); // İyileştirildi: 18px → 19px\n  doc.setTextColor(0, 0, 0);\n\n  const summaryY = y + 50;\n\n  // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n  forceRobotoFont(doc, \"normal\");\n\n  // Özet tablosu - sabit stil, dinamik veriler\n  autoTable(doc, {\n    startY: summaryY,\n    head: transliterateTableData([['Metrik', 'Değer']], doc),\n    body: transliterateTableData(data, doc),\n    margin: { left: x, right: x },\n    willDrawCell: createWillDrawCell(doc),\n    headStyles: {\n      fillColor: [headerR, headerG, headerB],\n      textColor: [255, 255, 255],\n      fontStyle: \"bold\",\n      fontSize: 12,\n      font: getFontName(doc),\n      lineColor: [headerR, headerG, headerB],\n      lineWidth: { top: 1, bottom: 1, left: 1, right: 1 },\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    },\n    bodyStyles: {\n      textColor: [31, 41, 55],\n      fontSize: 11,\n      font: getFontName(doc),\n      lineColor: [229, 231, 235],\n      lineWidth: { bottom: 1 },\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    },\n    styles: {\n      font: getFontName(doc),\n      fontStyle: \"normal\",\n      fontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    },\n    columnStyles: {\n      0: { cellWidth: \"auto\", halign: \"left\", fontStyle: \"bold\" },\n      1: { cellWidth: 150, halign: \"right\", fontStyle: \"bold\", textColor: [headerR, headerG, headerB] },\n    },\n    alternateRowStyles: {\n      fillColor: [249, 250, 251]\n    },\n  });\n\n  const finalY = (doc.lastAutoTable?.finalY || summaryY) + 50; // Optimize edilmiş boşluk: 50pt\n  return finalY;\n};\n\n// Font yükleme durumunu takip etmek için doc objesine property ekle\ninterface jsPDFWithFontStatus extends jsPDF {\n  _robotoFontLoaded?: boolean;\n  _robotoFontLoadFailed?: boolean; // Font yükleme başarısız olduysa tekrar deneme\n  _robotoSupportsTurkish?: boolean; // Font'un Türkçe karakterleri destekleyip desteklemediği\n  _turkishCharsTested?: boolean; // Türkçe karakter testi yapıldı mı?\n  lastAutoTable?: {\n    finalY?: number;\n  };\n}\n\n// Font URLs (Google Fonts CDN) - Artık kullanılmıyor ama referans için tutulabilir veya silinebilir\n// const ROBOTO_REGULAR_URL = \"https://fonts.gstatic.com/s/roboto/v30/KFOmCnqEu92Fr1Mu4mxP.ttf\";\n// const ROBOTO_BOLD_URL = \"https://fonts.gstatic.com/s/roboto/v30/KFOlCnqEu92Fr1MmWUlfBBc9.ttf\";\n\n// Font cache - Base64 import edildiği için gerek kalmadı\n// const fontCache: Record<string, string> = {};\n\n// Fetch font and convert to base64 - Artık kullanılmıyor\n// const fetchFont = async (url: string): Promise<string> => { ... };\n\nconst isRobotoName = (fontName?: string): boolean => {\n  if (!fontName) return false;\n  return fontName.toLowerCase().includes(\"roboto\");\n};\n\n// Güçlendirilmiş Font Yönetimi\nconst registerFonts = async (doc: jsPDFWithFontStatus) => {\n  // Eğer font zaten yüklendiyse tekrar yükleme\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    // Font'un gerçekten yüklü olduğunu doğrula\n    try {\n      const currentFont = doc.getFont();\n      if (currentFont && isRobotoName(currentFont.fontName)) {\n        // Font yüklü, Türkçe karakter desteğini test et\n        try {\n          doc.setFontSize(12);\n          doc.text(\"İğüşöç\", -1000, -1000);\n          return; // Font zaten yüklü ve çalışıyor\n        } catch (testError) {\n          // Türkçe karakter testi başarısız, ama font yüklü olabilir\n          // Font'u yeniden yükle\n          doc._robotoFontLoaded = false;\n        }\n      } else {\n        // Font yüklü değil, yeniden yükle\n        doc._robotoFontLoaded = false;\n      }\n    } catch {\n      // Font kontrolü başarısız, yeniden yükle\n      doc._robotoFontLoaded = false;\n    }\n  }\n\n  // Eğer daha önce yükleme başarısız olduysa, tekrar dene (flag'i reset et)\n  if (doc._robotoFontLoadFailed) {\n    // Bir kez daha deneme şansı ver\n    doc._robotoFontLoadFailed = false;\n    // Devam et, font yükleme işlemini tekrar dene\n  }\n\n  // Font string'lerinin kesilmiş olup olmadığını kontrol et\n  // Eğer \"...\" ile bitiyorsa, font string'leri kesilmiş demektir\n  // Ayrıca string'lerin çok kısa olup olmadığını kontrol et (base64 font'lar genellikle çok uzun olur)\n  if (ROBOTO_REGULAR_BASE64.endsWith('...') || ROBOTO_BOLD_BASE64.endsWith('...') ||\n    ROBOTO_REGULAR_BASE64.length < 1000 || ROBOTO_BOLD_BASE64.length < 1000) {\n    doc.setFont(\"helvetica\", \"normal\");\n    doc._robotoFontLoaded = false;\n    doc._robotoFontLoadFailed = true;\n    return;\n  }\n\n  try {\n    // Base64 string'lerin düzgün formatta olduğundan emin ol\n    // Önce data: prefix'i varsa temizle\n    let cleanRegular = ROBOTO_REGULAR_BASE64.replace(/^data:.*?,/, '').trim();\n    let cleanBold = ROBOTO_BOLD_BASE64.replace(/^data:.*?,/, '').trim();\n\n\n    // \"...\" gibi kesilme işaretlerini kaldır (eğer varsa)\n    cleanRegular = cleanRegular.replace(/\\.\\.\\.$/, '').trim();\n    cleanBold = cleanBold.replace(/\\.\\.\\.$/, '').trim();\n\n    // Eğer string'ler boşsa, direkt helvetica'ya geç\n    if (!cleanRegular || !cleanBold || cleanRegular.length === 0 || cleanBold.length === 0) {\n      throw new Error(\"Font base64 string'leri boş\");\n    }\n\n    // Tüm whitespace karakterlerini kaldır (boşluk, tab, newline, vb.)\n    cleanRegular = cleanRegular.replace(/\\s+/g, '');\n    cleanBold = cleanBold.replace(/\\s+/g, '');\n\n    // Sadece geçerli base64 karakterlerini tut (A-Z, a-z, 0-9, +, /, =)\n    cleanRegular = cleanRegular.replace(/[^A-Za-z0-9+/=]/g, '');\n    cleanBold = cleanBold.replace(/[^A-Za-z0-9+/=]/g, '');\n\n    // Padding düzeltmesi (Base64 string uzunluğu 4'ün katı olmalı)\n    const regularPadding = (4 - (cleanRegular.length % 4)) % 4;\n    const boldPadding = (4 - (cleanBold.length % 4)) % 4;\n    cleanRegular += '='.repeat(regularPadding);\n    cleanBold += '='.repeat(boldPadding);\n\n    if (cleanRegular.length === 0 || cleanBold.length === 0) {\n      throw new Error(\"Font base64 string'leri boş\");\n    }\n\n    // Add to VFS - her adımda hata kontrolü yap\n    try {\n      doc.addFileToVFS(\"Roboto-Regular.ttf\", cleanRegular);\n      doc.addFileToVFS(\"Roboto-Bold.ttf\", cleanBold);\n    } catch (vfsError) {\n      throw new Error(\"Font VFS'e eklenemedi: \" + vfsError);\n    }\n\n    // Add fonts - her adımda hata kontrolü yap\n    // ÖNEMLİ: Font'u eklemeden önce VFS'de olduğundan emin ol\n    try {\n      const fontListBefore = doc.getFontList();\n\n      // Font'u ekle - font adı \"Roboto\" olmalı\n      doc.addFont(\"Roboto-Regular.ttf\", \"Roboto\", \"normal\");\n\n      // Font'un eklendiğini doğrula\n      const fontListAfterRegular = doc.getFontList();\n      const hasRobotoRegular = fontListAfterRegular && Object.keys(fontListAfterRegular).some((key) => isRobotoName(key));\n\n\n      if (!hasRobotoRegular) {\n        throw new Error(\"Roboto Regular font eklenemedi\");\n      }\n\n      doc.addFont(\"Roboto-Bold.ttf\", \"Roboto\", \"bold\");\n\n      // Font'un eklendiğini doğrula\n      const fontListAfterBold = doc.getFontList();\n      const hasRobotoBold = fontListAfterBold && Object.keys(fontListAfterBold).some((key) => isRobotoName(key));\n\n      if (!hasRobotoBold) {\n        // Roboto Bold font eklenemedi, ama Regular yüklü\n      }\n    } catch (addFontError) {\n      // Font eklenemedi, VFS'den temizle\n      try {\n        // VFS'den silmek için bir yöntem yok, ama flag'i set edelim\n      } catch (error) {\n        // VFS'den silmek için bir yöntem yok, ama flag'i set edelim\n      }\n      throw new Error(\"Font eklenemedi: \" + addFontError);\n    }\n\n    // Set default font ve test et\n    try {\n      doc.setFont(\"Roboto\", \"normal\");\n\n      const fontAfterSet = doc.getFont();\n    } catch (setFontError) {\n      throw new Error(\"Font ayarlanamadı: \" + setFontError);\n    }\n\n    // Font'un gerçekten yüklendiğini test et - basit bir text yazmayı dene\n    try {\n      const fontList = doc.getFontList();\n      // Font listesinde Roboto var mı kontrol et\n      const hasRoboto =\n        fontList &&\n        Object.keys(fontList).some((fontKey) => isRobotoName(fontKey));\n\n\n      if (!hasRoboto) {\n        throw new Error(\"Roboto font listesinde bulunamadı\");\n      }\n      // Font'un gerçekten çalıştığını test et - Türkçe karakter testi\n      const currentFont = doc.getFont();\n      if (!currentFont || !isRobotoName(currentFont.fontName)) {\n        throw new Error(\"Font ayarlandı ama font name eşleşmiyor\");\n      }\n\n      // Türkçe karakter testi - \"İğüşöç\" karakterlerini test et - daha kapsamlı test\n      // Özellikle ş, ç, ğ, İ karakterlerini test et (kullanıcının belirttiği karakterler)\n      let turkishTestPassed = false;\n      try {\n        doc.setFontSize(12);\n        // Test text'i yaz (görünmez bir yere) - tüm Türkçe karakterleri test et\n        // Özellikle ş, ç, ğ, İ karakterlerini test et (kullanıcının belirttiği karakterler)\n        const testText = \"İğüşöçÇĞÜŞÖÇşçğİŞÇĞ\";\n\n        // Font'u tekrar ayarla ve test et - daha agresif\n        for (let i = 0; i < 5; i++) {\n          try {\n            doc.setFont(\"Roboto\", \"normal\");\n            doc.setFontSize(12);\n            const checkFont = doc.getFont();\n            if (checkFont && isRobotoName(checkFont.fontName)) {\n              // Font Roboto, test text'i yaz\n              doc.text(testText, -1000, -1000);\n              turkishTestPassed = true;\n              break;\n            }\n          } catch {\n            // Tekrar dene\n          }\n        }\n\n        if (!turkishTestPassed) {\n          // Türkçe karakter testi başarısız, ama font yüklü olabilir\n          // Font listesini kontrol et\n          try {\n            const fontList = doc.getFontList();\n            const hasRoboto = fontList && Object.keys(fontList).some((key) => isRobotoName(key));\n            if (hasRoboto) {\n              // Font listesinde var, yükleme başarılı sayılabilir\n              turkishTestPassed = true;\n            }\n          } catch {\n            // Font listesi alınamadı\n          }\n        }\n\n        // Font'un gerçekten çalıştığını doğrula\n        const verifyFont = doc.getFont();\n        if (verifyFont && isRobotoName(verifyFont.fontName) && turkishTestPassed) {\n          doc._robotoFontLoaded = true;\n          doc._robotoFontLoadFailed = false;\n          // Font yüklü ve ayarlanmış - Türkçe karakterleri destekliyor\n        } else if (turkishTestPassed) {\n          // Türkçe test başarılı ama font adı eşleşmiyor, yine de kabul et\n          doc._robotoFontLoaded = true;\n          doc._robotoFontLoadFailed = false;\n        } else {\n          throw new Error(\"Font test sonrası doğrulama başarısız\");\n        }\n      } catch (textWriteError) {\n        // Text yazma hatası - font Türkçe karakterleri desteklemiyor olabilir\n        // Ama yine de font yüklü olabilir, bu yüzden devam et\n        // Font listesinde varsa kabul et\n        try {\n          const fontList = doc.getFontList();\n          const hasRoboto = fontList && Object.keys(fontList).some((key) => isRobotoName(key));\n          const currentFont = doc.getFont();\n          if (hasRoboto && currentFont && isRobotoName(currentFont.fontName)) {\n            doc._robotoFontLoaded = true;\n            doc._robotoFontLoadFailed = false;\n          } else {\n            throw new Error(\"Font test başarısız: \" + textWriteError);\n          }\n        } catch (finalError) {\n          throw new Error(\"Font test başarısız: \" + textWriteError);\n        }\n      }\n    } catch (fontTestError) {\n      // Font test başarısız, helvetica'ya geç\n      doc.setFont(\"helvetica\", \"normal\");\n      throw new Error(\"Font yüklendi ama kullanılamıyor: \" + fontTestError);\n    }\n  } catch (e) {\n    doc.setFont(\"helvetica\", \"normal\");\n    doc._robotoFontLoaded = false;\n    doc._robotoFontLoadFailed = true; // Bir daha deneme\n  }\n};\n\nconst safeSetFont = (doc: jsPDFWithFontStatus, style: \"normal\" | \"bold\" = \"normal\") => {\n  // Font yüklenmemişse veya yükleme başarısızsa direkt helvetica kullan\n  if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n    try {\n      doc.setFont(\"helvetica\", style);\n    } catch {\n      // Helvetica bile başarısız olursa hiçbir şey yapma\n    }\n    return;\n  }\n\n  // Roboto font'unu zorla ayarla - daha agresif yaklaşım\n\n  let attempts = 0;\n  let fontSet = false;\n  const maxAttempts = 3;\n\n  while (attempts < maxAttempts && !fontSet) {\n    try {\n      // Roboto font'unu kullanmayı dene\n      doc.setFont(\"Roboto\", style);\n\n      // Font'un gerçekten ayarlandığını kontrol et - daha sıkı kontrol\n      const currentFont = doc.getFont();\n      if (currentFont && isRobotoName(currentFont.fontName)) {\n        // Font başarıyla ayarlandı, doğrula\n        // Türkçe karakter testi yap (görünmez yere)\n        try {\n          doc.setFontSize(12);\n          doc.text(\"İğüşöç\", -1000, -1000);\n          fontSet = true;\n          break;\n        } catch (testError) {\n          // Test başarısız ama font yüklü olabilir, font listesini kontrol et\n          const fontList = doc.getFontList();\n          const hasRoboto = fontList && Object.keys(fontList).some((key) => isRobotoName(key));\n          if (hasRoboto) {\n            fontSet = true;\n            break;\n          }\n        }\n      }\n\n      attempts++;\n      if (attempts < maxAttempts) {\n        // Kısa bir bekleme (synchronous delay simülasyonu)\n        // Tekrar dene\n      }\n    } catch (error) {\n      attempts++;\n      if (attempts >= maxAttempts) {\n        // Tüm denemeler başarısız, helvetica'ya geç\n        try {\n          doc.setFont(\"helvetica\", style);\n          doc._robotoFontLoaded = false;\n          doc._robotoFontLoadFailed = true;\n        } catch {\n          // Son çare: hiçbir şey yapma\n        }\n        return;\n      }\n    }\n  }\n\n  // Font ayarlanamadıysa helvetica'ya geri dön\n  if (!fontSet) {\n    try {\n      doc.setFont(\"helvetica\", style);\n      doc._robotoFontLoaded = false;\n      doc._robotoFontLoadFailed = true;\n    } catch {\n      // Son çare: hiçbir şey yapma\n    }\n  }\n};\n\n// Güçlendirilmiş Tipografi Ayarları\nconst applyDocumentTypography = (doc: jsPDFWithFontStatus) => {\n  doc.setLineHeightFactor(1.5); // Profesyonel satır aralığı (1.4 → 1.5)\n\n  // Font'u ÇOK AGRESİF şekilde ayarla - MUTLAKA Roboto kullan\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    // Font'u 10 kez deneyerek zorla Roboto olarak ayarla\n    let fontSet = false;\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          fontSet = true;\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n\n    if (!fontSet) {\n      // Font ayarlanamadı, Helvetica'ya geç\n      doc.setFont(\"helvetica\", \"normal\");\n      doc._robotoFontLoaded = false;\n      doc._robotoFontLoadFailed = true;\n    } else {\n      // Font başarıyla ayarlandı, doğrula\n      const verifyFont = doc.getFont();\n      if (verifyFont && isRobotoName(verifyFont.fontName)) {\n      }\n    }\n  } else {\n    doc.setFont(\"helvetica\", \"normal\");\n  }\n\n  doc.setFontSize(11); // Profesyonel font boyutu\n};\n\n// Font'u zorla Roboto olarak ayarla - helper fonksiyon\nconst forceRobotoFont = (doc: jsPDFWithFontStatus, style: \"normal\" | \"bold\" = \"normal\") => {\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", style);\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          return true;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n  return false;\n};\n\nconst getFontName = (doc?: jsPDFWithFontStatus): string => {\n  // Roboto font yüklüyse ve başarısız olmadıysa kullan\n  if (doc?._robotoFontLoaded && !doc?._robotoFontLoadFailed) {\n    // Font'un gerçekten yüklü olduğunu kontrol et\n    try {\n      // Önce mevcut font'u kontrol et\n      const currentFont = doc?.getFont();\n      if (currentFont && isRobotoName(currentFont.fontName)) {\n        return \"Roboto\";\n      }\n\n      // Font listesini kontrol et\n      const fontList = doc?.getFontList();\n      if (fontList && Object.keys(fontList).some((key) => isRobotoName(key))) {\n        // Font listesinde var, zorla ayarla\n        try {\n          doc?.setFont(\"Roboto\", \"normal\");\n          const verifyFont = doc?.getFont();\n          if (verifyFont && isRobotoName(verifyFont.fontName)) {\n            return \"Roboto\";\n          }\n        } catch {\n          // Font ayarlanamadı\n        }\n        // Yine de Roboto döndür - font listesinde var\n        return \"Roboto\";\n      }\n    } catch (error) {\n      // Font kontrolü başarısız, ama yine de Roboto dene\n      if (doc?._robotoFontLoaded && !doc?._robotoFontLoadFailed) {\n        return \"Roboto\";\n      }\n    }\n  }\n  // Eğer Roboto yüklenemezse, Helvetica kullan (autoTable için)\n  // Helvetica Türkçe karakterleri desteklemez ama en azından çalışır\n  return \"helvetica\";\n};\n\n// Güçlendirilmiş Türkçe Karakter Desteği - willDrawCell hook'u (didParseCell yerine)\n// willDrawCell daha geç çalışır ve font ayarlarının override edilmesini önler\ninterface CellHookData {\n  cell?: {\n    text?: string | string[];\n    fontStyle?: string;\n    font?: string;\n    styles?: {\n      font?: string;\n      fontStyle?: string;\n      fontSize?: number;\n    };\n    x?: number;\n    y?: number;\n    width?: number;\n    height?: number;\n  };\n  row?: {\n    index?: number;\n  };\n  column?: {\n    index?: number;\n  };\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n}\n\nconst createWillDrawCell = (doc: jsPDFWithFontStatus) => {\n  return (data: CellHookData) => {\n    if (!data.cell) return;\n\n    const cell = data.cell;\n\n    // Font style'ı belirle\n    const fontStyle = (cell.fontStyle === \"bold\" || cell.styles?.fontStyle === \"bold\" || cell.styles?.font === \"bold\") ? \"bold\" : \"normal\";\n\n    // Eğer Roboto font yüklüyse, font'u zorla ayarla\n    if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n      try {\n        // Font'u güvenli şekilde ayarla - daha agresif\n        safeSetFont(doc, fontStyle);\n\n        // Font'un gerçekten Roboto olduğunu kontrol et - daha sıkı kontrol\n        let attempts = 0;\n        let fontVerified = false;\n        const maxAttempts = 10;\n\n        while (attempts < maxAttempts && !fontVerified) {\n          try {\n            doc.setFont(\"Roboto\", fontStyle);\n            const currentFont = doc.getFont();\n            if (currentFont && isRobotoName(currentFont.fontName)) {\n              fontVerified = true;\n              break;\n            }\n            attempts++;\n          } catch {\n            attempts++;\n            if (attempts >= maxAttempts) break;\n          }\n        }\n\n        // cell.styles'i mutlaka ayarla\n        if (!cell.styles) {\n          cell.styles = {};\n        }\n\n        if (fontVerified) {\n          // Font Roboto - cell.styles.font kullan (willDrawCell'de bu daha etkili)\n          cell.styles.font = \"Roboto\";\n          cell.styles.fontStyle = fontStyle;\n\n          // Roboto font Türkçe karakterleri destekler, translitere etmeye gerek yok\n          // Text'i olduğu gibi bırak - Türkçe karakterler korunacak\n\n          // Font ayarlaması için string kontrolü yap\n          const textString = typeof cell.text === 'string' ? cell.text : (Array.isArray(cell.text) ? (cell.text as string[]).join(' ') : '');\n          if (textString) {\n            // Font'u zorla ayarla - Roboto kullan\n            try {\n              const fontList = doc.getFontList();\n              const hasRoboto = fontList && Object.keys(fontList).some((key) => isRobotoName(key));\n              if (hasRoboto) {\n                // Font listesinde var, zorla ayarla\n                for (let i = 0; i < 10; i++) {\n                  try {\n                    doc.setFont(\"Roboto\", fontStyle);\n                    if (cell.styles?.fontSize) {\n                      doc.setFontSize(cell.styles.fontSize);\n                    }\n                    const verifyFont = doc.getFont();\n                    if (verifyFont && isRobotoName(verifyFont.fontName)) {\n                      break;\n                    }\n                  } catch {\n                    // Tekrar dene\n                  }\n                }\n              }\n            } catch {\n              // Font listesi alınamadı, yine de zorla ayarla\n              try {\n                doc.setFont(\"Roboto\", fontStyle);\n                if (cell.styles?.fontSize) {\n                  doc.setFontSize(cell.styles.fontSize);\n                }\n              } catch {\n                // Font ayarlanamadı\n              }\n            }\n          } else {\n            // Text yok, normal font ayarlaması yap\n            for (let i = 0; i < 5; i++) {\n              try {\n                doc.setFont(\"Roboto\", fontStyle);\n                const verifyFont = doc.getFont();\n                if (verifyFont && isRobotoName(verifyFont.fontName)) {\n                  break;\n                }\n              } catch {\n                // Tekrar dene\n              }\n            }\n          }\n        } else {\n          // Font Roboto değilse, Helvetica'ya geç\n          cell.styles.font = \"helvetica\";\n          cell.styles.fontStyle = fontStyle;\n\n          // Helvetica Türkçe karakterleri desteklemiyor, transliterate et\n          if (cell.text && typeof cell.text === 'string') {\n            try {\n              cell.text = transliterateTurkish(cell.text);\n            } catch {\n              // Text değiştirilemez, devam et\n            }\n          } else if (cell.text && Array.isArray(cell.text)) {\n            try {\n              cell.text = (cell.text as string[]).map((item: unknown): string => {\n                if (typeof item === 'string') {\n                  return transliterateTurkish(item);\n                }\n                return String(item);\n              });\n            } catch {\n              // Text değiştirilemez, devam et\n            }\n          }\n        }\n      } catch {\n        // Font ayarlama hatası, Helvetica'ya geç\n        if (!cell.styles) {\n          cell.styles = {};\n        }\n        cell.styles.font = \"helvetica\";\n        cell.styles.fontStyle = fontStyle;\n      }\n    } else {\n      // Helvetica kullanılıyorsa veya font yüklenmemişse\n      if (!cell.styles) {\n        cell.styles = {};\n      }\n      cell.styles.font = \"helvetica\";\n      cell.styles.fontStyle = fontStyle;\n\n      // Helvetica Türkçe karakterleri desteklemiyor, transliterate et\n      if (cell.text) {\n        if (typeof cell.text === 'string') {\n          try {\n            cell.text = transliterateTurkish(cell.text);\n          } catch {\n            // Text değiştirilemez, devam et\n          }\n        } else if (Array.isArray(cell.text)) {\n          try {\n            cell.text = (cell.text as string[]).map((item: unknown): string => {\n              if (typeof item === 'string') {\n                return transliterateTurkish(item);\n              }\n              return String(item);\n            });\n          } catch {\n            // Text değiştirilemez, devam et\n          }\n        }\n      }\n    }\n  };\n};\n\n// Eski didParseCell hook'u - geriye dönük uyumluluk için (kullanılmıyor ama silmiyoruz)\nconst createDidParseCell = (doc: jsPDFWithFontStatus) => {\n  return (data: CellHookData) => {\n    // willDrawCell kullanıyoruz, bu fonksiyon artık kullanılmıyor\n    // Ama bazı yerlerde hala didParseCell kullanılıyor olabilir, bu yüzden willDrawCell'i çağır\n    return createWillDrawCell(doc)(data);\n  };\n};\n\n// PDF oluşturma helper fonksiyonu\nconst createPdf = (options: jsPDFOptions = { format: \"a4\", unit: \"pt\" }) => {\n  const doc = new jsPDF(options) as jsPDFWithFontStatus;\n  return doc;\n};\n\n// Ortak yardımcı fonksiyonlar\nconst formatDate = (dateStr: string) => {\n  if (!dateStr || dateStr.trim() === \"\") return \"-\";\n  try {\n    const date = new Date(dateStr);\n    // Geçersiz tarih kontrolü\n    if (isNaN(date.getTime()) || !isFinite(date.getTime())) {\n      return \"-\";\n    }\n    const months = [\n      \"Ocak\", \"Şubat\", \"Mart\", \"Nisan\", \"Mayıs\", \"Haziran\",\n      \"Temmuz\", \"Ağustos\", \"Eylül\", \"Ekim\", \"Kasım\", \"Aralık\"\n    ];\n    // Görseldeki format: \"20 Ağustos 2025\" (ay ve yıl arasında boşluk var)\n    const day = date.getDate();\n    const monthIndex = date.getMonth();\n    const year = date.getFullYear();\n\n    // Geçerli değerler kontrolü - tüm değerlerin geçerli olduğundan emin ol\n    if (isNaN(day) || isNaN(monthIndex) || isNaN(year) ||\n      monthIndex < 0 || monthIndex > 11 ||\n      day < 1 || day > 31 ||\n      year < 1900 || year > 2100) {\n      return \"-\";\n    }\n\n    const month = months[monthIndex];\n    if (!month) {\n      return \"-\";\n    }\n\n    return `${day} ${month} ${year}`;\n  } catch (error) {\n    return \"-\";\n  }\n};\n\nconst formatDateShort = (dateStr: string) => {\n  const date = new Date(dateStr);\n  return date.toLocaleDateString('tr-TR');\n};\n\ntype TotalsSummary = {\n  subtotal: number;\n  discount: number;\n  tax: number;\n  grandTotal: number;\n};\n\nconst ensureSpace = (\n  doc: jsPDF,\n  currentY: number,\n  requiredHeight: number,\n  margin = 40,\n  titleForNextPage?: string\n) => {\n  const pageHeight = doc.internal.pageSize.getHeight();\n  const footerHeight = PDF_CONSTANTS.footerHeight;\n\n  // Daha fazla boşluk bırak (70pt ekstra - 50pt'den artırıldı)\n  const minSpaceNeeded = requiredHeight + 70;\n  if (currentY + minSpaceNeeded > pageHeight - footerHeight - margin) {\n    doc.addPage();\n    let nextY = margin + 30; // Üstten 30pt daha fazla boşluk (20pt'den artırıldı)\n\n    // Yeni sayfada template'i uygula\n    const template = createPDFTemplate(doc as jsPDFWithFontStatus);\n    drawPDFBackground(doc as jsPDFWithFontStatus, template);\n\n    if (titleForNextPage) {\n      const safeText = createSafeText(doc as jsPDFWithFontStatus);\n      safeSetFont(doc as jsPDFWithFontStatus, \"bold\");\n      // \"(devam)\" etiketi kaldırıldı - kullanıcı isteği\n    }\n    return nextY;\n  }\n  return currentY;\n};\n\nconst formatCurrency = (value: number, currency = \"₺\") => {\n  const safeValue = Number.isFinite(value) ? value : 0;\n  // Binlik ayırıcılar ile formatla (web UI ile uyumlu)\n  const formatted = safeValue.toLocaleString(\"tr-TR\", {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  });\n  return `${currency}${formatted}`;\n};\n\n// Optimize edilmiş helper fonksiyonlar - tüm PDF'lerde kullanılabilir\nconst safeNumber = (value: unknown): number => {\n  const num = Number(value);\n  return (isNaN(num) || !isFinite(num)) ? 0 : num;\n};\n\nconst safeFormatCurrency = (value: number): string => {\n  const safeVal = safeNumber(value);\n  // Daha okunabilir format: binlik ayırıcılar ve 2 ondalık basamak\n  const formatted = safeVal.toLocaleString(\"tr-TR\", {\n    minimumFractionDigits: 2,\n    maximumFractionDigits: 2\n  });\n  return `₺${formatted}`;\n};\n\nconst drawInfoCard = (\n  doc: jsPDF,\n  {\n    x,\n    y,\n    width,\n    title,\n    rows,\n  }: { x: number; y: number; width: number; title: string; rows: Array<{ label: string; value?: string }> }\n) => {\n  const padding = 16;\n  const innerWidth = width - padding * 2;\n  const preparedRows = rows.map((row) => ({\n    label: row.label,\n    lines: doc.splitTextToSize(row.value && row.value.trim() ? row.value : \"-\", innerWidth),\n  }));\n  const baseHeight = padding + 18;\n  const rowsHeight = preparedRows.reduce((sum, row) => sum + 12 + row.lines.length * 14 + 6, 0);\n  const height = baseHeight + rowsHeight + padding / 2;\n\n  doc.setFillColor(248, 249, 252);\n  doc.setDrawColor(229, 234, 244);\n  doc.roundedRect(x, y, width, height, 10, 10, \"F\");\n  doc.roundedRect(x, y, width, height, 10, 10, \"S\");\n\n  const safeText = createSafeText(doc as jsPDFWithFontStatus);\n  let cursorY = y + padding;\n  safeText(title, x + padding, cursorY, 12, true);\n  cursorY += 18;\n\n  preparedRows.forEach((row) => {\n    safeText(row.label.toUpperCase(), x + padding, cursorY, 9, true);\n    cursorY += 12;\n\n    row.lines.forEach((line) => {\n      safeText(line, x + padding, cursorY, 11, false);\n      cursorY += 14;\n    });\n    cursorY += 6;\n  });\n\n  doc.setTextColor(0, 0, 0);\n  return height;\n};\n\nconst drawTermsBlock = (\n  doc: jsPDF,\n  { x, y, width, terms }: { x: number; y: number; width: number; terms?: string[] }\n) => {\n  const padding = 16;\n  const innerWidth = width - padding * 2;\n  const termsList = (terms && terms.length > 0 ? terms : [\"Özel şart belirtilmemiştir.\"]).filter(\n    (term) => term && term.trim()\n  );\n  const termLines = termsList.flatMap((term) => doc.splitTextToSize(`• ${term}`, innerWidth));\n  const height = padding * 2 + 18 + termLines.length * 14;\n\n  doc.setFillColor(253, 253, 255);\n  doc.setDrawColor(229, 234, 244);\n  doc.roundedRect(x, y, width, height, 10, 10, \"F\");\n  doc.roundedRect(x, y, width, height, 10, 10, \"S\");\n\n  const safeText = createSafeText(doc as jsPDFWithFontStatus);\n  let cursorY = y + padding;\n  safeText(\"Şartlar\", x + padding, cursorY, 12, true);\n  cursorY += 18;\n\n  termLines.forEach((line) => {\n    safeText(line, x + padding, cursorY, 11, false);\n    cursorY += 14;\n  });\n\n  doc.setTextColor(0, 0, 0);\n  return height;\n};\n\nconst drawSummaryBlock = (\n  doc: jsPDF,\n  {\n    x,\n    y,\n    width,\n    totals,\n    currency,\n    taxRate,\n  }: { x: number; y: number; width: number; totals: TotalsSummary; currency: string; taxRate: number }\n) => {\n  const padding = 16;\n  const rows: Array<{ label: string; value: string; isAccent?: boolean }> = [];\n\n  if ((totals.discount || 0) > 0) {\n    rows.push({\n      label: \"Toplam İskonto\",\n      value: `-${formatCurrency(totals.discount, currency)}`,\n      isAccent: true,\n    });\n  }\n\n  rows.push(\n    { label: \"Ara Toplam\", value: formatCurrency(totals.subtotal, currency) },\n    { label: `KDV (%${taxRate || 0})`, value: formatCurrency(totals.tax, currency) }\n  );\n\n  const contentHeight = rows.length * 20 + 40;\n  const height = padding * 2 + contentHeight + 32;\n\n  doc.setFillColor(248, 249, 252);\n  doc.setDrawColor(229, 234, 244);\n  doc.roundedRect(x, y, width, height, 10, 10, \"F\");\n  doc.roundedRect(x, y, width, height, 10, 10, \"S\");\n\n  const safeText = createSafeText(doc as jsPDFWithFontStatus);\n  let cursorY = y + padding;\n  safeText(\"Ödeme Özeti\", x + padding, cursorY, 12, true);\n  cursorY += 18;\n\n  rows.forEach((row) => {\n    safeText(row.label, x + padding, cursorY, 10, true);\n\n    const valueWidth = doc.getTextWidth(row.value);\n    safeText(row.value, x + width - padding - valueWidth, cursorY, row.isAccent ? 11 : 11, row.isAccent);\n    cursorY += 20;\n  });\n\n  doc.setDrawColor(229, 234, 244);\n  doc.line(x + padding, cursorY, x + width - padding, cursorY);\n  cursorY += 18;\n\n  safeText(\"GENEL TOPLAM\", x + padding, cursorY, 13, true);\n\n  const grandTotalText = formatCurrency(totals.grandTotal, currency);\n  const grandTotalWidth = doc.getTextWidth(grandTotalText);\n  safeText(grandTotalText, x + width - padding - grandTotalWidth, cursorY, 16, true);\n\n  doc.setTextColor(0, 0, 0);\n  return height;\n};\n\n// Header template'i - sabit komponentler + dinamik içerik\nconst drawPDFHeader = (doc: jsPDFWithFontStatus, template: PDFTemplateLayout, title: string, reportDate: string, startDate?: string, endDate?: string) => {\n  const mar = PDF_CONSTANTS.margin;\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const logoSize = PDF_CONSTANTS.logoSize;\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // Header çizgisi header içeriğinden SONRA çizilecek (drawPDFHeader içinde)\n\n  const safeText = createSafeText(doc);\n\n  // Font'u Roboto olarak ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  // YENİ HEADER TASARIMI: Logo sol, Başlık orta, Tarih/Şirket bilgileri sağ\n\n  // === SOL TARAF: Logo ve REVIUM (en solda, margin içinde) ===\n  const logoX = mar; // En solda, margin'den başlar\n  const logoY = 35; // Üstten 35px (25 → 35, üstte ek boşluk)\n  const logoFramePadding = 2; // Çerçeve padding'i\n  const logoFrameSize = logoSize + (logoFramePadding * 2); // Çerçeve boyutu\n\n  // Logo için arka plan kutusu - minimal\n  doc.setFillColor(255, 255, 255);\n  doc.roundedRect(logoX - logoFramePadding, logoY - logoFramePadding, logoFrameSize, logoFrameSize, 4, 4, \"F\");\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.1 }));\n  doc.setLineWidth(1);\n  doc.roundedRect(logoX - logoFramePadding, logoY - logoFramePadding, logoFrameSize, logoFrameSize, 4, 4, \"S\");\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  try {\n    doc.addImage(REV_LOGO_DATA_URI, 'PNG', logoX, logoY, logoSize, logoSize);\n  } catch (error) {\n    // Logo eklenemezse sessizce devam et\n  }\n\n  // REVIUM brand name - logonun ÇERÇEVESİNİN altında ORTALANMIŞ\n  doc.setTextColor(primaryR, primaryG, primaryB);\n  // REVIUM text genişliğini hesapla ve logonun çerçevesinin ortasına hizala\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    doc.setFont(\"Roboto\", \"bold\");\n    doc.setFontSize(14);\n  } else {\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setFontSize(14);\n  }\n  const reviumTextWidth = doc.getTextWidth(\"REVIUM\");\n  const reviumX = logoX - logoFramePadding + (logoFrameSize / 2) - (reviumTextWidth / 2); // Çerçeve ortasına hizala\n  const reviumY = logoY + logoSize + logoFramePadding + 12; // Logo + çerçeve altından 12px aşağı (6 → 12, daha aşağı)\n  safeText(\"REVIUM\", reviumX, reviumY, 14, true);\n  doc.setTextColor(0, 0, 0);\n\n  // === ORTA TARAF: Başlık (sayfa genişliğinde ortalanmış) ===\n  // Başlığı sayfa genişliğinde ortala\n  const titleY = 45; // Üstten 45px (35 → 45, üstte ek boşluk)\n\n  // Report title - dinamik (sayfa genişliğinde ortada)\n  doc.setTextColor(primaryR, primaryG, primaryB);\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"bold\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n    doc.setFontSize(22);\n  } else {\n    doc.setFont(\"helvetica\", \"bold\");\n    doc.setFontSize(22);\n  }\n\n  // Başlık genişliğini hesapla ve sayfa genişliğinde ortala\n  const titleWidth = doc.getTextWidth(title);\n  const titleStartX = (pageWidth - titleWidth) / 2; // Sayfa genişliğinin ortası\n\n  safeText(title, titleStartX, titleY, 22, true);\n\n  // Title altında ince çizgi\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.2 }));\n  doc.setLineWidth(1.5);\n  doc.line(titleStartX, titleY + 7, titleStartX + titleWidth, titleY + 7);\n  doc.setGState(doc.GState({ opacity: 1 }));\n  doc.setTextColor(0, 0, 0);\n\n  // === SAĞ TARAF: Tarih (en üst) ve Şirket Bilgileri (altında) ===\n  const rightSectionX = pageWidth - mar - 200; // Sağdan 200px içeride (taşmaması için)\n  let rightSectionY = 30; // En üstten başlar (20 → 30, üstte ek boşluk)\n\n  // Telefon numarası genişliğini hesapla (referans pozisyon için - önce hesapla)\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    doc.setFont(\"Roboto\", \"normal\");\n    doc.setFontSize(8);\n  } else {\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setFontSize(8);\n  }\n  const phoneText = \"+90 (551) 829-1613\";\n  const phoneTextWidth = doc.getTextWidth(phoneText);\n  const phoneX = pageWidth - mar - phoneTextWidth; // Sağa hizalı - referans pozisyon\n\n  // \"2025\" metninin genişliğini hesapla (sağa kaydırma miktarı için)\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    doc.setFont(\"Roboto\", \"normal\");\n    doc.setFontSize(9);\n  } else {\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setFontSize(9);\n  }\n  const year2025Width = doc.getTextWidth(\"2025\");\n  // Tüm bilgileri \"2025\" genişliği kadar sağa kaydır\n  const rightInfoX = phoneX - year2025Width;\n\n  // 1. TARİH BİLGİLERİ - Telefon numarasıyla aynı hizaya alındı, \"2025\" genişliği kadar sağa kaydırıldı\n  doc.setTextColor(mutedR, mutedG, mutedB);\n\n  if (startDate && endDate) {\n    // Dönem bilgisi - sağa kaydırılmış pozisyon\n    safeText(`Dönem: ${formatDateShort(startDate)} - ${formatDateShort(endDate)}`, rightInfoX, rightSectionY, 9, false);\n\n    // Rapor tarihi (altında, sağa kaydırılmış pozisyon)\n    rightSectionY += 12; // Bir sonraki satır için boşluk\n    safeText(`Tarih: ${reportDate}`, rightInfoX, rightSectionY, 9, true);\n\n    rightSectionY += 15; // Şirket bilgileri için boşluk\n  } else {\n    // Sadece rapor tarihi varsa\n    safeText(`Tarih: ${reportDate}`, rightInfoX, rightSectionY, 9, true);\n\n    rightSectionY += 15; // Şirket bilgileri için boşluk\n  }\n\n  doc.setTextColor(0, 0, 0);\n\n  // 2. ŞİRKET BİLGİLERİ - Tarih altında, YETERLİ BOŞLUKLA (sağa kaydırılmış pozisyon)\n  let companyInfoY = rightSectionY; // Tarih bilgilerinden sonra başlar\n\n  // Tüm bilgiler sağa kaydırılmış X pozisyonundan hizalı\n  doc.setTextColor(mutedR, mutedG, mutedB);\n  // Adres - ilk satır (Milenyum Cad. alt satıra alındı)\n  safeText(\"Fevzi Cakmak Mah.\", rightInfoX, companyInfoY, 8, false); // Sağa kaydırılmış pozisyon\n  companyInfoY += 10; // Satırlar arası boşluk\n  safeText(\"Milenyum Cad. No:81\", rightInfoX, companyInfoY, 8, false); // Milenyum Cad. alt satırda\n  companyInfoY += 10; // Satırlar arası boşluk\n  safeText(COMPANY_INFO.city, rightInfoX, companyInfoY, 8, false); // Sağa kaydırılmış pozisyon\n  companyInfoY += 10;\n  // Email - alt satırda (sağa kaydırılmış pozisyon)\n  safeText(\"info@reviumtech.com\", rightInfoX, companyInfoY, 8, false);\n  companyInfoY += 10;\n  // Website - alt satırda (sağa kaydırılmış pozisyon)\n  safeText(\"www.reviumtech.com\", rightInfoX, companyInfoY, 8, false);\n  companyInfoY += 10;\n  // Telefon numarası - sağa kaydırılmış pozisyon (ama telefon numarası kendisi sağa hizalı kalacak)\n  // Telefon numarasını sağa hizalı tutmak için, rightInfoX'ten başlayıp genişliğini hesaplayarak sağa hizala\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    doc.setFont(\"Roboto\", \"normal\");\n    doc.setFontSize(8);\n  } else {\n    doc.setFont(\"helvetica\", \"normal\");\n    doc.setFontSize(8);\n  }\n  const phoneXAligned = rightInfoX; // Sağa kaydırılmış pozisyon, ama telefon numarası kendisi sağa hizalı değil, soldan başlıyor\n  safeText(phoneText, phoneXAligned, companyInfoY, 8, false);\n  doc.setTextColor(0, 0, 0);\n\n  // Header'ın son pozisyonunu hesapla (sol taraftaki logo+REVIUM veya sağ taraftaki şirket bilgileri, hangisi daha aşağıdaysa)\n  const leftSectionEndY = reviumY + 8; // REVIUM yazısı + boşluk (daha aşağıda olduğu için)\n  const headerEndY = Math.max(leftSectionEndY, companyInfoY + 8); // Her iki taraftan da en aşağıdaki pozisyon\n\n  // Header alt çizgisi - header içeriğinden SONRA çiz (istatistiklerin üstünde olması için)\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setLineWidth(2);\n  doc.line(mar, headerEndY + 5, pageWidth - mar, headerEndY + 5); // Header içeriğinden 5px aşağıda\n\n  // Dekoratif çizgi - sabit (daha hafif)\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.2 }));\n  doc.setLineWidth(1);\n  doc.line(mar, headerEndY + 8, pageWidth - mar, headerEndY + 8); // Ana çizgiden 3px aşağıda\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  // Template'in contentStartY'sini güncelle - header'dan sonra yeterli boşluk (altında ek boşluk)\n  return headerEndY + 50; // Header'dan sonra 50px boşluk (30 → 50, altında ek boşluk, içerik aşağı kaydırıldı)\n};\n\n// Footer template'i - sabit komponentler + dinamik sayfa numarası\nconst drawPDFFooter = (doc: jsPDFWithFontStatus, template: PDFTemplateLayout, pageNumber?: number, totalPages?: number) => {\n  const mar = PDF_CONSTANTS.margin;\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const footerY = template.footer.startY;\n  const footerLogoSize = PDF_CONSTANTS.footerLogoSize;\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // Footer üst çizgisi - sabit (daha ince ve profesyonel)\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setLineWidth(1.5); // Daha ince: 2 → 1.5\n  doc.line(mar, footerY - 18, pageWidth - mar, footerY - 18);\n\n  // Dekoratif çizgi - sabit (daha hafif)\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.2 })); // Daha hafif: 0.3 → 0.2\n  doc.setLineWidth(1);\n  doc.line(mar, footerY - 15, pageWidth - mar, footerY - 15);\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  const safeText = createSafeText(doc);\n\n  // Footer bilgileri - sol taraf - sabit bilgiler, cache'lenmiş\n  doc.setTextColor(mutedR, mutedG, mutedB);\n  safeText(COMPANY_INFO.name, mar, footerY, 10, true);\n  safeText(COMPANY_INFO.fullAddress, mar, footerY + 12, 9, false);\n  safeText(COMPANY_INFO.contactInfo, mar, footerY + 24, 9, false);\n  doc.setTextColor(0, 0, 0);\n\n  // Sayfa numarası kaldırıldı - kullanıcı isteği\n\n  // Footer logo - sabit komponent\n  const footerLogoX = pageWidth - mar - footerLogoSize - 120;\n  const footerLogoY = footerY - 3;\n\n  // Logo için arka plan kutusu - sabit\n  try {\n    doc.setFillColor(255, 255, 255);\n    doc.roundedRect(footerLogoX - 3, footerLogoY - 3, footerLogoSize + 6, footerLogoSize + 6, 4, 4, \"F\");\n    doc.setDrawColor(primaryR, primaryG, primaryB);\n    doc.setGState(doc.GState({ opacity: 0.2 }));\n    doc.setLineWidth(1);\n    doc.roundedRect(footerLogoX - 3, footerLogoY - 3, footerLogoSize + 6, footerLogoSize + 6, 4, 4, \"S\");\n    doc.setGState(doc.GState({ opacity: 1 }));\n\n    try {\n      doc.addImage(REV_LOGO_DATA_URI, 'PNG', footerLogoX, footerLogoY, footerLogoSize, footerLogoSize);\n    } catch (error) {\n      // Logo eklenemezse sessizce devam et\n    }\n\n    doc.setTextColor(primaryR, primaryG, primaryB);\n    safeText(\"REVIUM\", footerLogoX + footerLogoSize + 8, footerY + 10, 12, true);\n    doc.setTextColor(0, 0, 0);\n  } catch (logoError) {\n  }\n};\n\n// PDF Template sistemi - tüm sayfalar için sabit layout\nconst applyPDFTemplate = (\n  doc: jsPDFWithFontStatus,\n  title: string,\n  reportDate: string,\n  startDate?: string,\n  endDate?: string\n): PDFTemplateLayout => {\n  // Template layout'u oluştur\n  const template = createPDFTemplate(doc);\n\n  // Arka planı çiz (sabit)\n  drawPDFBackground(doc, template);\n\n  // Header'ı çiz (sabit + dinamik)\n  const contentStartY = drawPDFHeader(doc, template, title, reportDate, startDate, endDate);\n\n  // Content area'yı güncelle (header'dan sonraki gerçek başlangıç pozisyonu)\n  template.contentArea.startY = contentStartY;\n\n  return template;\n};\n\n// Yeni sayfa için template uygula\nconst applyPDFTemplateToNewPage = (doc: jsPDFWithFontStatus, template: PDFTemplateLayout) => {\n  // Yeni sayfa için template'i yeniden hesapla\n  const newTemplate = createPDFTemplate(doc);\n\n  // Arka planı çiz\n  drawPDFBackground(doc, newTemplate);\n\n  // Header'ı çiz (sadece sabit kısımlar, dinamik içerik yok)\n  const mar = PDF_CONSTANTS.margin;\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const logoSize = PDF_CONSTANTS.logoSize;\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // Header alt çizgisi\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setLineWidth(3);\n  doc.line(mar, newTemplate.header.endY, pageWidth - mar, newTemplate.header.endY);\n\n  // Logo ve şirket bilgileri (sadece sabit kısımlar)\n  const rightX = pageWidth - mar - 200;\n  const logoY = 28;\n\n  doc.setFillColor(255, 255, 255);\n  doc.roundedRect(rightX - 5, logoY - 5, logoSize + 10, logoSize + 10, 4, 4, \"F\");\n  doc.setDrawColor(primaryR, primaryG, primaryB);\n  doc.setGState(doc.GState({ opacity: 0.1 })); // Daha hafif: 0.2 → 0.1\n  doc.setLineWidth(1);\n  doc.roundedRect(rightX - 5, logoY - 5, logoSize + 10, logoSize + 10, 4, 4, \"S\");\n  doc.setGState(doc.GState({ opacity: 1 }));\n\n  try {\n    doc.addImage(REV_LOGO_DATA_URI, 'PNG', rightX, logoY, logoSize, logoSize);\n  } catch (error) {\n    // Logo eklenemezse sessizce devam et\n  }\n\n  const safeText = createSafeText(doc);\n  doc.setTextColor(primaryR, primaryG, primaryB);\n  safeText(\"REVIUM\", rightX + logoSize + 10, 58, 24, true);\n  doc.setTextColor(mutedR, mutedG, mutedB);\n  safeText(COMPANY_INFO.headerAddress, rightX, 75, 10, false);\n  safeText(COMPANY_INFO.city, rightX, 87, 10, false);\n  safeText(COMPANY_INFO.contactInfo, rightX, 99, 10, false);\n  doc.setTextColor(0, 0, 0);\n\n  return newTemplate;\n};\n\ninterface SalesReportData {\n  totalRevenue?: number;\n  totalOrders?: number;\n  activeCustomers?: number;\n  avgOrderValue?: number; // Web sayfasından gelen hesaplanmış değer\n  orders?: Array<{\n    status?: string;\n    total?: number;\n    totalAmount?: number;\n    total_amount?: number;\n    subtotal?: number;\n  }>;\n  topProducts?: Array<{\n    name?: string;\n    quantity?: number;\n    revenue?: number;\n  }>;\n}\n\nexport const generateSalesReportPDF = async (data: SalesReportData, startDate: string, endDate: string) => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n\n  // Font'u MUTLAKA yükle - daha agresif yaklaşım\n  try {\n    await registerFonts(doc);\n  } catch (fontError) {\n    // Font yükleme hatası, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // İkinci deneme de başarısız, devam et\n    }\n  }\n\n  // Font'un gerçekten yüklendiğini doğrula - daha agresif kontrol\n  if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n    // Font yüklenemedi, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // Font yüklenemedi, devam et\n    }\n  }\n\n  // Font'u zorla Roboto olarak ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  applyDocumentTypography(doc);\n\n  const reportDate = formatDate(new Date().toISOString());\n\n  // PDF Template'i uygula - sabit layout + dinamik içerik\n  const template = applyPDFTemplate(doc, \"SATIŞ RAPORU\", reportDate, startDate, endDate);\n\n  // Font'u tekrar kontrol et ve ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 5; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  // Dinamik içerik alanından başla (iyileştirilmiş spacing)\n  let currentY = template.contentArea.startY + 5; // Header'dan sonra ekstra 5px boşluk\n  const contentWidth = template.contentArea.width;\n  const mar = template.contentArea.leftMargin;\n\n  const safeText = createSafeText(doc);\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // İstatistik Kartları - Sabit tasarım, dinamik değerler (standardize edilmiş)\n  const cardDimensions = calculateCardDimensions(contentWidth, 3);\n  const cardWidth = cardDimensions.width;\n  const cardGap = cardDimensions.gap;\n  const cardHeight = PDF_CONSTANTS.cardHeight;\n  let cardX = mar;\n\n  // Kart 1: Toplam Gelir - Web sayfasındaki gibi (aynı veriler)\n  const totalRevenue = safeNumber(data.totalRevenue);\n  // Web sayfasında avgOrderValue zaten hesaplanmış geliyor, aynısını kullan\n  const avgOrderValue = safeNumber(data.avgOrderValue ?? (data.totalOrders && data.totalOrders > 0 ? totalRevenue / data.totalOrders : 0));\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Gelir\",\n    value: safeFormatCurrency(totalRevenue),\n    description: `Ortalama: ${safeFormatCurrency(avgOrderValue)}`,\n    color: {\n      background: TAILWIND_COLORS.primaryCardBg,\n      border: TAILWIND_COLORS.primaryCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.primaryCardValue,\n    },\n  });\n\n  // Kart 2: Toplam Sipariş - profesyonel ve minimal (info)\n  cardX += cardWidth + cardGap;\n  const totalOrders = safeNumber(data.totalOrders);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Sipariş\",\n    value: totalOrders.toString(),\n    description: \"Tarih aralığında\",\n    color: {\n      background: TAILWIND_COLORS.infoCardBg,\n      border: TAILWIND_COLORS.infoCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.infoCardValue,\n    },\n  });\n\n  // Kart 3: Aktif Müşteri - profesyonel ve minimal (success)\n  cardX += cardWidth + cardGap;\n  const activeCustomers = safeNumber(data.activeCustomers);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Aktif Müşteri\",\n    value: activeCustomers.toString(),\n    description: \"Sipariş veren müşteri\",\n    color: {\n      background: TAILWIND_COLORS.successCardBg,\n      border: TAILWIND_COLORS.successCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.successCardValue,\n    },\n  });\n\n  currentY += cardHeight + PDF_CONSTANTS.sectionSpacing + 5; // Kartlar ve tablolar arası boşluk - iyileştirilmiş (ekstra 5px)\n\n  // Sipariş Durumu Dağılımı Tablosu - sabit başlık tasarımı (iyileştirilmiş)\n  if (data.orders && data.orders.length > 0) {\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Sipariş Durumu Dağılımı\");\n    currentY = drawTableHeader(doc, mar, currentY, 300, {\n      title: \"Sipariş Durumu Dağılımı\",\n      backgroundColor: TAILWIND_COLORS.gray50, // Web: bg-[rgb(249,250,251)]\n      textColor: PDF_CONSTANTS.primaryColor, // Web: text-primary\n      borderColor: [229, 231, 235], // Web: border-b (gray200)\n    });\n\n    const statusMap = new Map<string, { count: number; total: number }>();\n    data.orders?.forEach((order) => {\n      const status = order.status || \"Bilinmeyen\";\n      const total = safeNumber(order.total ?? order.totalAmount ?? order.total_amount ?? order.subtotal ?? 0);\n      if (!statusMap.has(status)) {\n        statusMap.set(status, { count: 0, total: 0 });\n      }\n      const stat = statusMap.get(status)!;\n      stat.count += 1;\n      stat.total += total;\n    });\n\n    const statusLabels: Record<string, string> = {\n      draft: \"Taslak\",\n      pending: \"Beklemede\",\n      confirmed: \"Onaylandı\",\n      planned: \"Planlandı\",\n      in_production: \"Üretimde\",\n      in_progress: \"Üretimde\",\n      quality_check: \"Kalite Kontrol\",\n      on_hold: \"Beklemede\",\n      completed: \"Tamamlandı\",\n      shipped: \"Kargoda\",\n      delivered: \"Teslim Edildi\",\n      cancelled: \"İptal\",\n    };\n\n    const totalOrders = data.orders.length;\n    const statusTableData = Array.from(statusMap.entries())\n      .sort((a, b) => b[1].count - a[1].count)\n      .map(([status, data]) => [\n        statusLabels[status] || status,\n        data.count.toString(),\n        safeFormatCurrency(data.total),\n        totalOrders > 0 ? `${((data.count / totalOrders) * 100).toFixed(1)}%` : \"0%\"\n      ]);\n\n    // Profesyonel tablo stilleri kullan - Web sayfasındaki gibi\n    const tableStyles = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Web sayfasındaki tablo stilleri (zaten createProfessionalTableStyles'da ayarlandı)\n    tableStyles.bodyStyles.overflow = 'linebreak';\n    tableStyles.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Sipariş Durumu Dağılımı\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const tableWidth = currentPageWidth - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Durum', 'Sipariş Sayısı', 'Toplam Tutar', 'Oran']]),\n      body: transliterateTableData(statusTableData),\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles,\n      columnStyles: {\n        0: { cellWidth: tableWidth * 0.35, halign: \"center\", overflow: 'linebreak', fontStyle: \"normal\" }, // Ortalanmış\n        1: { cellWidth: tableWidth * 0.20, halign: \"center\", fontStyle: \"bold\" }, // Ortalanmış\n        2: { cellWidth: tableWidth * 0.25, halign: \"center\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.primaryColor }, // Ortalanmış\n        3: { cellWidth: tableWidth * 0.20, halign: \"center\", fontStyle: \"bold\", textColor: [107, 114, 128] }, // Ortalanmış\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // En Çok Satan Ürünler Tablosu - sabit başlık tasarımı\n  if (data.topProducts && data.topProducts.length > 0) {\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"En Çok Satan Ürünler\");\n    currentY = drawTableHeader(doc, mar, currentY, 300, {\n      title: \"En Çok Satan Ürünler\",\n      backgroundColor: TAILWIND_COLORS.gray50, // Web: bg-[rgb(249,250,251)]\n      textColor: PDF_CONSTANTS.primaryColor, // Web: text-primary\n      borderColor: [229, 231, 235], // Web: border-b (gray200)\n    });\n\n    // Web sayfasındaki gibi - sadece ilk 10 ürün, TOPLAM satırı yok\n    const topProductsData = data.topProducts?.slice(0, 10).map((p, index: number) => [\n      `#${index + 1}`,\n      p.name || '-',\n      safeNumber(p.quantity).toString(),\n      safeFormatCurrency(safeNumber(p.revenue))\n    ]) || [];\n\n    // Profesyonel tablo stilleri kullan - Web sayfasındaki gibi\n    const tableStyles2 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Web sayfasındaki tablo stilleri (zaten createProfessionalTableStyles'da ayarlandı)\n    tableStyles2.bodyStyles.overflow = 'linebreak';\n    tableStyles2.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"En Çok Satan Ürünler\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth2 = doc.internal.pageSize.getWidth();\n    const tableWidth2 = currentPageWidth2 - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Ürün Adı', 'Adet', 'Gelir']]),\n      body: transliterateTableData(topProductsData),\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth2,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles2,\n      columnStyles: {\n        0: { cellWidth: tableWidth2 * 0.10, halign: \"center\", fontStyle: \"normal\", textColor: [107, 114, 128] }, // Ortalanmış\n        1: { cellWidth: tableWidth2 * 0.50, halign: \"center\", fontStyle: \"normal\", overflow: 'linebreak' }, // Ortalanmış\n        2: { cellWidth: tableWidth2 * 0.15, halign: \"center\", fontStyle: \"bold\" }, // Ortalanmış\n        3: { cellWidth: tableWidth2 * 0.25, halign: \"center\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.primaryColor }, // Ortalanmış\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle\n    const tableEndY2 = doc.lastAutoTable?.finalY;\n    if (tableEndY2 && tableEndY2 > currentY) {\n      currentY = tableEndY2 + PDF_CONSTANTS.tableSpacing;\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing;\n    }\n  }\n\n  // Web sayfasında sadece 3 bölüm var: Kartlar, Sipariş Durumu Dağılımı, En Çok Satan Ürünler\n  // Ekstra bölümler (Müşteri Bazlı Analiz, Zaman Bazlı Analiz, Özet) kaldırıldı\n\n  // Sayfa numaralarını ekle - template footer kullan\n  try {\n    const totalPages = doc.internal.pages.length - 1;\n    if (totalPages > 0) {\n      for (let i = 1; i <= totalPages; i++) {\n        try {\n          doc.setPage(i);\n          const pageTemplate = createPDFTemplate(doc);\n          drawPDFFooter(doc, pageTemplate, i, totalPages);\n        } catch (pageError) {\n          // Devam et, diğer sayfaları eklemeye çalış\n        }\n      }\n    }\n  } catch (footerError) {\n    // Footer hatası kritik değil, PDF'i yine de döndür\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output('blob');\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n\ninterface ProductionReportData {\n  totalOrders?: number;\n  completed?: number;\n  completionRate?: number;\n  statusDistribution?: Record<string, number>;\n  topProducts?: Array<{\n    name?: string;\n    quantity?: number;\n    orders?: number;\n  }>;\n}\n\nexport const generateProductionReportPDF = async (data: ProductionReportData, startDate: string, endDate: string) => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n\n  // Font'u MUTLAKA yükle - daha agresif yaklaşım\n  try {\n    await registerFonts(doc);\n  } catch (fontError) {\n    // Font yükleme hatası, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // İkinci deneme de başarısız, devam et\n    }\n  }\n\n  // Font'un gerçekten yüklendiğini doğrula - daha agresif kontrol\n  if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n    // Font yüklenemedi, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // Font yüklenemedi, devam et\n    }\n  }\n\n  // Font'u zorla Roboto olarak ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  applyDocumentTypography(doc);\n\n  const reportDate = formatDate(new Date().toISOString()); // Dinamik\n\n  // PDF Template'i uygula\n  const template = applyPDFTemplate(doc, \"ÜRETİM RAPORU\", reportDate, startDate, endDate);\n\n  // Font'u tekrar kontrol et ve ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 5; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  // Dinamik içerik alanından başla\n  let currentY = template.contentArea.startY;\n  const contentWidth = template.contentArea.width;\n  const mar = template.contentArea.leftMargin;\n\n  const safeText = createSafeText(doc);\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // İstatistik Kartları - Profesyonel tasarım, dinamik değerler\n  const cardWidth = (contentWidth - 32) / 3;\n  const cardHeight = 110; // Daha ferah: 100 → 110\n  const cardGap = 16;\n  let cardX = mar;\n\n  // Kart 1: Toplam Sipariş - profesyonel ve sade\n  const totalOrders = safeNumber(data.totalOrders);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Sipariş\",\n    value: totalOrders.toString(),\n    description: \"Tarih aralığında\",\n    color: {\n      background: TAILWIND_COLORS.infoCardBg,\n      border: TAILWIND_COLORS.infoCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.infoCardValue,\n    },\n  });\n\n  // Kart 2: Tamamlanan - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const completed = safeNumber(data.completed);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Tamamlanan\",\n    value: completed.toString(),\n    description: \"Başarıyla tamamlandı\",\n    color: {\n      background: TAILWIND_COLORS.successCardBg,\n      border: TAILWIND_COLORS.successCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.successCardValue,\n    },\n  });\n\n  // Kart 3: Tamamlanma Oranı - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const completionRate = safeNumber(data.completionRate);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Tamamlanma Oranı\",\n    value: `${completionRate.toFixed(1)}%`,\n    description: \"Başarı oranı\",\n    color: {\n      background: TAILWIND_COLORS.primaryCardBg,\n      border: TAILWIND_COLORS.primaryCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.primaryCardValue,\n    },\n  });\n\n  currentY += cardHeight + PDF_CONSTANTS.sectionSpacing; // Kartlar ve tablolar arası boşluk - standardize edilmiş\n\n  // Durum Dağılımı Tablosu - sabit başlık tasarımı\n  if (data.statusDistribution) {\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Durum Dağılımı\");\n    currentY = drawTableHeader(doc, mar, currentY, 250, {\n      title: \"Durum Dağılımı\",\n      backgroundColor: [249, 250, 251],\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    const statusLabels: Record<string, string> = {\n      planned: \"Planlandı\",\n      in_production: \"Üretimde\",\n      quality_check: \"Kalite Kontrol\",\n      completed: \"Tamamlandı\",\n      on_hold: \"Beklemede\"\n    };\n\n    const totalOrders = safeNumber(data.totalOrders);\n    const statusData = Object.entries(data.statusDistribution)\n      .filter(([_, value]) => safeNumber(value as number) > 0)\n      .sort((a, b) => safeNumber(b[1] as number) - safeNumber(a[1] as number))\n      .map(([key, value]) => {\n        const count = safeNumber(value as number);\n        const percentage = totalOrders > 0 ? `${((count / totalOrders) * 100).toFixed(1)}%` : \"0%\";\n        return [\n          statusLabels[key] || key,\n          count.toString(),\n          percentage\n        ];\n      });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Header rengi zaten createProfessionalTableStyles'da primaryColor olarak ayarlandı\n    // Burada override etmeye gerek yok, ama tutarlılık için bırakıyoruz\n    tableStyles.headStyles.fillColor = PDF_CONSTANTS.primaryColor;\n    tableStyles.headStyles.textColor = [255, 255, 255];\n    tableStyles.headStyles.halign = \"center\";\n    tableStyles.bodyStyles.overflow = 'linebreak';\n    tableStyles.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Durum Dağılımı\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const tableWidth = currentPageWidth - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Durum', 'Sipariş Sayısı', 'Oran']]),\n      body: transliterateTableData(statusData),\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles,\n      columnStyles: {\n        0: { cellWidth: tableWidth * 0.50, halign: \"left\", overflow: 'linebreak' }, // %50\n        1: { cellWidth: tableWidth * 0.25, halign: \"right\", fontStyle: \"bold\" }, // %25\n        2: { cellWidth: tableWidth * 0.25, halign: \"right\", fontStyle: \"bold\", textColor: [107, 114, 128] }, // %25\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // En Çok Üretilen Ürünler - daha vurgulu başlık\n  if (data.topProducts && data.topProducts.length > 0) {\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidthProd = doc.internal.pageSize.getWidth();\n    const tableWidthProd = pageWidthProd - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"En Çok Üretilen Ürünler\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidthProd, {\n      title: \"En Çok Üretilen Ürünler\",\n      backgroundColor: [249, 250, 251],\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    const topProductsData = data.topProducts?.slice(0, 10).map((p, index: number) => [\n      `#${index + 1}`,\n      p.name || '-',\n      safeNumber(p.quantity).toString(),\n      safeNumber(p.orders).toString()\n    ]);\n\n    // Özet satırı ekle\n    const totalQuantity = data.topProducts?.slice(0, 10).reduce((sum: number, p) => sum + safeNumber(p.quantity), 0) || 0;\n    const totalOrders = data.topProducts?.slice(0, 10).reduce((sum: number, p) => sum + safeNumber(p.orders), 0) || 0;\n    topProductsData.push([\n      'TOPLAM',\n      '',\n      totalQuantity.toString(),\n      totalOrders.toString()\n    ]);\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles2 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    tableStyles2.headStyles.fillColor = [59, 130, 246];\n    tableStyles2.headStyles.textColor = [255, 255, 255];\n    tableStyles2.headStyles.halign = \"center\";\n    tableStyles2.bodyStyles.overflow = 'linebreak';\n    tableStyles2.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"En Çok Üretilen Ürünler\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth2 = doc.internal.pageSize.getWidth();\n    const tableWidth2 = currentPageWidth2 - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Ürün Adı', 'Miktar', 'Sipariş Sayısı']]),\n      body: transliterateTableData(topProductsData),\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth2,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles2,\n      columnStyles: {\n        0: { cellWidth: tableWidth2 * 0.10, halign: \"left\", textColor: [107, 114, 128] }, // %10\n        1: { cellWidth: tableWidth2 * 0.50, halign: \"left\", overflow: 'linebreak' }, // %50\n        2: { cellWidth: tableWidth2 * 0.20, halign: \"right\", fontStyle: \"bold\" }, // %20\n        3: { cellWidth: tableWidth2 * 0.20, halign: \"right\", fontStyle: \"bold\" }, // %20\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // Üretim Verimliliği Analizi - Yeni detaylı bölüm\n  if (data.topProducts && data.topProducts.length > 0) {\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Üretim Verimliliği\");\n\n    const efficiencyData = data.topProducts?.slice(0, 10).map((p, index: number) => {\n      const quantity = safeNumber(p.quantity);\n      const orders = safeNumber(p.orders);\n      const avgPerOrder = orders > 0 ? (quantity / orders).toFixed(1) : \"0\";\n      const productName = (p.name || '-').length > 25 ? (p.name || '-').substring(0, 25) + \"...\" : (p.name || '-');\n      return [\n        `#${index + 1}`,\n        productName,\n        quantity.toString(),\n        orders.toString(),\n        avgPerOrder\n      ];\n    });\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidth3 = doc.internal.pageSize.getWidth();\n    const tableWidth3 = pageWidth3 - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Ürün Bazlı Üretim Verimliliği\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidth3, {\n      title: \"Ürün Bazlı Üretim Verimliliği\",\n      backgroundColor: [249, 250, 251],\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles3 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    tableStyles3.headStyles.fillColor = [59, 130, 246];\n    tableStyles3.headStyles.textColor = [255, 255, 255];\n    tableStyles3.headStyles.halign = \"center\";\n    tableStyles3.bodyStyles.overflow = 'linebreak';\n    tableStyles3.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Ürün Bazlı Üretim Verimliliği\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth3 = doc.internal.pageSize.getWidth();\n    const currentTableWidth3 = currentPageWidth3 - (mar * 2);\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Ürün', 'Toplam Miktar', 'Sipariş', 'Ortalama/Sipariş']]),\n      body: transliterateTableData(efficiencyData),\n      margin: { left: mar, right: mar },\n      tableWidth: currentTableWidth3,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles3,\n      columnStyles: {\n        0: { cellWidth: currentTableWidth3 * 0.08, halign: \"left\", textColor: [107, 114, 128] }, // %8\n        1: { cellWidth: currentTableWidth3 * 0.40, halign: \"left\", overflow: 'linebreak' }, // %40\n        2: { cellWidth: currentTableWidth3 * 0.18, halign: \"right\", fontStyle: \"bold\" }, // %18\n        3: { cellWidth: currentTableWidth3 * 0.15, halign: \"right\", fontStyle: \"bold\" }, // %15\n        4: { cellWidth: currentTableWidth3 * 0.19, halign: \"right\", textColor: [107, 114, 128] }, // %19\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // Özet Bölümü - sabit tasarım, dinamik veriler\n  currentY = (doc.lastAutoTable?.finalY || currentY) + 50; // Optimize edilmiş boşluk: 50pt\n  currentY = ensureSpace(doc, currentY, 100, mar, \"Özet\");\n\n  const onHold = safeNumber((data as any).onHold || 0);\n  const inProduction = safeNumber((data as any).inProduction || 0);\n  const planned = safeNumber(data.statusDistribution?.planned || 0);\n  const qualityCheck = safeNumber(data.statusDistribution?.quality_check || 0);\n\n  const summaryData: Array<[string, string]> = [\n    ['Toplam Sipariş', totalOrders.toString()],\n    ['Tamamlanan', completed.toString()],\n    ['Tamamlanma Oranı', `${completionRate.toFixed(1)}%`],\n    ['Beklemede', onHold.toString()],\n    ['Üretimde', inProduction.toString()],\n    ['Planlandı', planned.toString()],\n    ['Kalite Kontrol', qualityCheck.toString()],\n    ['En Çok Üretilen Ürün Sayısı', data.topProducts ? data.topProducts.length.toString() : \"0\"],\n  ];\n\n  currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Rapor Özeti\", summaryData, [37, 99, 235]);\n\n  // Sayfa numaralarını ekle - template footer kullan\n  try {\n    const totalPages = doc.internal.pages.length - 1;\n    if (totalPages > 0) {\n      for (let i = 1; i <= totalPages; i++) {\n        try {\n          doc.setPage(i);\n          const pageTemplate = createPDFTemplate(doc);\n          drawPDFFooter(doc, pageTemplate, i, totalPages);\n        } catch (pageError) {\n          // Devam et, diğer sayfaları eklemeye çalış\n        }\n      }\n    }\n  } catch (footerError) {\n    // Footer hatası kritik değil, PDF'i yine de döndür\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output('blob');\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n\ninterface CustomerReportData {\n  totalCustomers?: number;\n  activeCustomers?: number;\n  newCustomers?: number;\n  topCustomers?: Array<{\n    name?: string;\n    total?: number;\n    orders?: number;\n    lastOrderDate?: string | Date;\n  }>;\n  customerSegments?: {\n    high?: number;\n    medium?: number;\n    low?: number;\n  };\n}\n\nexport const generateCustomerReportPDF = async (data: CustomerReportData, startDate: string, endDate: string) => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n\n  // Font'u MUTLAKA yükle - daha agresif yaklaşım\n  try {\n    await registerFonts(doc);\n  } catch (fontError) {\n    // Font yükleme hatası, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // İkinci deneme de başarısız, devam et\n    }\n  }\n\n  // Font'un gerçekten yüklendiğini doğrula - daha agresif kontrol\n  if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n    // Font yüklenemedi, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // Font yüklenemedi, devam et\n    }\n  }\n\n  // Font'u zorla Roboto olarak ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  applyDocumentTypography(doc);\n\n  const reportDate = formatDate(new Date().toISOString()); // Dinamik\n\n  // PDF Template'i uygula - Türkçe karakterler için font kontrolü\n  const template = applyPDFTemplate(doc, \"MÜŞTERİ RAPORU\", reportDate, startDate, endDate);\n\n  // Font'u tekrar kontrol et ve ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 5; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  // Dinamik içerik alanından başla\n  let currentY = template.contentArea.startY;\n  const contentWidth = template.contentArea.width;\n  const mar = template.contentArea.leftMargin;\n\n  const safeText = createSafeText(doc);\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // İstatistik Kartları - Profesyonel tasarım, dinamik değerler\n  const cardWidth = (contentWidth - 32) / 3;\n  const cardHeight = 110; // Daha ferah: 100 → 110\n  const cardGap = 16;\n  let cardX = mar;\n\n  // Kart 1: Toplam Müşteri - profesyonel ve sade\n  const totalCustomers = safeNumber(data.totalCustomers);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Müşteri\",\n    value: totalCustomers.toString(),\n    description: \"Tüm müşteriler\",\n    color: {\n      background: TAILWIND_COLORS.cardBackground,\n      border: TAILWIND_COLORS.cardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.gray700,\n    },\n  });\n\n  // Kart 2: Aktif Müşteri - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const activeCustomers = safeNumber(data.activeCustomers);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Aktif Müşteri\",\n    value: activeCustomers.toString(),\n    description: \"Sipariş veren müşteri\",\n    color: {\n      background: TAILWIND_COLORS.successCardBg,\n      border: TAILWIND_COLORS.successCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.successCardValue,\n    },\n  });\n\n  // Kart 3: Yeni Müşteri - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const newCustomers = safeNumber(data.newCustomers);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Yeni Müşteri\",\n    value: newCustomers.toString(),\n    description: \"Tarih aralığında\",\n    color: {\n      background: TAILWIND_COLORS.infoCardBg,\n      border: TAILWIND_COLORS.infoCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.infoCardValue,\n    },\n  });\n\n  currentY += cardHeight + PDF_CONSTANTS.sectionSpacing; // Kartlar ve tablolar arası boşluk - standardize edilmiş\n\n  // Müşteri Segmentasyonu Tablosu - sayfadaki sıralamayla uyumlu (önce Segmentasyonu, sonra En Değerli Müşteriler)\n  if ((data as any).segments) {\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidthSeg = doc.internal.pageSize.getWidth();\n    const tableWidthSeg = pageWidthSeg - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Müşteri Segmentasyonu\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidthSeg, {\n      title: \"Müşteri Segmentasyonu\",\n      backgroundColor: [249, 250, 251],\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles2 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    tableStyles2.headStyles.fillColor = [59, 130, 246];\n    tableStyles2.headStyles.textColor = [255, 255, 255];\n    tableStyles2.headStyles.halign = \"center\";\n    tableStyles2.bodyStyles.overflow = 'linebreak';\n    tableStyles2.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 150, mar, \"Müşteri Segmentasyonu\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidthSeg = doc.internal.pageSize.getWidth();\n    const currentTableWidthSeg = currentPageWidthSeg - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Segment', 'Müşteri Sayısı']]),\n      body: transliterateTableData([\n        ['Yüksek Değerli (>₺50K)', safeNumber((data as any).segments.high).toString()],\n        ['Orta Değerli (₺10K-₺50K)', safeNumber((data as any).segments.medium).toString()],\n        ['Düşük Değerli (<₺10K)', safeNumber((data as any).segments.low).toString()],\n      ]),\n      margin: { left: mar, right: mar },\n      tableWidth: currentTableWidthSeg,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles2,\n      columnStyles: {\n        0: { cellWidth: currentTableWidthSeg * 0.70, halign: \"left\", overflow: 'linebreak' }, // %70\n        1: { cellWidth: currentTableWidthSeg * 0.30, halign: \"right\", fontStyle: \"bold\" }, // %30\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle\n    const tableEndY2 = doc.lastAutoTable?.finalY;\n    if (tableEndY2 && tableEndY2 > currentY) {\n      currentY = tableEndY2 + 50; // Optimize edilmiş boşluk: 50pt\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // En Değerli Müşteriler Tablosu - sayfadaki sıralamayla uyumlu (Müşteri Segmentasyonu'ndan sonra)\n  if (data.topCustomers && data.topCustomers.length > 0) {\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidth = doc.internal.pageSize.getWidth();\n    const tableWidth = pageWidth - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"En Değerli Müşteriler\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidth, {\n      title: \"En Değerli Müşteriler\",\n      backgroundColor: TAILWIND_COLORS.gray100,\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Header rengi zaten createProfessionalTableStyles'da ayarlandı\n    // Override etmeye gerek yok\n    tableStyles.headStyles.halign = \"center\";\n    tableStyles.bodyStyles.overflow = 'linebreak';\n    tableStyles.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"En Değerli Müşteriler\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const currentTableWidth = currentPageWidth - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Müşteri', 'Sipariş Sayısı', 'Toplam Harcama']]),\n      body: transliterateTableData(\n        data.topCustomers?.slice(0, 10).map((c, index: number) => [\n          `#${index + 1}`,\n          c.name || '-',\n          safeNumber(c.orders).toString(),\n          safeFormatCurrency(safeNumber(c.total))\n        ]) || []\n      ),\n      margin: { left: mar, right: mar },\n      tableWidth: currentTableWidth,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles,\n      columnStyles: {\n        0: { cellWidth: currentTableWidth * 0.10, halign: \"left\", textColor: TAILWIND_COLORS.gray500 }, // %10\n        1: { cellWidth: currentTableWidth * 0.40, halign: \"left\", overflow: 'linebreak' }, // %40\n        2: { cellWidth: currentTableWidth * 0.20, halign: \"right\", fontStyle: \"bold\" }, // %20\n        3: { cellWidth: currentTableWidth * 0.30, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.primaryColor }, // %30\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + 50; // Optimize edilmiş boşluk: 50pt\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // Müşteri Detay Analizi - Yeni detaylı bölüm\n  if (data.topCustomers && data.topCustomers.length > 0) {\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - minimum 30pt boşluk\n    const tableEndY2 = doc.lastAutoTable?.finalY;\n    if (tableEndY2 && tableEndY2 > currentY) {\n      currentY = tableEndY2 + 60; // Tablo sonrası boşluk artırıldı: 30 → 60\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Müşteri Detay Analizi\");\n\n    // Müşteri bazlı sipariş frekansı ve değer analizi\n    const customerDetailData = data.topCustomers?.slice(0, 15).map((c, index: number) => {\n      const orders = safeNumber(c.orders);\n      const total = safeNumber(c.total);\n      const avgOrderValue = orders > 0 ? (total / orders) : 0;\n      const customerName = (c.name || '-').length > 30 ? (c.name || '-').substring(0, 30) + \"...\" : (c.name || '-');\n\n      return [\n        `#${index + 1}`,\n        customerName,\n        orders.toString(),\n        safeFormatCurrency(total),\n        safeFormatCurrency(avgOrderValue),\n        total >= 50000 ? \"Yüksek\" : total >= 10000 ? \"Orta\" : \"Düşük\"\n      ];\n    });\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidth5 = doc.internal.pageSize.getWidth();\n    const tableWidth5 = pageWidth5 - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 300, mar, \"Müşteri Detay Analizi\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidth5, {\n      title: \"Müşteri Detay Analizi (Top 15)\",\n      backgroundColor: [249, 250, 251],\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles3 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    tableStyles3.headStyles.fillColor = [59, 130, 246];\n    tableStyles3.headStyles.textColor = [255, 255, 255];\n    tableStyles3.headStyles.halign = \"center\";\n    tableStyles3.bodyStyles.overflow = 'linebreak';\n    tableStyles3.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Müşteri Detay Analizi\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Müşteri', 'Sipariş', 'Toplam', 'Ortalama', 'Segment']]),\n      body: transliterateTableData(customerDetailData),\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth5,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles3,\n      columnStyles: {\n        0: { cellWidth: tableWidth5 * 0.07, halign: \"left\", textColor: [107, 114, 128] }, // %7\n        1: { cellWidth: tableWidth5 * 0.30, halign: \"left\", overflow: 'linebreak' }, // %30\n        2: { cellWidth: tableWidth5 * 0.12, halign: \"right\", fontStyle: \"bold\" }, // %12\n        3: { cellWidth: tableWidth5 * 0.20, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.primaryColor }, // %20\n        4: { cellWidth: tableWidth5 * 0.18, halign: \"right\", textColor: [107, 114, 128] }, // %18\n        5: { cellWidth: tableWidth5 * 0.13, halign: \"center\", fontStyle: \"bold\" }, // %13\n      },\n      alternateRowStyles: {\n        fillColor: [249, 250, 251]\n      },\n      didDrawCell: (data: CellHookData) => {\n        // Segment renklendirme\n        if (data.column?.index === 5 && data.cell?.text) {\n          const segment = data.cell.text.toString();\n          const x = data.cell?.x ?? data.x ?? 0;\n          const y = data.cell?.y ?? data.y ?? 0;\n          const width = data.cell?.width ?? data.width ?? 0;\n          const height = data.cell?.height ?? data.height ?? 0;\n          if (segment === \"Yüksek\") {\n            doc.setFillColor(240, 253, 244);\n            doc.rect(x, y, width, height, \"F\");\n            doc.setTextColor(22, 163, 74);\n          } else if (segment === \"Orta\") {\n            doc.setFillColor(254, 249, 195);\n            doc.rect(x, y, width, height, \"F\");\n            doc.setTextColor(217, 119, 6);\n          } else {\n            doc.setFillColor(254, 242, 242);\n            doc.rect(x, y, width, height, \"F\");\n            doc.setTextColor(220, 38, 38);\n          }\n        }\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - minimum 30pt boşluk\n    const tableEndY3 = doc.lastAutoTable?.finalY;\n    if (tableEndY3 && tableEndY3 > currentY) {\n      currentY = tableEndY3 + 30; // Standart boşluk: 30pt\n    } else {\n      currentY += 30; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // Müşteri Trend Analizi - Yeni bölüm\n  if (data.newCustomers !== undefined) {\n    currentY = ensureSpace(doc, currentY, 150, mar, \"Müşteri Trend Analizi\");\n\n    const retentionRate = safeNumber(data.totalCustomers) > 0\n      ? ((safeNumber(data.totalCustomers) - safeNumber(data.newCustomers)) / safeNumber(data.totalCustomers) * 100).toFixed(1)\n      : \"0\";\n    const activeRate = safeNumber(data.totalCustomers) > 0\n      ? (safeNumber(data.activeCustomers) / safeNumber(data.totalCustomers) * 100).toFixed(1)\n      : \"0\";\n\n    const trendData: Array<[string, string]> = [\n      ['Yeni Müşteri Oranı', `${(safeNumber(data.newCustomers) / Math.max(safeNumber(data.totalCustomers), 1) * 100).toFixed(1)}%`],\n      ['Müşteri Tutma Oranı', `${retentionRate}%`],\n      ['Aktif Müşteri Oranı', `${activeRate}%`],\n      ['Segment Dağılımı (Yüksek)', `${safeNumber((data as any).segments?.high || 0)} müşteri`],\n      ['Segment Dağılımı (Orta)', `${safeNumber((data as any).segments?.medium || 0)} müşteri`],\n      ['Segment Dağılımı (Düşük)', `${safeNumber((data as any).segments?.low || 0)} müşteri`],\n    ];\n\n    currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Müşteri Trend Analizi\", trendData, [147, 51, 234]);\n  }\n\n  // Özet Bölümü - sabit tasarım, dinamik veriler\n  currentY = (doc.lastAutoTable?.finalY || currentY) + 50; // Optimize edilmiş boşluk: 50pt\n  currentY = ensureSpace(doc, currentY, 100, mar, \"Özet\");\n\n  const summaryData: Array<[string, string]> = [\n    ['Toplam Müşteri', safeNumber(data.totalCustomers).toString()],\n    ['Aktif Müşteri', safeNumber(data.activeCustomers).toString()],\n    ['Yeni Müşteri', safeNumber(data.newCustomers).toString()],\n    ['Yüksek Değerli Müşteri', safeNumber((data as any).segments?.high || 0).toString()],\n    ['Orta Değerli Müşteri', safeNumber((data as any).segments?.medium || 0).toString()],\n    ['Düşük Değerli Müşteri', safeNumber((data as any).segments?.low || 0).toString()],\n    ['En Değerli Müşteri Sayısı', data.topCustomers ? data.topCustomers.length.toString() : \"0\"],\n  ];\n\n  currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Rapor Özeti\", summaryData, [147, 51, 234]);\n\n  // Sayfa numaralarını ekle - template footer kullan\n  try {\n    const totalPages = doc.internal.pages.length - 1;\n    if (totalPages > 0) {\n      for (let i = 1; i <= totalPages; i++) {\n        try {\n          doc.setPage(i);\n          const pageTemplate = createPDFTemplate(doc);\n          drawPDFFooter(doc, pageTemplate, i, totalPages);\n        } catch (pageError) {\n          // Devam et, diğer sayfaları eklemeye çalış\n        }\n      }\n    }\n  } catch (footerError) {\n    // Footer hatası kritik değil, PDF'i yine de döndür\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output('blob');\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n\ninterface FinancialReportData {\n  totalRevenue?: number;\n  totalCost?: number;\n  grossProfit?: number;\n  profitMargin?: number;\n  monthlyTrend?: Array<{\n    month?: string;\n    revenue?: number;\n    cost?: number;\n    profit?: number;\n  }>;\n  topProfitableProducts?: Array<{\n    name?: string;\n    revenue?: number;\n    cost?: number;\n    profit?: number;\n  }>;\n  segments?: {\n    high?: number;\n    medium?: number;\n    low?: number;\n  };\n  topCustomers?: Array<{\n    name?: string;\n    total?: number;\n  }>;\n}\n\nexport const generateFinancialReportPDF = async (data: FinancialReportData, startDate: string, endDate: string) => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n\n  // Font'u MUTLAKA yükle - daha agresif yaklaşım\n  try {\n    await registerFonts(doc);\n  } catch (fontError) {\n    // Font yükleme hatası, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // İkinci deneme de başarısız, devam et\n    }\n  }\n\n  // Font'un gerçekten yüklendiğini doğrula - daha agresif kontrol\n  if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\n    // Font yüklenemedi, tekrar dene\n    try {\n      await registerFonts(doc);\n    } catch (retryError) {\n      // Font yüklenemedi, devam et\n    }\n  }\n\n  // Font'u zorla Roboto olarak ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 10; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  applyDocumentTypography(doc);\n\n  const reportDate = formatDate(new Date().toISOString()); // Dinamik\n\n  // PDF Template'i uygula - Türkçe karakterler için font kontrolü\n  const template = applyPDFTemplate(doc, \"MALİ RAPOR\", reportDate, startDate, endDate);\n\n  // Font'u tekrar kontrol et ve ayarla\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    for (let i = 0; i < 5; i++) {\n      try {\n        doc.setFont(\"Roboto\", \"normal\");\n        const currentFont = doc.getFont();\n        if (currentFont && isRobotoName(currentFont.fontName)) {\n          break;\n        }\n      } catch {\n        // Tekrar dene\n      }\n    }\n  }\n\n  // Dinamik içerik alanından başla\n  let currentY = template.contentArea.startY;\n  const contentWidth = template.contentArea.width;\n  const mar = template.contentArea.leftMargin;\n\n  const safeText = createSafeText(doc);\n  const [primaryR, primaryG, primaryB] = PDF_CONSTANTS.primaryColor;\n  const [mutedR, mutedG, mutedB] = PDF_CONSTANTS.mutedColor;\n\n  // İstatistik Kartları - Profesyonel tasarım (4 kart) - standardize edilmiş\n  const cardDimensions = calculateCardDimensions(contentWidth, 4);\n  const cardWidth = cardDimensions.width;\n  const cardGap = cardDimensions.gap;\n  const cardHeight = PDF_CONSTANTS.cardHeight;\n  let cardX = mar;\n\n  // Kart 1: Toplam Gelir (Green) - profesyonel ve sade\n  const totalRevenue = safeNumber(data.totalRevenue);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Gelir\",\n    value: safeFormatCurrency(totalRevenue),\n    description: \"Toplam ciro\",\n    color: {\n      background: TAILWIND_COLORS.successCardBg,\n      border: TAILWIND_COLORS.successCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.successCardValue,\n    },\n  });\n\n  // Kart 2: Toplam Gider (Red) - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const totalCost = safeNumber(data.totalCost);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Toplam Gider\",\n    value: safeFormatCurrency(totalCost),\n    description: \"Toplam maliyet\",\n    color: {\n      background: TAILWIND_COLORS.errorCardBg,\n      border: TAILWIND_COLORS.errorCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.errorCardValue,\n    },\n  });\n\n  // Kart 3: Brüt Kar (Emerald) - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const grossProfit = safeNumber(data.grossProfit);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Brüt Kar\",\n    value: safeFormatCurrency(grossProfit),\n    description: \"Net kar\",\n    color: {\n      background: TAILWIND_COLORS.successCardBg,\n      border: TAILWIND_COLORS.successCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.successCardValue,\n    },\n  });\n\n  // Kart 4: Kar Marjı (Primary) - profesyonel ve sade\n  cardX += cardWidth + cardGap;\n  const profitMargin = safeNumber(data.profitMargin);\n  drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\n    title: \"Kar Marjı\",\n    value: `${profitMargin.toFixed(1)}%`,\n    description: \"Karlılık oranı\",\n    color: {\n      background: TAILWIND_COLORS.primaryCardBg,\n      border: TAILWIND_COLORS.primaryCardBorder,\n      text: TAILWIND_COLORS.cardText,\n      value: TAILWIND_COLORS.primaryCardValue,\n    },\n  });\n\n  currentY += cardHeight + PDF_CONSTANTS.sectionSpacing; // Kartlar ve tablolar arası boşluk - standardize edilmiş\n\n  // Aylık Trend Tablosu - sayfadaki sıralamayla uyumlu (önce Aylık Trend, sonra En Karlı Ürünler)\n  if (data.monthlyTrend && data.monthlyTrend.length > 0) {\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidthTrend = doc.internal.pageSize.getWidth();\n    const tableWidthTrend = pageWidthTrend - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Aylık Trend\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidthTrend, {\n      title: \"Aylık Gelir-Gider-Kar Trendi\",\n      backgroundColor: TAILWIND_COLORS.gray100,\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    const monthLabels: Record<string, string> = {\n      '01': 'Ocak', '02': 'Şubat', '03': 'Mart', '04': 'Nisan',\n      '05': 'Mayıs', '06': 'Haziran', '07': 'Temmuz', '08': 'Ağustos',\n      '09': 'Eylül', '10': 'Ekim', '11': 'Kasım', '12': 'Aralık'\n    };\n\n    const trendData = data.monthlyTrend?.map((item) => {\n      const [year, month] = item.month.split('-');\n      const monthLabel = monthLabels[month] || month;\n      return [\n        `${monthLabel} ${year}`,\n        safeFormatCurrency(safeNumber(item.revenue || 0)),\n        safeFormatCurrency(safeNumber(item.cost || 0)),\n        safeFormatCurrency(safeNumber(item.profit || 0))\n      ];\n    });\n\n    // Profesyonel tablo stilleri kullan (özel header rengi ile)\n    const tableStyles2 = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    tableStyles2.headStyles.fillColor = PDF_CONSTANTS.primaryColor; // Primary color\n    tableStyles2.headStyles.textColor = [255, 255, 255]; // White text\n    tableStyles2.headStyles.halign = \"center\";\n    tableStyles2.bodyStyles.overflow = 'linebreak';\n    tableStyles2.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Aylık Gelir-Gider-Kar Trendi\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth2 = doc.internal.pageSize.getWidth();\n    const currentTableWidth2 = currentPageWidth2 - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Ay', 'Gelir', 'Gider', 'Kar']]),\n      body: transliterateTableData(trendData),\n      margin: { left: mar, right: mar },\n      tableWidth: currentTableWidth2,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles2,\n      columnStyles: {\n        0: { cellWidth: currentTableWidth2 * 0.25, halign: \"left\" },  // %25\n        1: { cellWidth: currentTableWidth2 * 0.25, halign: \"right\" }, // %25\n        2: { cellWidth: currentTableWidth2 * 0.25, halign: \"right\" }, // %25\n        3: { cellWidth: currentTableWidth2 * 0.25, halign: \"right\" }, // %25\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle\n    const trendTableEndY = doc.lastAutoTable?.finalY;\n    if (trendTableEndY && trendTableEndY > currentY) {\n      currentY = trendTableEndY + 50; // Optimize edilmiş boşluk: 50pt\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // En Karlı Ürünler Tablosu - sayfadaki sıralamayla uyumlu (Aylık Trend'den sonra)\n  if (data.topProfitableProducts && data.topProfitableProducts.length > 0) {\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const pageWidth = doc.internal.pageSize.getWidth();\n    const tableWidth = pageWidth - (mar * 2);\n\n    // Tablolar arası boşluk kontrolü\n    currentY = ensureSpace(doc, currentY, 200, mar, \"En Karlı Ürünler\");\n    currentY = drawTableHeader(doc, mar, currentY, tableWidth, {\n      title: \"En Karlı Ürünler\",\n      backgroundColor: TAILWIND_COLORS.gray100,\n      textColor: PDF_CONSTANTS.primaryColor,\n      borderColor: PDF_CONSTANTS.primaryColor,\n    });\n\n    // Profesyonel tablo stilleri kullan\n    const tableStyles = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Header rengi zaten createProfessionalTableStyles'da ayarlandı\n    // Override etmeye gerek yok\n    tableStyles.headStyles.halign = \"center\";\n    tableStyles.bodyStyles.overflow = 'linebreak';\n    tableStyles.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"En Karlı Ürünler\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const currentTableWidth = currentPageWidth - (mar * 2);\n\n    // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n    forceRobotoFont(doc, \"normal\");\n\n    autoTable(doc, {\n      startY: currentY,\n      head: transliterateTableData([['Sıra', 'Ürün', 'Gelir', 'Gider', 'Kar']]),\n      body: transliterateTableData(\n        data.topProfitableProducts?.slice(0, 10).map((p, index: number) => [\n          `#${index + 1}`,\n          p.name || '-',\n          safeFormatCurrency(safeNumber(p.revenue)),\n          safeFormatCurrency(safeNumber(p.cost)),\n          safeFormatCurrency(safeNumber(p.profit))\n        ]) || []\n      ),\n      margin: { left: mar, right: mar },\n      tableWidth: currentTableWidth,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles,\n      columnStyles: {\n        0: { cellWidth: currentTableWidth * 0.08, halign: \"left\", textColor: TAILWIND_COLORS.gray500 }, // %8\n        1: { cellWidth: currentTableWidth * 0.40, halign: \"left\", overflow: 'linebreak' }, // %40\n        2: { cellWidth: currentTableWidth * 0.17, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.successColor }, // %17\n        3: { cellWidth: currentTableWidth * 0.17, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.errorColor }, // %17\n        4: { cellWidth: currentTableWidth * 0.18, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.successColor }, // %18\n      },\n    });\n\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle\n    const productsTableEndY = doc.lastAutoTable?.finalY;\n    if (productsTableEndY && productsTableEndY > currentY) {\n      currentY = productsTableEndY + 50; // Optimize edilmiş boşluk: 50pt\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n  }\n\n  // Gider Kalemleri Analizi - Yeni detaylı bölüm\n  if ((data as any).costBreakdown || (data as any).expenseCategories) {\n    // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n    const tableEndY = doc.lastAutoTable?.finalY;\n    if (tableEndY && tableEndY > currentY) {\n      currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n    } else {\n      currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n    }\n    currentY = ensureSpace(doc, currentY, 200, mar, \"Gider Kalemleri Analizi\");\n\n    const costData = (data as any).costBreakdown || (data as any).expenseCategories || [];\n    if (costData.length > 0) {\n      // En Karlı Ürünler tablosu gibi sıra numarası ile\n      const costTableData = costData.map((item: { category?: string; name?: string; amount?: number; total?: number; percentage?: number }, index: number) => {\n        const category = item.category || item.name || \"Bilinmeyen\";\n        const amount = safeNumber(item.amount || item.total || 0);\n        const percentage = item.percentage !== undefined\n          ? item.percentage.toFixed(1)\n          : (safeNumber(data.totalCost) > 0\n            ? ((amount / safeNumber(data.totalCost)) * 100).toFixed(1)\n            : \"0\");\n        return [\n          `#${index + 1}`,\n          category.length > 30 ? category.substring(0, 30) + \"...\" : category,\n          safeFormatCurrency(amount),\n          `${percentage}%`\n        ];\n      });\n\n      // Tablo genişliğini sayfa genişliğine göre ayarla\n      const pageWidth3 = doc.internal.pageSize.getWidth();\n      const tableWidth3 = pageWidth3 - (mar * 2);\n\n      // Tablolar arası boşluk kontrolü\n      currentY = ensureSpace(doc, currentY, 200, mar, \"Gider Kalemleri Analizi\");\n      currentY = drawTableHeader(doc, mar, currentY, tableWidth3, {\n        title: \"Gider Kalemleri Analizi\",\n        backgroundColor: TAILWIND_COLORS.gray100,\n        textColor: PDF_CONSTANTS.primaryColor,\n        borderColor: PDF_CONSTANTS.primaryColor,\n      });\n\n      // Profesyonel tablo stilleri kullan\n      const tableStyles3 = createProfessionalTableStyles(doc, {\n        headerFontSize: 12,\n        bodyFontSize: 11,\n        cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n      });\n      tableStyles3.headStyles.fillColor = [59, 130, 246];\n      tableStyles3.headStyles.textColor = [255, 255, 255];\n      tableStyles3.headStyles.halign = \"center\";\n      tableStyles3.bodyStyles.overflow = 'linebreak';\n      tableStyles3.styles.overflow = 'linebreak';\n\n      // Sayfa sığma kontrolü\n      currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Gider Kalemleri Analizi\");\n\n      // Tablo genişliğini sayfa genişliğine göre ayarla\n      const currentPageWidth3 = doc.internal.pageSize.getWidth();\n      const currentTableWidth3 = currentPageWidth3 - (mar * 2);\n\n      // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n      forceRobotoFont(doc, \"normal\");\n\n      autoTable(doc, {\n        startY: currentY,\n        head: transliterateTableData([['Sıra', 'Gider Kalemi', 'Tutar', 'Oran']]),\n        body: transliterateTableData(costTableData),\n        margin: { left: mar, right: mar },\n        tableWidth: currentTableWidth3,\n        willDrawCell: createWillDrawCell(doc),\n        ...tableStyles3,\n        columnStyles: {\n          0: { cellWidth: currentTableWidth3 * 0.08, halign: \"left\", textColor: TAILWIND_COLORS.gray500 }, // %8 - Sıra\n          1: { cellWidth: currentTableWidth3 * 0.40, halign: \"left\", overflow: 'linebreak' }, // %40 - Gider Kalemi\n          2: { cellWidth: currentTableWidth3 * 0.30, halign: \"right\", fontStyle: \"bold\", textColor: PDF_CONSTANTS.errorColor }, // %30 - Tutar\n          3: { cellWidth: currentTableWidth3 * 0.22, halign: \"right\", textColor: TAILWIND_COLORS.gray500 }, // %22 - Oran\n        },\n      });\n\n      // Tablo sonrası currentY'yi güvenli şekilde güncelle - yeterli boşluk\n      const tableEndY = doc.lastAutoTable?.finalY;\n      if (tableEndY && tableEndY > currentY) {\n        currentY = tableEndY + PDF_CONSTANTS.tableSpacing; // Tablo sonrası boşluk - standardize edilmiş\n      } else {\n        currentY += PDF_CONSTANTS.tableSpacing; // Fallback: eğer lastAutoTable yoksa\n      }\n    }\n  }\n\n  // Kar Analizi Detayı - Yeni bölüm\n  currentY = ensureSpace(doc, currentY, 150, mar, \"Kar Analizi Detayı\");\n\n  const profitMarginValue = safeNumber(data.profitMargin);\n  const revenue = safeNumber(data.totalRevenue);\n  const cost = safeNumber(data.totalCost);\n  const profit = safeNumber(data.grossProfit);\n  const avgMonthlyRevenue = data.monthlyTrend && data.monthlyTrend.length > 0\n    ? safeNumber(data.totalRevenue) / data.monthlyTrend.length\n    : 0;\n  const avgMonthlyCost = data.monthlyTrend && data.monthlyTrend.length > 0\n    ? safeNumber(data.totalCost) / data.monthlyTrend.length\n    : 0;\n  const avgMonthlyProfit = avgMonthlyRevenue - avgMonthlyCost;\n  const profitGrowth = data.monthlyTrend && data.monthlyTrend.length >= 2\n    ? ((data.monthlyTrend[data.monthlyTrend.length - 1].profit || 0) - (data.monthlyTrend[0].profit || 0))\n    : 0;\n\n  const profitAnalysisData: Array<[string, string]> = [\n    ['Toplam Gelir', safeFormatCurrency(revenue)],\n    ['Toplam Gider', safeFormatCurrency(cost)],\n    ['Brüt Kar', safeFormatCurrency(profit)],\n    ['Kar Marjı', `${profitMarginValue.toFixed(1)}%`],\n    ['Ortalama Aylık Gelir', safeFormatCurrency(avgMonthlyRevenue)],\n    ['Ortalama Aylık Gider', safeFormatCurrency(avgMonthlyCost)],\n    ['Ortalama Aylık Kar', safeFormatCurrency(avgMonthlyProfit)],\n    ['Kar Büyümesi', profitGrowth > 0 ? `+${safeFormatCurrency(profitGrowth)}` : safeFormatCurrency(profitGrowth)],\n  ];\n\n  currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Kar Analizi Detayı\", profitAnalysisData, [5, 150, 105]);\n\n  // Özet Bölümü - sabit tasarım, dinamik veriler\n  currentY = (doc.lastAutoTable?.finalY || currentY) + 50; // Optimize edilmiş boşluk: 50pt\n  currentY = ensureSpace(doc, currentY, 100, mar, \"Özet\");\n\n  const summaryData: Array<[string, string]> = [\n    ['Toplam Gelir', safeFormatCurrency(safeNumber(data.totalRevenue))],\n    ['Toplam Gider', safeFormatCurrency(safeNumber(data.totalCost))],\n    ['Brüt Kar', safeFormatCurrency(safeNumber(data.grossProfit))],\n    ['Kar Marjı', `${safeNumber(data.profitMargin).toFixed(1)}%`],\n    ['Ortalama Aylık Gelir', data.monthlyTrend && data.monthlyTrend.length > 0\n      ? safeFormatCurrency(safeNumber(data.totalRevenue) / data.monthlyTrend.length)\n      : safeFormatCurrency(0)],\n    ['Aylık Trend Verisi', data.monthlyTrend ? `${data.monthlyTrend.length} ay` : \"0 ay\"],\n    ['En Karlı Ürün Sayısı', data.topProfitableProducts ? data.topProfitableProducts.length.toString() : \"0\"],\n  ];\n\n  currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Rapor Özeti\", summaryData, [5, 150, 105]);\n\n  // Sayfa numaralarını ekle - template footer kullan\n  try {\n    const totalPages = doc.internal.pages.length - 1;\n    if (totalPages > 0) {\n      for (let i = 1; i <= totalPages; i++) {\n        try {\n          doc.setPage(i);\n          const pageTemplate = createPDFTemplate(doc);\n          drawPDFFooter(doc, pageTemplate, i, totalPages);\n        } catch (pageError) {\n          // Devam et, diğer sayfaları eklemeye çalış\n        }\n      }\n    }\n  } catch (footerError) {\n    // Footer hatası kritik değil, PDF'i yine de döndür\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output('blob');\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n\ninterface SalesOfferPayload {\n  quoteNumber: string;\n  quoteDate: string;\n  validUntil: string;\n  customerName: string;\n  customerCompany: string;\n  customerAddress?: string;\n  customerPhone?: string;\n  customerEmail?: string;\n  projectName: string;\n  deliveryTerms: string;\n  paymentTerms: string;\n  notes: string;\n  currency: string;\n  taxRate: number;\n  discountRate: number;\n  items: Array<{ description: string; quantity: number; unitPrice: number; discount?: number }>;\n  totals: {\n    subtotal: number;\n    discount: number;\n    tax: number;\n    grandTotal: number;\n  };\n  terms?: string[];\n}\n\n/**\n * Kullanıcı istatistikleri PDF'i oluştur\n */\ninterface UserStatsReportData {\n  userName: string;\n  userEmail: string;\n  total: number;\n  accepted: number;\n  rejected: number;\n  pending: number;\n  completed: number;\n  active: number;\n  assignments: Array<{\n    taskTitle: string;\n    status: string;\n    assignedAt: Date | string;\n    completedAt?: Date | string | null;\n  }>;\n}\n\nexport const generateUserStatsPDF = async (userStats: UserStatsReportData): Promise<Blob> => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n  await registerFonts(doc);\n\n  // Font'un gerçekten yüklendiğini doğrula\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    const currentFont = doc.getFont();\n    if (!currentFont || !isRobotoName(currentFont.fontName)) {\n      await registerFonts(doc);\n    }\n  }\n\n  const reportDate = formatDate(new Date().toISOString());\n\n  // PDF Template'i uygula\n  const template = applyPDFTemplate(doc, \"Kullanıcı Performans Raporu\", reportDate);\n  let yPos = template.contentArea.startY;\n  const mar = template.contentArea.leftMargin;\n  const pageWidth = doc.internal.pageSize.getWidth();\n  const pageHeight = doc.internal.pageSize.getHeight();\n\n  const safeTextUser = createSafeText(doc);\n  const safeSetFontUser = (bold: boolean = false) => {\n    safeSetFont(doc, bold ? \"bold\" : \"normal\");\n  };\n\n  // Kullanıcı bilgileri kartı\n  const cardHeight = 110; // Daha ferah: 100 → 110\n  const cardY = yPos;\n  doc.setFillColor(TAILWIND_COLORS.gray50[0], TAILWIND_COLORS.gray50[1], TAILWIND_COLORS.gray50[2]);\n  doc.setDrawColor(TAILWIND_COLORS.gray200[0], TAILWIND_COLORS.gray200[1], TAILWIND_COLORS.gray200[2]);\n  doc.setLineWidth(1.5);\n  doc.roundedRect(mar, cardY, pageWidth - 2 * mar, cardHeight, 6, 6, \"F\");\n  doc.roundedRect(mar, cardY, pageWidth - 2 * mar, cardHeight, 6, 6, \"S\");\n\n  safeSetFontUser(true);\n  doc.setTextColor(31, 41, 55);\n  safeTextUser(\"Kullanıcı Bilgileri\", mar + 15, cardY + 20, 16);\n\n  safeSetFontUser(false);\n  doc.setTextColor(75, 85, 99);\n  safeTextUser(`Kullanıcı Adı: ${userStats.userName}`, mar + 15, cardY + 45, 12);\n  safeTextUser(`E-posta: ${userStats.userEmail}`, mar + 15, cardY + 65, 12);\n  safeTextUser(`Rapor Tarihi: ${new Date().toLocaleDateString(\"tr-TR\", { day: \"2-digit\", month: \"long\", year: \"numeric\" })}`, mar + 15, cardY + 85, 12);\n\n  yPos = cardY + cardHeight + 30;\n\n  // İstatistik kartları (3 sütun)\n  safeSetFontUser(true);\n  doc.setTextColor(31, 41, 55);\n  safeTextUser(\"Performans Özeti\", mar, yPos, 18);\n  yPos += 30;\n\n  const cardWidth = (pageWidth - 2 * mar - 20) / 3;\n  const statCards = [\n    { label: \"Toplam Görev\", value: userStats.total, color: [59, 130, 246], icon: \"📊\" },\n    { label: \"Tamamlanan\", value: userStats.completed, color: [34, 197, 94], icon: \"✅\" },\n    { label: \"Aktif\", value: userStats.active, color: [251, 191, 36], icon: \"🔄\" },\n  ];\n\n  statCards.forEach((stat, index) => {\n    const cardX = mar + index * (cardWidth + 10);\n    const statCardHeight = 90;\n\n    // Gradient efekti simülasyonu\n    doc.setFillColor(stat.color[0], stat.color[1], stat.color[2], 0.1);\n    doc.setDrawColor(stat.color[0], stat.color[1], stat.color[2], 0.3);\n    doc.setLineWidth(1.5);\n    doc.roundedRect(cardX, yPos, cardWidth, statCardHeight, 6, 6, \"F\");\n    doc.roundedRect(cardX, yPos, cardWidth, statCardHeight, 6, 6, \"S\");\n\n    // İkon ve değer\n    safeSetFontUser(true);\n    doc.setTextColor(stat.color[0], stat.color[1], stat.color[2]);\n    safeTextUser(stat.value.toString(), cardX + 15, yPos + 25, 28);\n\n    safeSetFontUser(false);\n    doc.setTextColor(75, 85, 99);\n    safeTextUser(stat.label, cardX + 15, yPos + 55, 11);\n  });\n\n  yPos += 110;\n\n  // Detaylı istatistikler tablosu\n  if (yPos > pageHeight - 200) {\n    doc.addPage();\n    yPos = mar;\n  }\n\n  safeSetFontUser(true);\n  doc.setTextColor(31, 41, 55);\n  safeTextUser(\"Detaylı İstatistikler\", mar, yPos, 18);\n  yPos += 25;\n\n  const detailedStats = [\n    [\"Metrik\", \"Değer\", \"Oran\"],\n    [\"Toplam Görev\", userStats.total.toString(), \"%100\"],\n    [\"Tamamlanan\", userStats.completed.toString(), userStats.total > 0 ? `%${Math.round((userStats.completed / userStats.total) * 100)}` : \"%0\"],\n    [\"Kabul Edilen\", userStats.accepted.toString(), userStats.total > 0 ? `%${Math.round((userStats.accepted / userStats.total) * 100)}` : \"%0\"],\n    [\"Beklemede\", userStats.pending.toString(), userStats.total > 0 ? `%${Math.round((userStats.pending / userStats.total) * 100)}` : \"%0\"],\n    [\"Reddedilen\", userStats.rejected.toString(), userStats.total > 0 ? `%${Math.round((userStats.rejected / userStats.total) * 100)}` : \"%0\"],\n    [\"Aktif Görevler\", userStats.active.toString(), userStats.total > 0 ? `%${Math.round((userStats.active / userStats.total) * 100)}` : \"%0\"],\n  ];\n\n  // Detaylı istatistikler için profesyonel tablo stilleri\n  const detailedTableStyles = createProfessionalTableStyles(doc, {\n    headerFontSize: 12,\n    bodyFontSize: 11,\n    cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n  });\n  detailedTableStyles.headStyles.fillColor = [59, 130, 246];\n  detailedTableStyles.headStyles.textColor = [255, 255, 255];\n  detailedTableStyles.headStyles.halign = \"center\";\n  detailedTableStyles.bodyStyles.halign = \"center\";\n  detailedTableStyles.bodyStyles.textColor = [31, 41, 55];\n\n  const currentPageWidth = doc.internal.pageSize.getWidth();\n  const detailedTableWidth = currentPageWidth - (mar * 2);\n\n  autoTable(doc, {\n    startY: yPos,\n    head: [detailedStats[0]],\n    body: detailedStats.slice(1),\n    willDrawCell: createWillDrawCell(doc),\n    margin: { left: mar, right: mar },\n    tableWidth: detailedTableWidth,\n    ...detailedTableStyles,\n    columnStyles: {\n      0: { cellWidth: detailedTableWidth * 0.50, halign: \"left\" }, // %50 - metrik adı için\n      1: { cellWidth: detailedTableWidth * 0.25, halign: \"center\" }, // %25 - değer için\n      2: { cellWidth: detailedTableWidth * 0.25, halign: \"center\" }, // %25 - oran için\n    },\n  });\n\n  yPos = (doc.lastAutoTable?.finalY || yPos) + 30;\n\n  // Görev listesi\n  if (userStats.assignments.length > 0) {\n    if (yPos > pageHeight - 150) {\n      doc.addPage();\n      yPos = mar;\n    }\n\n    safeSetFontUser(true);\n    doc.setTextColor(31, 41, 55);\n    safeTextUser(\"Görev Detayları\", mar, yPos, 18);\n    yPos += 25;\n\n    const statusLabels: Record<string, string> = {\n      \"pending\": \"Beklemede\",\n      \"accepted\": \"Kabul Edildi\",\n      \"rejected\": \"Reddedildi\",\n      \"completed\": \"Tamamlandı\",\n      \"in_progress\": \"Devam Ediyor\",\n    };\n\n    const assignmentRows = userStats.assignments.map((assignment) => {\n      const assignedDate = assignment.assignedAt instanceof Date\n        ? assignment.assignedAt\n        : new Date(assignment.assignedAt);\n      const completedDate = assignment.completedAt\n        ? (assignment.completedAt instanceof Date\n          ? assignment.completedAt\n          : new Date(assignment.completedAt))\n        : null;\n\n      return [\n        assignment.taskTitle,\n        statusLabels[assignment.status] || assignment.status,\n        assignedDate.toLocaleDateString(\"tr-TR\", { day: \"2-digit\", month: \"2-digit\", year: \"numeric\" }),\n        completedDate\n          ? completedDate.toLocaleDateString(\"tr-TR\", { day: \"2-digit\", month: \"2-digit\", year: \"numeric\" })\n          : \"-\",\n      ];\n    });\n\n    // Profesyonel tablo stilleri kullan (özel header rengi ile)\n    const tableStyles = createProfessionalTableStyles(doc, {\n      headerFontSize: 12,\n      bodyFontSize: 11,\n      cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n    });\n    // Header rengi zaten createProfessionalTableStyles'da primaryColor olarak ayarlandı\n    // Burada override etmeye gerek yok, ama tutarlılık için bırakıyoruz\n    tableStyles.headStyles.fillColor = PDF_CONSTANTS.primaryColor; // Blue\n    tableStyles.headStyles.textColor = [255, 255, 255]; // White\n    tableStyles.headStyles.halign = \"center\";\n    tableStyles.bodyStyles.halign = \"left\";\n    tableStyles.bodyStyles.overflow = 'linebreak';\n    tableStyles.styles.overflow = 'linebreak';\n\n    // Sayfa sığma kontrolü\n    yPos = ensureTableFitsPage(doc, yPos, 200, mar, \"Görev Detayları\");\n\n    // Tablo genişliğini sayfa genişliğine göre ayarla\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const tableWidth = currentPageWidth - (mar * 2);\n\n    autoTable(doc, {\n      startY: yPos,\n      head: [[\"Görev Başlığı\", \"Durum\", \"Atanma Tarihi\", \"Tamamlanma Tarihi\"]],\n      body: assignmentRows,\n      margin: { left: mar, right: mar },\n      tableWidth: tableWidth,\n      willDrawCell: createWillDrawCell(doc),\n      ...tableStyles,\n      columnStyles: {\n        0: { cellWidth: tableWidth * 0.40, halign: \"left\", overflow: 'linebreak' }, // %40 - görev başlığı için daha fazla alan\n        1: { cellWidth: tableWidth * 0.20, halign: \"center\" }, // %20\n        2: { cellWidth: tableWidth * 0.20, halign: \"center\" }, // %20\n        3: { cellWidth: tableWidth * 0.20, halign: \"center\" }, // %20\n      },\n    });\n  }\n\n  // Özet bölümü\n  const finalY = doc.lastAutoTable?.finalY || yPos;\n  if (finalY < pageHeight - 120) {\n    yPos = finalY + 30;\n\n    // Özet metnini hazırla\n    const completionRate = userStats.total > 0 ? Math.round((userStats.completed / userStats.total) * 100) : 0;\n    const summaryText = `${userStats.userName} kullanıcısı toplam ${userStats.total} görev almış, ${userStats.completed} görevi tamamlamıştır. Tamamlanma oranı: %${completionRate}`;\n\n    // Metni satırlara böl (maksimum genişlik kontrolü)\n    const currentPageWidth = doc.internal.pageSize.getWidth();\n    const maxWidth = currentPageWidth - 2 * mar - 30; // 30pt padding\n    const lines = doc.splitTextToSize(summaryText, maxWidth);\n    const lineHeight = 14;\n    const summaryHeight = Math.max(70, 20 + (lines.length * lineHeight) + 10); // Minimum 70pt, dinamik yükseklik\n\n    // Sayfa sığmazsa yeni sayfa ekle\n    if (yPos + summaryHeight > pageHeight - 100) {\n      doc.addPage();\n      const template = createPDFTemplate(doc);\n      drawPDFBackground(doc, template);\n      yPos = mar + 30;\n    }\n\n    safeSetFontUser(true);\n    doc.setTextColor(255, 255, 255);\n    doc.setFillColor(59, 130, 246);\n    doc.setDrawColor(59, 130, 246);\n    doc.setLineWidth(1.5);\n    const summaryPageWidth = doc.internal.pageSize.getWidth();\n    doc.roundedRect(mar, yPos, summaryPageWidth - 2 * mar, summaryHeight, 6, 6, \"F\");\n    doc.roundedRect(mar, yPos, summaryPageWidth - 2 * mar, summaryHeight, 6, 6, \"S\");\n\n    safeTextUser(\"Özet\", mar + 15, yPos + 20, 16);\n\n    safeSetFontUser(false);\n    doc.setTextColor(255, 255, 255);\n    // Metni satır satır yaz\n    lines.forEach((line: string, index: number) => {\n      safeTextUser(line, mar + 15, yPos + 40 + (index * lineHeight), 11);\n    });\n  }\n\n  // Footer'ı ekle\n  try {\n    const finalTemplate = createPDFTemplate(doc);\n    drawPDFFooter(doc, finalTemplate);\n  } catch (footerError) {\n    // Footer hatası kritik değil, PDF'i yine de döndür\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output(\"blob\");\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n\n/**\n * PDF Generation Summary:\n * - Library: jsPDF + jspdf-autotable (programmatic PDF generation, NOT html2canvas or react-pdf)\n * - File: src/services/pdfGenerator.ts -> generateSalesOfferPDF()\n * - A4 Dimensions: 595pt (width) x 842pt (height) in portrait\n * - Margins: 40pt on all sides\n * - Content Width: 515pt (595 - 80)\n * \n * Layout Constraints:\n * - Header: Top 20% of page (max 170pt)\n * - Table: Central area with percentage-based column widths\n * - Notes/Totals: Bottom area, split 50/50\n * - Footer: Fixed 60pt at bottom\n * \n * Column Widths (percentage-based to fit A4):\n * - No: 8% (~41pt)\n * - Ürün Adı: 48% (~247pt)\n * - Adet: 10% (~52pt)\n * - Birim Fiyat: 17% (~88pt)\n * - Toplam: 17% (~88pt)\n */\nexport const generateSalesOfferPDF = async (payload: SalesOfferPayload) => {\n  const doc = createPdf({ format: \"a4\", unit: \"pt\" });\n  await registerFonts(doc);\n\n  // Font'un gerçekten yüklendiğini doğrula\n  if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\n    const currentFont = doc.getFont();\n    if (!currentFont || !isRobotoName(currentFont.fontName)) {\n      await registerFonts(doc);\n    }\n  }\n\n  applyDocumentTypography(doc);\n\n  // A4 dimensions and margins - FIXED VALUES\n  const mar = 40; // Margin on all sides\n  const pageWidth = 595; // A4 width in pt\n  const pageHeight = 842; // A4 height in pt\n  const contentWidth = pageWidth - (mar * 2); // 515pt usable width\n\n  // Verify actual page size matches expected A4\n  const actualWidth = doc.internal.pageSize.getWidth();\n  const actualHeight = doc.internal.pageSize.getHeight();\n  if (Math.abs(actualWidth - pageWidth) > 1 || Math.abs(actualHeight - pageHeight) > 1) {\n  }\n\n  // Header - Form Preview Style\n  // Logo ve Şirket Bilgileri (Sağ Üst)\n  const logoWidth = 40;\n  const logoHeight = 40;\n  const logoX = pageWidth - mar - 160; // Logo ve text için alan ayır\n\n  // Helper functions\n  const safeNumber = (value: unknown): number => {\n    const num = Number(value);\n    return (isNaN(num) || !isFinite(num)) ? 0 : num;\n  };\n\n  const safeFormatCurrency = (value: number, currency: string): string => {\n    const safeVal = safeNumber(value);\n    // Türkçe locale kullan (web UI ile uyumlu)\n    return `${currency}${safeVal.toLocaleString(\"tr-TR\", { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;\n  };\n\n  // Create safeText helper with color support - createSafeText kullan\n  const baseSafeText = createSafeText(doc);\n  const safeText = (text: string, x: number, y: number, fontSize: number, isBold: boolean = false, color?: [number, number, number]) => {\n    try {\n      // Renk ayarla\n      if (color) {\n        doc.setTextColor(color[0], color[1], color[2]);\n      }\n\n      // createSafeText kullan (Türkçe karakter desteği ile)\n      baseSafeText(text, x, y, fontSize, isBold);\n\n      // Renk sıfırla\n      if (color) {\n        doc.setTextColor(0, 0, 0);\n      }\n    } catch (error) {\n      // Hata durumunda fallback\n      try {\n        doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\n        doc.setFontSize(fontSize);\n        // Problemli karakterleri transliterate et\n        const hasProblematicChars = /[şŞİğĞ]/.test(text);\n        const safeTextFallback = hasProblematicChars ? transliterateTurkish(text) : text;\n        if (color) {\n          doc.setTextColor(color[0], color[1], color[2]);\n        }\n        doc.text(safeTextFallback, x, y);\n        doc.setTextColor(0, 0, 0);\n      } catch (fallbackError) {\n      }\n    }\n  };\n\n  // Background: Light grey diagonal/triangular panel on the left side\n  try {\n    doc.setFillColor(243, 244, 246); // gray-100 - light grey\n    doc.setGState(doc.GState({ opacity: 0.3 }));\n\n    // Diagonal triangular shape on the left\n    // Create a polygon-like shape using multiple rectangles\n    const bgStartX = 0;\n    const bgStartY = 0;\n    const bgWidth = 200; // Width of the grey panel\n    const bgHeight = pageHeight;\n\n    // Draw diagonal shape\n    doc.rect(bgStartX, bgStartY, bgWidth, bgHeight, \"F\");\n\n    // Reset opacity\n    doc.setGState(doc.GState({ opacity: 1 }));\n  } catch (error) {\n  }\n\n  // Header Y position - Optimized for A4 (top 20% of page = ~170pt max)\n  const headerY = 45; // Reduced from 50\n\n  // Left Side: Title - Two lines: \"SATIŞ TEKLİFİ\" and \"FORMU\"\n  // Reduced font size slightly for better fit\n  safeText(\"SATIŞ TEKLİFİ\", mar, headerY, 30, true); // Reduced from 32\n  safeText(\"FORMU\", mar, headerY + 36, 30, true); // Reduced from 32, adjusted spacing\n\n  // Customer Info Block - Left side, aligned with title\n  const customerBlockY = headerY + 90; // Reduced from 100 for tighter spacing\n  safeText(\"Müşteri\", mar, customerBlockY, 14, true);\n\n  const customerName = payload.customerName || \"\";\n  const customerCompany = payload.customerCompany || \"\";\n  const customerAddress = payload.customerAddress || \"\";\n  const customerPhone = payload.customerPhone || \"\";\n  const customerEmail = payload.customerEmail || \"\";\n\n  let customerY = customerBlockY + 24;\n\n  // Customer name/company (prioritize customerName over customerCompany)\n  const customerText = customerName || customerCompany || \"\";\n  if (customerText) {\n    safeSetFont(doc, \"normal\");\n    doc.setFontSize(14);\n    const customerLines = doc.splitTextToSize(customerText, 280);\n    customerLines.forEach((line: string) => {\n      doc.setTextColor(31, 41, 55); // gray-800\n      safeText(line, mar, customerY, 14, false);\n      doc.setTextColor(0, 0, 0);\n      customerY += 18;\n    });\n  }\n\n  // Additional customer details (address, phone, email) - each on a new line\n  const customerDetails: string[] = [];\n  if (customerAddress) customerDetails.push(customerAddress);\n  if (customerPhone) customerDetails.push(customerPhone);\n  if (customerEmail) customerDetails.push(customerEmail);\n\n  customerDetails.forEach((detail) => {\n    doc.setTextColor(107, 114, 128); // gray-500\n    safeSetFont(doc, \"normal\");\n    doc.setFontSize(11);\n    const detailLines = doc.splitTextToSize(detail, 280);\n    detailLines.forEach((line: string) => {\n      safeText(line, mar, customerY, 11, false);\n      customerY += 14;\n    });\n    doc.setTextColor(0, 0, 0);\n  });\n\n  // Right Side: Logo & Company Info - Top right\n  const rightContentX = pageWidth - mar;\n  const companyInfoY = headerY;\n  const headerLogoSize = 40; // 50 → 40 (daha küçük logo)\n\n  // Logo - sağ üst köşede, doğru pozisyonda\n  try {\n    const logoX = rightContentX - headerLogoSize;\n    doc.addImage(REV_LOGO_DATA_URI, 'PNG', logoX, companyInfoY, headerLogoSize, headerLogoSize);\n  } catch (error) {\n  }\n\n  // Company address block - under logo, right-aligned (daha kompakt)\n  const addressLines = [\n    COMPANY_INFO.address,\n    COMPANY_INFO.city,\n    COMPANY_INFO.email,\n    COMPANY_INFO.website,\n    COMPANY_INFO.phone\n  ];\n\n  let addrY = companyInfoY + headerLogoSize + 10; // 14 → 10 (daha az boşluk)\n  safeSetFont(doc, \"normal\");\n  doc.setFontSize(9); // 10 → 9 (daha küçük font)\n  addressLines.forEach(line => {\n    try {\n      const lineWidth = doc.getTextWidth(line);\n      doc.setTextColor(75, 85, 99); // gray-600\n      safeText(line, rightContentX - lineWidth, addrY, 9, false);\n      doc.setTextColor(0, 0, 0);\n      addrY += 11; // 13 → 11 (daha kompakt satır aralığı)\n    } catch (error) {\n      addrY += 11;\n    }\n  });\n\n  // Date Info - Right side, şirket bilgilerinden sonra (üst üste binmeyi önlemek için)\n  // Şirket bilgileri: addrY başlangıç + (5 satır * 11pt) = companyInfoY + headerLogoSize + 10 + 55 = companyInfoY + 105\n  const dateInfoY = companyInfoY + headerLogoSize + 10 + (addressLines.length * 11) + 12; // Şirket bilgilerinden sonra 12pt boşluk\n\n  // Format dates in Turkish format: \"20 Ağustos 2025\"\n  const formatDateTurkish = (dateStr: string | Date): string => {\n    try {\n      const date = typeof dateStr === 'string' ? new Date(dateStr) : dateStr;\n      if (isNaN(date.getTime())) {\n        // If already formatted (contains Turkish month names), return as is\n        if (typeof dateStr === 'string' && (dateStr.includes('Ocak') || dateStr.includes('Şubat') || dateStr.includes('Mart') || dateStr.includes('Nisan') || dateStr.includes('Mayıs') || dateStr.includes('Haziran') || dateStr.includes('Temmuz') || dateStr.includes('Ağustos') || dateStr.includes('Eylül') || dateStr.includes('Ekim') || dateStr.includes('Kasım') || dateStr.includes('Aralık'))) {\n          return dateStr;\n        }\n        return formatDate(String(dateStr));\n      }\n      const months = [\"Ocak\", \"Şubat\", \"Mart\", \"Nisan\", \"Mayıs\", \"Haziran\", \"Temmuz\", \"Ağustos\", \"Eylül\", \"Ekim\", \"Kasım\", \"Aralık\"];\n      return `${date.getDate()} ${months[date.getMonth()]} ${date.getFullYear()}`;\n    } catch (error) {\n      return formatDate(String(dateStr));\n    }\n  };\n\n  // Tarih - sağa yaslı\n  const dateLabel = \"Tarih:\";\n  let dateValue: string = \"-\";\n  try {\n    dateValue = formatDateTurkish(payload.quoteDate);\n  } catch (error) {\n    dateValue = \"-\";\n  }\n\n  safeSetFont(doc, \"bold\");\n  doc.setFontSize(14);\n  const dateLabelWidth = doc.getTextWidth(dateLabel);\n  safeSetFont(doc, \"normal\");\n  doc.setFontSize(14);\n  const dateValueWidth = doc.getTextWidth(dateValue);\n  const dateX = rightContentX - dateValueWidth;\n  safeText(dateLabel, dateX - dateLabelWidth - 6, dateInfoY, 14, true);\n  doc.setTextColor(55, 65, 81); // gray-700\n  safeText(dateValue, dateX, dateInfoY, 14, false);\n  doc.setTextColor(0, 0, 0);\n\n  // Geçerlilik Tarihi - sağa yaslı, altında\n  const validLabel = \"Geçerlilik Tarihi:\";\n  let validValue: string = \"-\";\n  try {\n    validValue = formatDateTurkish(payload.validUntil);\n  } catch (error) {\n    validValue = \"-\";\n  }\n\n  safeSetFont(doc, \"bold\");\n  doc.setFontSize(14);\n  const validLabelWidth = doc.getTextWidth(validLabel);\n  safeSetFont(doc, \"normal\");\n  doc.setFontSize(14);\n  const validValueWidth = doc.getTextWidth(validValue);\n  const validX = rightContentX - validValueWidth;\n  safeText(validLabel, validX - validLabelWidth - 6, dateInfoY + 22, 14, true);\n  doc.setTextColor(55, 65, 81); // gray-700\n  safeText(validValue, validX, dateInfoY + 22, 14, false);\n  doc.setTextColor(0, 0, 0);\n\n  // Table starts after customer/date blocks - ensure enough space\n  // Optimized spacing for A4 layout\n  const maxBottomY = Math.max(customerY, dateInfoY + 40); // Reduced from 45\n  let currentY = maxBottomY + 30; // Reduced from 35 for tighter layout\n\n  // Products Table - Full width with columns: No, Ürün Adı, Adet, Birim Fiyat, Toplam\n  const items = Array.isArray(payload.items) ? payload.items.filter(item => item.description && item.description.trim() !== \"\") : [];\n\n  const tableBody = items.map((item, index) => {\n    const unitPrice = safeNumber(item.unitPrice);\n    const quantity = safeNumber(item.quantity);\n    const discount = safeNumber(item.discount || 0);\n    const lineTotal = (quantity * unitPrice) - discount;\n\n    return [\n      (index + 1).toString(), // No (1-based)\n      item.description || \"-\", // Ürün Adı (supports multi-line)\n      quantity.toString(), // Adet\n      safeFormatCurrency(unitPrice, payload.currency || \"$\"), // Birim Fiyat\n      safeFormatCurrency(lineTotal, payload.currency || \"$\"), // Toplam\n    ];\n  });\n\n  const tableHead = [[\"No\", \"Ürün Adı\", \"Adet\", \"Birim Fiyat\", \"Toplam\"]];\n\n  let startY = currentY;\n  const baseDidParseCell = createDidParseCell(doc);\n\n  // Alternatif satır renkleri için özel didParseCell\n  const didParseCell = (data: { row?: { index?: number }; cell?: { styles?: { fillColor?: number[] } } }) => {\n    // Base fonksiyonu çağır\n    if (baseDidParseCell) {\n      baseDidParseCell(data);\n    }\n\n    // Body satırları için alternatif renk (header hariç, index 0 header)\n    if (data.row && data.row.index !== undefined && data.cell && data.cell.styles) {\n      const rowIndex = data.row.index;\n      // Header index 0, body satırları 1'den başlar\n      if (rowIndex > 0) {\n        // Çift satırlar için alternatif renk (2, 4, 6, ... - 0-based değil, 1-based body)\n        if ((rowIndex - 1) % 2 === 1) {\n          data.cell.styles.fillColor = [248, 250, 252]; // slate-50\n        } else {\n          data.cell.styles.fillColor = [255, 255, 255]; // Beyaz\n        }\n      }\n    }\n  };\n\n  // Dinamik tablo genişliği hesaplama (diğer tablolarla tutarlı)\n  const dynamicPageWidth = doc.internal.pageSize.getWidth();\n  const tableWidth = dynamicPageWidth - (mar * 2);\n\n  // Profesyonel tablo stilleri kullan (modern UI/UX kurallarına uygun)\n  const tableStyles = createProfessionalTableStyles(doc, {\n    headerFontSize: 11,\n    bodyFontSize: 10,\n    cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\n  });\n\n  // Modern, profesyonel renk paleti\n  tableStyles.headStyles.fillColor = [15, 23, 42]; // slate-900 - daha koyu, profesyonel\n  tableStyles.headStyles.textColor = [255, 255, 255]; // White\n  tableStyles.headStyles.halign = \"center\";\n  tableStyles.headStyles.fontStyle = \"bold\";\n  tableStyles.headStyles.fontSize = 11;\n  tableStyles.headStyles.lineColor = [15, 23, 42]; // slate-900 border\n  tableStyles.headStyles.lineWidth = { top: 0, bottom: 2, left: 0, right: 0 }; // Kalın alt border\n  tableStyles.headStyles.cellPadding = { top: 12, right: 14, bottom: 12, left: 14 };\n  tableStyles.headStyles.minCellHeight = 36;\n\n  // Body stilleri - daha temiz ve okunabilir\n  tableStyles.bodyStyles.fillColor = [255, 255, 255]; // Beyaz\n  tableStyles.bodyStyles.textColor = [30, 41, 59]; // slate-700 - daha koyu, okunabilir\n  tableStyles.bodyStyles.fontSize = 10;\n  tableStyles.bodyStyles.fontStyle = \"normal\";\n  tableStyles.bodyStyles.lineColor = [226, 232, 240]; // slate-200 - daha açık border\n  tableStyles.bodyStyles.lineWidth = { bottom: 0.5, top: 0, left: 0, right: 0 }; // İnce alt border\n  tableStyles.bodyStyles.cellPadding = { top: 12, right: 14, bottom: 12, left: 14 };\n  tableStyles.bodyStyles.minCellHeight = 32;\n  tableStyles.bodyStyles.overflow = 'linebreak';\n\n  // Alternatif satır renkleri (zebra striping) - daha profesyonel\n  tableStyles.alternateRowStyles.fillColor = [248, 250, 252]; // slate-50 - çok açık gri\n  tableStyles.styles.overflow = 'linebreak';\n\n  // Sayfa sığma kontrolü\n  startY = ensureTableFitsPage(doc, startY, 300, mar, \"Ürün Listesi\");\n\n  // Font'u zorla Roboto olarak ayarla (autoTable öncesi)\n  forceRobotoFont(doc, \"normal\");\n\n  autoTable(doc, {\n    head: transliterateTableData(tableHead),\n    body: transliterateTableData(tableBody.length === 0\n      ? [[\"\", \"Kalem bilgisi girilmedi\", \"\", \"\", \"\"]]\n      : tableBody),\n    startY,\n    margin: { left: mar, right: mar },\n    didParseCell: didParseCell,\n    tableWidth: tableWidth, // Dinamik genişlik kullan\n    ...tableStyles,\n    columnStyles: {\n      0: {\n        cellWidth: tableWidth * 0.08,\n        halign: \"center\",\n        textColor: [71, 85, 105], // slate-600 - daha yumuşak\n        fontStyle: \"normal\"\n      }, // %8 - No\n      1: {\n        cellWidth: tableWidth * 0.48,\n        halign: \"left\",\n        overflow: 'linebreak',\n        textColor: [15, 23, 42], // slate-900 - ürün adı daha koyu\n        fontStyle: \"normal\"\n      }, // %48 - Ürün Adı\n      2: {\n        cellWidth: tableWidth * 0.10,\n        halign: \"center\",\n        textColor: [30, 41, 59], // slate-700\n        fontStyle: \"normal\"\n      }, // %10 - Adet\n      3: {\n        cellWidth: tableWidth * 0.17,\n        halign: \"right\",\n        textColor: [30, 41, 59], // slate-700\n        fontStyle: \"normal\"\n      }, // %17 - Birim Fiyat\n      4: {\n        cellWidth: tableWidth * 0.17,\n        halign: \"right\",\n        textColor: [15, 23, 42], // slate-900 - toplam daha vurgulu\n        fontStyle: \"bold\" // Toplam sütunu bold\n      }, // %17 - Toplam\n    },\n  });\n\n  // Get actual table end position - minimum 30pt boşluk (diğer tablolarla tutarlı)\n  let tableEndY = (doc.lastAutoTable?.finalY || startY);\n  if (doc.lastAutoTable?.finalY) {\n    tableEndY = doc.lastAutoTable.finalY + 50; // Optimize edilmiş boşluk: 50pt\n  } else {\n    tableEndY = startY + 50; // Fallback: eğer lastAutoTable yoksa\n  }\n\n  // Layout: Left (Notes) - Right (Totals) at bottom\n  // Calculate available space - ensure footer doesn't overlap\n  const footerReservedSpace = 70; // Space reserved for footer (reduced from 80)\n  const minSpaceForNotesAndTotals = 180; // Minimum space needed (reduced from 200)\n  const availableSpace = pageHeight - tableEndY - footerReservedSpace;\n\n  // Check if we need a new page for notes/totals\n  let notesStartY = tableEndY + 25; // Reduced from 30\n  if (availableSpace < minSpaceForNotesAndTotals) {\n    doc.addPage();\n    notesStartY = 45; // Reduced from 50\n    tableEndY = notesStartY - 25; // Reset for new page\n  }\n\n  // Left Column: Notes area (bottom left)\n  // Optimized for A4: exactly half width minus gap\n  let notesY = notesStartY;\n  const notesWidth = (contentWidth / 2) - 15; // Gap between columns: 15pt\n\n  // Collect all notes/terms\n  const allNotes: string[] = [];\n  if (payload.notes && payload.notes.trim() !== \"\") {\n    allNotes.push(payload.notes);\n  }\n  if (payload.deliveryTerms && payload.deliveryTerms.trim() !== \"\") {\n    allNotes.push(`Teslimat: ${payload.deliveryTerms}`);\n  }\n  if (payload.paymentTerms && payload.paymentTerms.trim() !== \"\") {\n    allNotes.push(`Ödeme: ${payload.paymentTerms}`);\n  }\n  if (payload.terms && payload.terms.length > 0) {\n    allNotes.push(...payload.terms);\n  }\n\n  // Render notes with bullet points\n  allNotes.forEach((note) => {\n    try {\n      safeSetFont(doc, \"normal\");\n      doc.setFontSize(11);\n      doc.setTextColor(107, 114, 128); // gray-500\n      safeText(\"•\", mar, notesY, 11, false);\n      doc.setTextColor(0, 0, 0);\n\n      // Wrap text\n      const noteLines = doc.splitTextToSize(note, notesWidth - 15);\n      let noteLineY = notesY;\n      noteLines.forEach((line: string) => {\n        doc.setTextColor(75, 85, 99); // gray-600\n        safeText(line, mar + 12, noteLineY, 11, false);\n        doc.setTextColor(0, 0, 0);\n        noteLineY += 14;\n      });\n      notesY += (noteLines.length * 14) + 6;\n    } catch (error) {\n      notesY += 16;\n    }\n  });\n\n  // Right Column: Totals (bottom right, aligned)\n  const totals = payload.totals || { subtotal: 0, discount: 0, tax: 0, grandTotal: 0 };\n  const currency = payload.currency || \"$\";\n\n  const safeSubtotal = safeNumber(totals.subtotal);\n  const safeDiscount = safeNumber(totals.discount);\n  const safeTax = safeNumber(totals.tax);\n  const safeGrandTotal = safeNumber(totals.grandTotal);\n  const safeTaxRate = safeNumber(payload.taxRate || 20);\n\n  // Right column X position - ensure proper alignment\n  // Start at middle of page + gap\n  const rightColX = mar + (contentWidth / 2) + 15; // Gap: 15pt (matches notesWidth gap)\n\n  // Start totals from same Y as notes\n  let totalsY = notesStartY;\n\n  // Helper for right aligned totals row\n  // Optimized font sizes for A4\n  const drawTotalRow = (label: string, value: string, isBold = false, isGrandTotal = false) => {\n    try {\n      const fontSize = isGrandTotal ? 14 : 12; // Reduced: 16→14, 14→12\n      safeSetFont(doc, isBold || isGrandTotal ? \"bold\" : \"normal\");\n      doc.setFontSize(fontSize);\n\n      const valueWidth = doc.getTextWidth(value);\n\n      // Label on left side of totals area, value on right\n      safeText(label, rightColX, totalsY, fontSize, isBold || isGrandTotal);\n      safeText(value, rightContentX - valueWidth, totalsY, fontSize, isBold || isGrandTotal);\n\n      totalsY += isGrandTotal ? 22 : 18; // Reduced spacing: 26→22, 20→18\n    } catch (error) {\n      totalsY += isGrandTotal ? 20 : 18; // Reduced spacing\n    }\n  };\n\n  // Discount (if any)\n  if (safeDiscount > 0) {\n    drawTotalRow(\"Toplam İskonto:\", `-${safeFormatCurrency(safeDiscount, currency)}`);\n  }\n\n  // Ara Toplam\n  drawTotalRow(\"Ara Toplam:\", safeFormatCurrency(safeSubtotal, currency));\n\n  // KDV\n  drawTotalRow(`KDV (%${safeTaxRate.toFixed(0)}):`, safeFormatCurrency(safeTax, currency));\n\n  // Separator line\n  doc.setDrawColor(107, 114, 128); // gray-500\n  doc.setLineWidth(1.5);\n  doc.line(rightColX, totalsY - 6, rightContentX, totalsY - 6);\n  totalsY += 10;\n\n  // GENEL TOPLAM (bold, bigger) - Optimized for A4\n  const grandTotalLabel = \"GENEL TOPLAM:\";\n  const grandTotalValue = safeFormatCurrency(safeGrandTotal, currency);\n\n  safeSetFont(doc, \"bold\");\n  doc.setFontSize(14); // Reduced from 16 for better fit\n  const grandTotalValueWidth = doc.getTextWidth(grandTotalValue);\n  safeText(grandTotalLabel, rightColX, totalsY, 14, true);\n  safeText(grandTotalValue, rightContentX - grandTotalValueWidth, totalsY, 14, true);\n\n  // Footer - Bottom of page, ensure it doesn't overlap content\n  // Optimized spacing for A4\n  const maxContentY = Math.max(notesY, totalsY) + 15; // Reduced from 20\n  const footerHeight = 55; // Reduced from 60\n  const footerBottomY = pageHeight - footerHeight;\n\n  // Check if content overlaps footer area\n  if (maxContentY > footerBottomY - 25) { // Reduced threshold from 30\n    // Content too close to footer, add new page for footer\n    doc.addPage();\n  }\n\n  // Draw footer on current page (or new page if added)\n  const currentPageHeight = doc.internal.pageSize.getHeight();\n  const footerY = currentPageHeight - footerHeight;\n\n  // Footer separator line\n  doc.setDrawColor(209, 213, 219); // gray-300\n  doc.setLineWidth(1);\n  doc.line(mar, footerY - 10, rightContentX, footerY - 10);\n\n  // Left: Company legal info\n  safeSetFont(doc, \"bold\");\n  doc.setFontSize(10);\n  doc.setTextColor(31, 41, 55); // gray-800\n  safeText(COMPANY_INFO.name, mar, footerY, 10, true);\n  doc.setTextColor(0, 0, 0);\n\n  safeSetFont(doc, \"normal\");\n  doc.setFontSize(9);\n  doc.setTextColor(75, 85, 99); // gray-600\n  safeText(COMPANY_INFO.fullAddress, mar, footerY + 12, 9, false);\n  safeText(`${COMPANY_INFO.email} | ${COMPANY_INFO.website} | ${COMPANY_INFO.phone}`, mar, footerY + 22, 9, false);\n  doc.setTextColor(0, 0, 0);\n\n  // Right: Logo (smaller size, bottom-right aligned)\n  try {\n    const footerLogoSize = 28;\n    const logoX = rightContentX - footerLogoSize;\n    doc.addImage(REV_LOGO_DATA_URI, 'PNG', logoX, footerY, footerLogoSize, footerLogoSize);\n  } catch (error) {\n  }\n\n  // PDF'i güvenli bir şekilde oluştur\n  try {\n    const blob = doc.output(\"blob\");\n    if (!blob || blob.size === 0) {\n      throw new Error(\"PDF blob boş veya geçersiz\");\n    }\n    return blob;\n  } catch (outputError) {\n    throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\pdf\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\pdf\\pdfCore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":594,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19286,19289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19286,19289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PDF Generator Core\r\n * Core PDF functionality, constants, types, and shared utilities\r\n * Extracted from pdfGenerator.ts for better maintainability\r\n */\r\n\r\nimport jsPDF, { jsPDFOptions } from \"jspdf\";\r\nimport autoTable, { CellHookData as AutoTableCellHookData } from \"jspdf-autotable\";\r\nimport { REV_LOGO_DATA_URI } from \"@/assets/rev-logo-base64\";\r\n\r\n// Company info\r\nexport const COMPANY_INFO = {\r\n    name: \"Revium Tech\",\r\n    contactInfo: \"info@reviumtech.com | www.reviumtech.com | +90 (551) 829-1613\",\r\n    headerAddress: \"Fevzi Cakmak Mah. Milenyum Cad. No:81\",\r\n} as const;\r\n\r\n// PDF sabit değerleri - cache'lenmiş\r\nexport const PDF_CONSTANTS = {\r\n    margin: 50,\r\n    headerHeight: 120,\r\n    footerHeight: 50,\r\n    logoSize: 40,\r\n    footerLogoSize: 28,\r\n    lineHeight: 14,\r\n    primaryColor: [30, 41, 59] as [number, number, number],\r\n    secondaryColor: [100, 116, 139] as [number, number, number],\r\n    accentColor: [37, 99, 235] as [number, number, number],\r\n    backgroundColor: [248, 250, 252] as [number, number, number],\r\n    borderColor: [226, 232, 240] as [number, number, number],\r\n    sectionSpacing: 20,\r\n    tableSpacing: 20,\r\n    fontSizeTitle: 16,\r\n    fontSizeSubtitle: 12,\r\n    fontSizeBody: 11,\r\n    fontSizeSmall: 10,\r\n    fontSizeCardTitle: 12,\r\n    fontSizeCardValue: 24,\r\n    fontSizeCardDescription: 11,\r\n    fontSizeTableHeader: 16,\r\n    fontSizeTableBody: 11,\r\n    fontSizeTableHeaderText: 12,\r\n} as const;\r\n\r\n// Profesyonel renk paleti\r\nexport const TAILWIND_COLORS = {\r\n    // Card backgrounds\r\n    cardBackground: [248, 250, 252] as [number, number, number],\r\n    cardBorder: [226, 232, 240] as [number, number, number],\r\n    cardText: [51, 65, 85] as [number, number, number],\r\n    cardValue: [15, 23, 42] as [number, number, number],\r\n\r\n    // Primary kart (vurgulu)\r\n    primaryCardBg: [255, 255, 255] as [number, number, number],\r\n    primaryCardBorder: [221, 83, 53] as [number, number, number],\r\n    primaryCardValue: [221, 83, 53] as [number, number, number],\r\n\r\n    // Status colors\r\n    successCardBg: [240, 253, 244] as [number, number, number],\r\n    successCardBorder: [187, 247, 208] as [number, number, number],\r\n    successCardValue: [22, 163, 74] as [number, number, number],\r\n\r\n    infoCardBg: [239, 246, 255] as [number, number, number],\r\n    infoCardBorder: [191, 219, 254] as [number, number, number],\r\n    infoCardValue: [37, 99, 235] as [number, number, number],\r\n\r\n    warningCardBg: [255, 251, 235] as [number, number, number],\r\n    warningCardBorder: [254, 215, 170] as [number, number, number],\r\n    warningCardValue: [234, 88, 12] as [number, number, number],\r\n\r\n    dangerCardBg: [254, 242, 242] as [number, number, number],\r\n    dangerCardBorder: [254, 202, 202] as [number, number, number],\r\n    dangerCardValue: [220, 38, 38] as [number, number, number],\r\n\r\n    // Grayscale\r\n    gray50: [249, 250, 251] as [number, number, number],\r\n    gray100: [243, 244, 246] as [number, number, number],\r\n    gray200: [229, 231, 235] as [number, number, number],\r\n    gray300: [209, 213, 219] as [number, number, number],\r\n    gray400: [156, 163, 175] as [number, number, number],\r\n    gray500: [107, 114, 128] as [number, number, number],\r\n    gray600: [75, 85, 99] as [number, number, number],\r\n    gray700: [55, 65, 81] as [number, number, number],\r\n    gray800: [30, 41, 59] as [number, number, number],\r\n    gray900: [15, 23, 42] as [number, number, number],\r\n    white: [255, 255, 255] as [number, number, number],\r\n} as const;\r\n\r\n// Types\r\nexport interface PDFTemplateLayout {\r\n    background: {\r\n        startY: number;\r\n        endY: number;\r\n    };\r\n    header: {\r\n        startY: number;\r\n        endY: number;\r\n        logoX: number;\r\n        logoY: number;\r\n        titleX: number;\r\n        titleY: number;\r\n    };\r\n    contentArea: {\r\n        startY: number;\r\n        endY: number;\r\n        width: number;\r\n        leftMargin: number;\r\n        rightMargin: number;\r\n    };\r\n}\r\n\r\nexport interface StatCardConfig {\r\n    title: string;\r\n    value: string | number;\r\n    description?: string;\r\n    color: {\r\n        background: [number, number, number];\r\n        border: [number, number, number];\r\n        text: [number, number, number];\r\n        value: [number, number, number];\r\n    };\r\n}\r\n\r\nexport interface TableHeaderConfig {\r\n    title: string;\r\n    backgroundColor?: [number, number, number];\r\n    textColor?: [number, number, number];\r\n    borderColor?: [number, number, number];\r\n}\r\n\r\nexport interface TotalsSummary {\r\n    subtotal: number;\r\n    discount: number;\r\n    tax: number;\r\n    grandTotal: number;\r\n}\r\n\r\nexport interface ProfessionalTableStyles {\r\n    headStyles: Record<string, unknown>;\r\n    bodyStyles: Record<string, unknown>;\r\n    styles: Record<string, unknown>;\r\n    alternateRowStyles: Record<string, unknown>;\r\n}\r\n\r\n// Font status interface\r\nexport interface jsPDFWithFontStatus extends jsPDF {\r\n    _robotoFontLoaded?: boolean;\r\n    _robotoFontLoadFailed?: boolean;\r\n    _robotoSupportsTurkish?: boolean;\r\n    _turkishCharsTested?: boolean;\r\n    lastAutoTable?: {\r\n        finalY?: number;\r\n    };\r\n}\r\n\r\n// Helper functions\r\n\r\n/**\r\n * Türkçe karakterleri ASCII'ye çevir\r\n */\r\nexport function transliterateTurkish(text: string): string {\r\n    const turkishMap: Record<string, string> = {\r\n        'ç': 'c', 'Ç': 'C',\r\n        'ğ': 'g', 'Ğ': 'G',\r\n        'ı': 'i', 'İ': 'I',\r\n        'ö': 'o', 'Ö': 'O',\r\n        'ş': 's', 'Ş': 'S',\r\n        'ü': 'u', 'Ü': 'U',\r\n    };\r\n\r\n    return text.replace(/[çÇğĞıİöÖşŞüÜ]/g, (char) => turkishMap[char] || char);\r\n}\r\n\r\n/**\r\n * AutoTable verilerini transliterate et\r\n */\r\nexport function transliterateTableData(\r\n    data: (string | number)[][] | null | undefined,\r\n    doc?: jsPDFWithFontStatus\r\n): (string | number)[][] {\r\n    if (!data) return [];\r\n\r\n    // Roboto font yüklüyse transliterate yapma\r\n    if (doc && doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n        return data; // Return original data\r\n    }\r\n\r\n    return data.map(row =>\r\n        row.map(cell =>\r\n            typeof cell === 'string' ? transliterateTurkish(cell) : cell\r\n        )\r\n    );\r\n}\r\n\r\n/**\r\n * PDF Template oluştur\r\n */\r\nexport function createPDFTemplate(doc: jsPDFWithFontStatus): PDFTemplateLayout {\r\n    const pageWidth = doc.internal.pageSize.getWidth();\r\n    const pageHeight = doc.internal.pageSize.getHeight();\r\n\r\n    return {\r\n        background: {\r\n            startY: 0,\r\n            endY: pageHeight,\r\n        },\r\n        header: {\r\n            startY: 0,\r\n            endY: PDF_CONSTANTS.headerHeight,\r\n            logoX: PDF_CONSTANTS.margin,\r\n            logoY: 30,\r\n            titleX: PDF_CONSTANTS.margin + PDF_CONSTANTS.logoSize + 20,\r\n            titleY: 45,\r\n        },\r\n        contentArea: {\r\n            startY: PDF_CONSTANTS.headerHeight + 20,\r\n            endY: pageHeight - PDF_CONSTANTS.footerHeight - 20,\r\n            width: pageWidth - (PDF_CONSTANTS.margin * 2),\r\n            leftMargin: PDF_CONSTANTS.margin,\r\n            rightMargin: pageWidth - PDF_CONSTANTS.margin,\r\n        },\r\n    };\r\n}\r\n\r\n/**\r\n * Kart boyutlarını hesapla\r\n */\r\nexport function calculateCardDimensions(\r\n    contentWidth: number,\r\n    cardCount: number\r\n): { width: number; gap: number } {\r\n    const gap = 16;\r\n    const totalGaps = (cardCount - 1) * gap;\r\n    const width = (contentWidth - totalGaps) / cardCount;\r\n    return { width, gap };\r\n}\r\n\r\n/**\r\n * Para birimi formatla\r\n */\r\nexport function formatCurrency(value: number, currency = \"₺\"): string {\r\n    return `${currency}${value.toLocaleString('tr-TR', {\r\n        minimumFractionDigits: 2,\r\n        maximumFractionDigits: 2\r\n    })}`;\r\n}\r\n\r\n/**\r\n * Güvenli sayı dönüşümü\r\n */\r\nexport function safeNumber(value: unknown): number {\r\n    if (typeof value === 'number') return value;\r\n    if (typeof value === 'string') {\r\n        const parsed = parseFloat(value);\r\n        return isNaN(parsed) ? 0 : parsed;\r\n    }\r\n    return 0;\r\n}\r\n\r\n/**\r\n * Güvenli para birimi formatı\r\n */\r\nexport function safeFormatCurrency(value: number): string {\r\n    if (typeof value !== 'number' || isNaN(value)) {\r\n        return '₺0,00';\r\n    }\r\n    return formatCurrency(value);\r\n}\r\n\r\n/**\r\n * Tarih formatla\r\n */\r\nexport function formatDate(dateStr: string): string {\r\n    try {\r\n        const date = new Date(dateStr);\r\n        if (isNaN(date.getTime())) return dateStr;\r\n\r\n        const months = [\r\n            'Ocak', 'Şubat', 'Mart', 'Nisan', 'Mayıs', 'Haziran',\r\n            'Temmuz', 'Ağustos', 'Eylül', 'Ekim', 'Kasım', 'Aralık'\r\n        ];\r\n\r\n        const day = date.getDate();\r\n        const month = months[date.getMonth()];\r\n        const year = date.getFullYear();\r\n\r\n        return `${day} ${month} ${year}`;\r\n    } catch {\r\n        return dateStr;\r\n    }\r\n}\r\n\r\n/**\r\n * Kısa tarih formatı\r\n */\r\nexport function formatDateShort(dateStr: string): string {\r\n    try {\r\n        const date = new Date(dateStr);\r\n        if (isNaN(date.getTime())) return dateStr;\r\n        return date.toLocaleDateString('tr-TR');\r\n    } catch {\r\n        return dateStr;\r\n    }\r\n}\r\n\r\n/**\r\n * PDF oluştur\r\n */\r\nexport function createPdf(\r\n    options: jsPDFOptions = { format: \"a4\", unit: \"pt\" }\r\n): jsPDFWithFontStatus {\r\n    return new jsPDF(options) as jsPDFWithFontStatus;\r\n}\r\n\r\n/**\r\n * Sayfa sığmazsa yeni sayfa ekle\r\n */\r\nexport function ensureSpace(\r\n    doc: jsPDF,\r\n    currentY: number,\r\n    requiredHeight: number,\r\n    margin = 40,\r\n    titleForNextPage?: string\r\n): number {\r\n    const pageHeight = doc.internal.pageSize.getHeight();\r\n\r\n    if (currentY + requiredHeight > pageHeight - margin) {\r\n        doc.addPage();\r\n        let newY = margin;\r\n\r\n        if (titleForNextPage) {\r\n            doc.setFontSize(12);\r\n            doc.text(titleForNextPage + \" (devam)\", margin, newY);\r\n            newY += 20;\r\n        }\r\n\r\n        return newY;\r\n    }\r\n\r\n    return currentY;\r\n}\r\n\r\n// Re-export for convenience\r\nexport { REV_LOGO_DATA_URI };\r\n\r\nimport { ROBOTO_REGULAR_BASE64, ROBOTO_BOLD_BASE64 } from \"@/assets/fonts/roboto-base64\";\r\n\r\nexport const isRobotoName = (fontName?: string): boolean => {\r\n    if (!fontName) return false;\r\n    return fontName.toLowerCase().includes(\"roboto\");\r\n};\r\n\r\n// Güçlendirilmiş Font Yönetimi\r\nexport const registerFonts = async (doc: jsPDFWithFontStatus) => {\r\n    // Eğer font zaten yüklendiyse tekrar yükleme\r\n    if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n        // Font'un gerçekten yüklü olduğunu doğrula\r\n        try {\r\n            const currentFont = doc.getFont();\r\n            if (currentFont && isRobotoName(currentFont.fontName)) {\r\n                // Font yüklü, Türkçe karakter desteğini test et\r\n                try {\r\n                    doc.setFontSize(12);\r\n                    doc.text(\"İğüşöç\", -1000, -1000);\r\n                    return; // Font zaten yüklü ve çalışıyor\r\n                } catch (testError) {\r\n                    // Türkçe karakter testi başarısız, ama font yüklü olabilir\r\n                    // Font'u yeniden yükle\r\n                    doc._robotoFontLoaded = false;\r\n                }\r\n            } else {\r\n                // Font yüklü değil, yeniden yükle\r\n                doc._robotoFontLoaded = false;\r\n            }\r\n        } catch {\r\n            // Font kontrolü başarısız, yeniden yükle\r\n            doc._robotoFontLoaded = false;\r\n        }\r\n    }\r\n\r\n    // Eğer daha önce yükleme başarısız olduysa, tekrar dene (flag'i reset et)\r\n    if (doc._robotoFontLoadFailed) {\r\n        // Bir kez daha deneme şansı ver\r\n        doc._robotoFontLoadFailed = false;\r\n        // Devam et, font yükleme işlemini tekrar dene\r\n    }\r\n\r\n    // Font string'lerinin kesilmiş olup olmadığını kontrol et\r\n    if (ROBOTO_REGULAR_BASE64.endsWith('...') || ROBOTO_BOLD_BASE64.endsWith('...') ||\r\n        ROBOTO_REGULAR_BASE64.length < 1000 || ROBOTO_BOLD_BASE64.length < 1000) {\r\n        doc.setFont(\"helvetica\", \"normal\");\r\n        doc._robotoFontLoaded = false;\r\n        doc._robotoFontLoadFailed = true;\r\n        return;\r\n    }\r\n\r\n    try {\r\n        // Base64 string'lerin düzgün formatta olduğundan emin ol\r\n        let cleanRegular = ROBOTO_REGULAR_BASE64.replace(/^data:.*?,/, '').trim();\r\n        let cleanBold = ROBOTO_BOLD_BASE64.replace(/^data:.*?,/, '').trim();\r\n\r\n        cleanRegular = cleanRegular.replace(/\\.\\.\\.$/, '').trim();\r\n        cleanBold = cleanBold.replace(/\\.\\.\\.$/, '').trim();\r\n\r\n        if (!cleanRegular || !cleanBold || cleanRegular.length === 0 || cleanBold.length === 0) {\r\n            throw new Error(\"Font base64 string'leri boş\");\r\n        }\r\n\r\n        cleanRegular = cleanRegular.replace(/\\s+/g, '');\r\n        cleanBold = cleanBold.replace(/\\s+/g, '');\r\n\r\n        cleanRegular = cleanRegular.replace(/[^A-Za-z0-9+/=]/g, '');\r\n        cleanBold = cleanBold.replace(/[^A-Za-z0-9+/=]/g, '');\r\n\r\n        const regularPadding = (4 - (cleanRegular.length % 4)) % 4;\r\n        const boldPadding = (4 - (cleanBold.length % 4)) % 4;\r\n        cleanRegular += '='.repeat(regularPadding);\r\n        cleanBold += '='.repeat(boldPadding);\r\n\r\n        if (cleanRegular.length === 0 || cleanBold.length === 0) {\r\n            throw new Error(\"Font base64 string'leri boş\");\r\n        }\r\n\r\n        // Add to VFS\r\n        try {\r\n            doc.addFileToVFS(\"Roboto-Regular.ttf\", cleanRegular);\r\n            doc.addFileToVFS(\"Roboto-Bold.ttf\", cleanBold);\r\n        } catch (vfsError) {\r\n            throw new Error(\"Font VFS'e eklenemedi: \" + vfsError);\r\n        }\r\n\r\n        // Add fonts\r\n        try {\r\n            doc.addFont(\"Roboto-Regular.ttf\", \"Roboto\", \"normal\");\r\n            const fontListAfterRegular = doc.getFontList();\r\n            const hasRobotoRegular = fontListAfterRegular && Object.keys(fontListAfterRegular).some((key) => isRobotoName(key));\r\n\r\n            if (!hasRobotoRegular) {\r\n                throw new Error(\"Roboto Regular font eklenemedi\");\r\n            }\r\n\r\n            doc.addFont(\"Roboto-Bold.ttf\", \"Roboto\", \"bold\");\r\n        } catch (addFontError) {\r\n            throw new Error(\"Font eklenemedi: \" + addFontError);\r\n        }\r\n\r\n        // Set default font ve test et\r\n        try {\r\n            doc.setFont(\"Roboto\", \"normal\");\r\n            doc._robotoFontLoaded = true;\r\n            doc._robotoFontLoadFailed = false;\r\n        } catch (setFontError) {\r\n            throw new Error(\"Font ayarlanamadı: \" + setFontError);\r\n        }\r\n\r\n    } catch (error) {\r\n        console.error(\"Font yükleme hatası:\", error);\r\n        doc.setFont(\"helvetica\", \"normal\");\r\n        doc._robotoFontLoaded = false;\r\n        doc._robotoFontLoadFailed = true;\r\n    }\r\n};\r\n\r\nexport const createSafeText = (doc: jsPDFWithFontStatus) => {\r\n    // Roboto font Türkçe karakterleri destekliyor\r\n    // Sadece Helvetica kullanılırken transliterate et\r\n    return (text: string, x: number, y: number, fontSize: number, isBold: boolean = false) => {\r\n        // null/undefined kontrolü\r\n        if (text == null || text === '') {\r\n            return;\r\n        }\r\n\r\n        const textStr = String(text);\r\n\r\n        // ÖNCE translitere edilmiş versiyonu hazırla (yedek olarak)\r\n        const transliteratedText = transliterateTurkish(textStr);\r\n\r\n        // Font yüklenmemişse veya yükleme başarısızsa direkt helvetica kullan ve transliterate et\r\n        if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\r\n            try {\r\n                doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\r\n                doc.setFontSize(fontSize);\r\n                doc.text(transliteratedText, x, y);\r\n            } catch (error: unknown) {\r\n                // Hata durumunda sessizce devam et - ama loglayalım\r\n                console.warn('createSafeText: Helvetica ile yazılamadı:', error);\r\n            }\r\n            return;\r\n        }\r\n\r\n        // Roboto kullanmayı dene\r\n        let robotoSuccess = false;\r\n        try {\r\n            doc.setFont(\"Roboto\", isBold ? \"bold\" : \"normal\");\r\n            doc.setFontSize(fontSize);\r\n            const currentFont = doc.getFont();\r\n\r\n            if (currentFont && isRobotoName(currentFont.fontName)) {\r\n                // Roboto font başarıyla ayarlandı, Türkçe karakterleri koruyarak yaz\r\n                try {\r\n                    doc.text(textStr, x, y);\r\n                    robotoSuccess = true;\r\n                } catch (writeError) {\r\n                    // Text yazma hatası - robotoSuccess false kalacak, fallback'e geçilecek\r\n                    console.warn('createSafeText: Roboto textStr yazılamadı, fallback deneniyor:', writeError);\r\n                }\r\n            }\r\n        } catch (fontError) {\r\n            // Font ayarlama hatası\r\n            console.warn('createSafeText: Roboto font ayarlanamadı:', fontError);\r\n        }\r\n\r\n        // Roboto başarısız olduysa, Helvetica ile translitere edilmiş text'i yaz\r\n        if (!robotoSuccess) {\r\n            try {\r\n                doc.setFont(\"helvetica\", isBold ? \"bold\" : \"normal\");\r\n                doc.setFontSize(fontSize);\r\n                doc.text(transliteratedText, x, y);\r\n            } catch (fallbackError) {\r\n                // Son çare: loglayıp devam et\r\n                console.error('createSafeText: Fallback da başarısız:', fallbackError);\r\n            }\r\n        }\r\n    };\r\n};\r\n\r\nexport const forceRobotoFont = (doc: jsPDFWithFontStatus, style: \"normal\" | \"bold\" = \"normal\") => {\r\n    if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n        for (let i = 0; i < 10; i++) {\r\n            try {\r\n                doc.setFont(\"Roboto\", style);\r\n                const currentFont = doc.getFont();\r\n                if (currentFont && isRobotoName(currentFont.fontName)) {\r\n                    return true;\r\n                }\r\n            } catch {\r\n                // Tekrar dene\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n};\r\n\r\nexport const safeSetFont = (doc: jsPDFWithFontStatus, style: \"normal\" | \"bold\" = \"normal\") => {\r\n    if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\r\n        try {\r\n            doc.setFont(\"helvetica\", style);\r\n        } catch {\r\n            // ignore\r\n        }\r\n        return;\r\n    }\r\n\r\n    let attempts = 0;\r\n    let fontSet = false;\r\n    const maxAttempts = 3;\r\n\r\n    while (attempts < maxAttempts && !fontSet) {\r\n        try {\r\n            doc.setFont(\"Roboto\", style);\r\n            const currentFont = doc.getFont();\r\n            if (currentFont && isRobotoName(currentFont.fontName)) {\r\n                try {\r\n                    doc.setFontSize(12);\r\n                    doc.text(\"İğüşöç\", -1000, -1000);\r\n                    fontSet = true;\r\n                    break;\r\n                } catch (testError) {\r\n                    // ignore\r\n                }\r\n            }\r\n            attempts++;\r\n        } catch (error) {\r\n            attempts++;\r\n        }\r\n    }\r\n\r\n    if (!fontSet) {\r\n        try {\r\n            doc.setFont(\"helvetica\", style);\r\n            doc._robotoFontLoaded = false;\r\n            doc._robotoFontLoadFailed = true;\r\n        } catch {\r\n            // ignore\r\n        }\r\n    }\r\n};\r\n\r\nexport const createWillDrawCell = (doc: jsPDFWithFontStatus) => {\r\n    return (data: AutoTableCellHookData) => {\r\n        if (!data.cell) return;\r\n\r\n        // Cast cell to any to avoid strict type checks on styles and fontStyle which might not match exact types\r\n        const cell = data.cell as any;\r\n        const fontStyle = (cell.fontStyle === \"bold\" || cell.styles?.fontStyle === \"bold\" || cell.styles?.font === \"bold\") ? \"bold\" : \"normal\";\r\n\r\n        if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n            try {\r\n                safeSetFont(doc, fontStyle);\r\n                if (!cell.styles) {\r\n                    cell.styles = {};\r\n                }\r\n                cell.styles.font = \"Roboto\";\r\n                cell.styles.fontStyle = fontStyle;\r\n            } catch {\r\n                if (!cell.styles) cell.styles = {};\r\n                cell.styles.font = \"helvetica\";\r\n                cell.styles.fontStyle = fontStyle;\r\n            }\r\n        } else {\r\n            if (!cell.styles) cell.styles = {};\r\n            cell.styles.font = \"helvetica\";\r\n            cell.styles.fontStyle = fontStyle;\r\n\r\n            if (cell.text) {\r\n                if (typeof cell.text === 'string') {\r\n                    cell.text = transliterateTurkish(cell.text);\r\n                } else if (Array.isArray(cell.text)) {\r\n                    cell.text = (cell.text as string[]).map((t: string) => transliterateTurkish(t));\r\n                }\r\n            }\r\n        }\r\n    };\r\n};\r\n\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\pdf\\pdfDrawing.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\aslan\\Downloads\\revium-erp-suite-main\\revium-erp-suite-main\\src\\services\\pdf\\pdfProductionReport.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'nextY' is never reassigned. Use 'const' instead.","line":67,"column":13,"nodeType":"Identifier","messageId":"useConst","endLine":67,"endColumn":18,"fix":{"range":[1710,1734],"text":"const nextY = margin + 30;"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":363,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":363,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14168,14171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14168,14171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":364,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14233,14236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14233,14236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":1,"fixableWarningCount":0,"source":"import jsPDF from \"jspdf\";\r\nimport autoTable from \"jspdf-autotable\";\r\nimport {\r\n    createPdf,\r\n    registerFonts,\r\n    formatDate,\r\n    PDF_CONSTANTS,\r\n    TAILWIND_COLORS,\r\n    createSafeText,\r\n    createPDFTemplate,\r\n    calculateCardDimensions,\r\n    safeNumber,\r\n    ensureSpace,\r\n    isRobotoName,\r\n    jsPDFWithFontStatus,\r\n    PDFTemplateLayout,\r\n    transliterateTurkish,\r\n    transliterateTableData,\r\n    forceRobotoFont,\r\n    safeSetFont,\r\n    createWillDrawCell\r\n} from \"./pdfCore\";\r\n\r\nimport {\r\n    applyPDFTemplate,\r\n    drawStatCard,\r\n    drawProfessionalTableHeader,\r\n    drawPDFBackground,\r\n    drawSummarySection,\r\n    drawPDFFooter,\r\n    createProfessionalTableStyles\r\n} from \"./pdfDrawing\";\r\n\r\n// Types derived from the component\r\nexport type ProductionStatus = \"planned\" | \"in_production\" | \"quality_check\" | \"completed\" | \"on_hold\";\r\nexport type StatusDistribution = Record<ProductionStatus, number>;\r\n\r\nexport interface ProductProductionStat {\r\n    name: string;\r\n    quantity: number;\r\n    orders: number;\r\n}\r\n\r\nexport interface ProductionReportData {\r\n    totalOrders: number;\r\n    completed: number;\r\n    completionRate: number;\r\n    statusDistribution: StatusDistribution;\r\n    topProducts: ProductProductionStat[];\r\n}\r\n\r\n\r\n\r\nconst ensureTableFitsPage = (\r\n    doc: jsPDFWithFontStatus,\r\n    currentY: number,\r\n    requiredHeight: number,\r\n    margin: number = 40,\r\n    titleForNextPage?: string\r\n): number => {\r\n    const pageHeight = doc.internal.pageSize.getHeight();\r\n    const footerHeight = PDF_CONSTANTS.footerHeight;\r\n    const minSpaceNeeded = requiredHeight + 70;\r\n\r\n    if (currentY + minSpaceNeeded > pageHeight - footerHeight - margin) {\r\n        doc.addPage();\r\n        let nextY = margin + 30;\r\n        const template = createPDFTemplate(doc);\r\n        drawPDFBackground(doc, template);\r\n        return nextY;\r\n    }\r\n    return currentY;\r\n};\r\n\r\n\r\nexport const generateProductionReportPDF = async (data: ProductionReportData, startDate: string, endDate: string) => {\r\n    const doc = createPdf({ format: \"a4\", unit: \"pt\" });\r\n\r\n    try {\r\n        await registerFonts(doc);\r\n    } catch (fontError) {\r\n        console.warn(\"Font yüklenirken hata oluştu:\", fontError);\r\n    }\r\n\r\n    if (!doc._robotoFontLoaded || doc._robotoFontLoadFailed) {\r\n        // Retry logic could be here\r\n    }\r\n\r\n    if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n        forceRobotoFont(doc, \"normal\");\r\n    }\r\n\r\n    const reportDate = formatDate(new Date().toISOString());\r\n\r\n    const template = applyPDFTemplate(doc, \"ÜRETİM RAPORU\", reportDate, startDate, endDate);\r\n\r\n    if (doc._robotoFontLoaded && !doc._robotoFontLoadFailed) {\r\n        forceRobotoFont(doc, \"normal\");\r\n    }\r\n\r\n    let currentY = template.contentArea.startY;\r\n    const contentWidth = template.contentArea.width;\r\n    const mar = template.contentArea.leftMargin;\r\n\r\n    const cardWidth = (contentWidth - 32) / 3;\r\n    const cardHeight = 110;\r\n    const cardGap = 16;\r\n    let cardX = mar;\r\n\r\n    const totalOrders = safeNumber(data.totalOrders);\r\n    drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\r\n        title: \"Toplam Sipariş\",\r\n        value: totalOrders.toString(),\r\n        description: \"Tarih aralığında\",\r\n        color: {\r\n            background: TAILWIND_COLORS.infoCardBg,\r\n            border: TAILWIND_COLORS.infoCardBorder,\r\n            text: TAILWIND_COLORS.cardText,\r\n            value: TAILWIND_COLORS.infoCardValue,\r\n        },\r\n    });\r\n\r\n    cardX += cardWidth + cardGap;\r\n    const completed = safeNumber(data.completed);\r\n    drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\r\n        title: \"Tamamlanan\",\r\n        value: completed.toString(),\r\n        description: \"Başarıyla tamamlandı\",\r\n        color: {\r\n            background: TAILWIND_COLORS.successCardBg,\r\n            border: TAILWIND_COLORS.successCardBorder,\r\n            text: TAILWIND_COLORS.cardText,\r\n            value: TAILWIND_COLORS.successCardValue,\r\n        },\r\n    });\r\n\r\n    cardX += cardWidth + cardGap;\r\n    const completionRate = safeNumber(data.completionRate);\r\n    drawStatCard(doc, cardX, currentY, cardWidth, cardHeight, {\r\n        title: \"Tamamlanma Oranı\",\r\n        value: `${completionRate.toFixed(1)}%`,\r\n        description: \"Başarı oranı\",\r\n        color: {\r\n            background: TAILWIND_COLORS.primaryCardBg,\r\n            border: TAILWIND_COLORS.primaryCardBorder,\r\n            text: TAILWIND_COLORS.cardText,\r\n            value: TAILWIND_COLORS.primaryCardValue,\r\n        },\r\n    });\r\n\r\n    currentY += cardHeight + PDF_CONSTANTS.sectionSpacing;\r\n\r\n    if (data.statusDistribution) {\r\n        currentY = ensureSpace(doc, currentY, 200, mar, \"Durum Dağılımı\");\r\n        currentY = drawProfessionalTableHeader(doc, mar, currentY, 250, {\r\n            title: \"Durum Dağılımı\",\r\n            backgroundColor: [249, 250, 251],\r\n            textColor: PDF_CONSTANTS.primaryColor,\r\n            borderColor: PDF_CONSTANTS.primaryColor,\r\n        });\r\n\r\n        const statusLabels: Record<string, string> = {\r\n            planned: \"Planlandı\",\r\n            in_production: \"Üretimde\",\r\n            quality_check: \"Kalite Kontrol\",\r\n            completed: \"Tamamlandı\",\r\n            on_hold: \"Beklemede\"\r\n        };\r\n\r\n        const statusData = Object.entries(data.statusDistribution)\r\n            .filter(([_, value]) => safeNumber(value as number) > 0)\r\n            .sort((a, b) => safeNumber(b[1] as number) - safeNumber(a[1] as number))\r\n            .map(([key, value]) => {\r\n                const count = safeNumber(value as number);\r\n                const percentage = totalOrders > 0 ? `${((count / totalOrders) * 100).toFixed(1)}%` : \"0%\";\r\n                return [\r\n                    statusLabels[key] || key,\r\n                    count.toString(),\r\n                    percentage\r\n                ];\r\n            });\r\n\r\n        const tableStyles = createProfessionalTableStyles(doc, {\r\n            headerFontSize: 12,\r\n            bodyFontSize: 11,\r\n            cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\r\n        });\r\n        tableStyles.headStyles.fillColor = PDF_CONSTANTS.primaryColor;\r\n        tableStyles.headStyles.textColor = [255, 255, 255];\r\n        tableStyles.headStyles.halign = \"center\" as const;\r\n        tableStyles.bodyStyles.overflow = 'linebreak';\r\n        tableStyles.styles.overflow = 'linebreak';\r\n\r\n        currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Durum Dağılımı\");\r\n        const currentPageWidth = doc.internal.pageSize.getWidth();\r\n        const tableWidth = currentPageWidth - (mar * 2);\r\n\r\n        forceRobotoFont(doc, \"normal\");\r\n\r\n        autoTable(doc, {\r\n            startY: currentY,\r\n            head: transliterateTableData([['Durum', 'Sipariş Sayısı', 'Oran']], doc),\r\n            body: transliterateTableData(statusData, doc),\r\n            margin: { left: mar, right: mar },\r\n            tableWidth: tableWidth,\r\n            willDrawCell: createWillDrawCell(doc),\r\n            ...tableStyles,\r\n            columnStyles: {\r\n                0: { cellWidth: tableWidth * 0.50, halign: \"left\", overflow: 'linebreak' },\r\n                1: { cellWidth: tableWidth * 0.25, halign: \"right\", fontStyle: \"bold\" },\r\n                2: { cellWidth: tableWidth * 0.25, halign: \"right\", fontStyle: \"bold\", textColor: [107, 114, 128] },\r\n            },\r\n        });\r\n\r\n        const tableEndY = doc.lastAutoTable?.finalY;\r\n        if (tableEndY && tableEndY > currentY) {\r\n            currentY = tableEndY + PDF_CONSTANTS.tableSpacing;\r\n        } else {\r\n            currentY += PDF_CONSTANTS.tableSpacing;\r\n        }\r\n    }\r\n\r\n    if (data.topProducts && data.topProducts.length > 0) {\r\n        const pageWidthProd = doc.internal.pageSize.getWidth();\r\n        const tableWidthProd = pageWidthProd - (mar * 2);\r\n\r\n        currentY = ensureSpace(doc, currentY, 200, mar, \"En Çok Üretilen Ürünler\");\r\n        currentY = drawProfessionalTableHeader(doc, mar, currentY, tableWidthProd, {\r\n            title: \"En Çok Üretilen Ürünler\",\r\n            backgroundColor: [249, 250, 251],\r\n            textColor: PDF_CONSTANTS.primaryColor,\r\n            borderColor: PDF_CONSTANTS.primaryColor,\r\n        });\r\n\r\n        const topProductsData = data.topProducts?.slice(0, 10).map((p, index: number) => [\r\n            `#${index + 1}`,\r\n            p.name || '-',\r\n            safeNumber(p.quantity).toString(),\r\n            safeNumber(p.orders).toString()\r\n        ]);\r\n\r\n        const totalQuantity = data.topProducts?.slice(0, 10).reduce((sum: number, p) => sum + safeNumber(p.quantity), 0) || 0;\r\n        const totalOrdersProd = data.topProducts?.slice(0, 10).reduce((sum: number, p) => sum + safeNumber(p.orders), 0) || 0;\r\n        topProductsData.push([\r\n            'TOPLAM',\r\n            '',\r\n            totalQuantity.toString(),\r\n            totalOrdersProd.toString()\r\n        ]);\r\n\r\n        const tableStyles2 = createProfessionalTableStyles(doc, {\r\n            headerFontSize: 12,\r\n            bodyFontSize: 11,\r\n            cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\r\n        });\r\n        tableStyles2.headStyles.fillColor = [59, 130, 246];\r\n        tableStyles2.headStyles.textColor = [255, 255, 255];\r\n        tableStyles2.headStyles.halign = \"center\" as const;\r\n        tableStyles2.bodyStyles.overflow = 'linebreak';\r\n        tableStyles2.styles.overflow = 'linebreak';\r\n\r\n        currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"En Çok Üretilen Ürünler\");\r\n        const currentPageWidth2 = doc.internal.pageSize.getWidth();\r\n        const tableWidth2 = currentPageWidth2 - (mar * 2);\r\n\r\n        forceRobotoFont(doc, \"normal\");\r\n\r\n        autoTable(doc, {\r\n            startY: currentY,\r\n            head: transliterateTableData([['Sıra', 'Ürün Adı', 'Miktar', 'Sipariş Sayısı']], doc),\r\n            body: transliterateTableData(topProductsData, doc),\r\n            margin: { left: mar, right: mar },\r\n            tableWidth: tableWidth2,\r\n            willDrawCell: createWillDrawCell(doc),\r\n            ...tableStyles2,\r\n            columnStyles: {\r\n                0: { cellWidth: tableWidth2 * 0.10, halign: \"left\", textColor: [107, 114, 128] },\r\n                1: { cellWidth: tableWidth2 * 0.50, halign: \"left\", overflow: 'linebreak' },\r\n                2: { cellWidth: tableWidth2 * 0.20, halign: \"right\", fontStyle: \"bold\" },\r\n                3: { cellWidth: tableWidth2 * 0.20, halign: \"right\", fontStyle: \"bold\" },\r\n            },\r\n        });\r\n\r\n        const tableEndY = doc.lastAutoTable?.finalY;\r\n        if (tableEndY && tableEndY > currentY) {\r\n            currentY = tableEndY + PDF_CONSTANTS.tableSpacing;\r\n        } else {\r\n            currentY += PDF_CONSTANTS.tableSpacing;\r\n        }\r\n    }\r\n\r\n    if (data.topProducts && data.topProducts.length > 0) {\r\n        currentY = ensureSpace(doc, currentY, 200, mar, \"Üretim Verimliliği\");\r\n\r\n        const efficiencyData = data.topProducts?.slice(0, 10).map((p, index: number) => {\r\n            const quantity = safeNumber(p.quantity);\r\n            const orders = safeNumber(p.orders);\r\n            const avgPerOrder = orders > 0 ? (quantity / orders).toFixed(1) : \"0\";\r\n            const productName = (p.name || '-').length > 25 ? (p.name || '-').substring(0, 25) + \"...\" : (p.name || '-');\r\n            return [\r\n                `#${index + 1}`,\r\n                productName,\r\n                quantity.toString(),\r\n                orders.toString(),\r\n                avgPerOrder\r\n            ];\r\n        });\r\n\r\n        const pageWidth3 = doc.internal.pageSize.getWidth();\r\n        const tableWidth3 = pageWidth3 - (mar * 2);\r\n\r\n        currentY = ensureSpace(doc, currentY, 200, mar, \"Ürün Bazlı Üretim Verimliliği\");\r\n        currentY = drawProfessionalTableHeader(doc, mar, currentY, tableWidth3, {\r\n            title: \"Ürün Bazlı Üretim Verimliliği\",\r\n            backgroundColor: [249, 250, 251],\r\n            textColor: PDF_CONSTANTS.primaryColor,\r\n            borderColor: PDF_CONSTANTS.primaryColor,\r\n        });\r\n\r\n        const tableStyles3 = createProfessionalTableStyles(doc, {\r\n            headerFontSize: 12,\r\n            bodyFontSize: 11,\r\n            cellPadding: { top: 12, right: 14, bottom: 12, left: 14 }\r\n        });\r\n        tableStyles3.headStyles.fillColor = [59, 130, 246];\r\n        tableStyles3.headStyles.textColor = [255, 255, 255];\r\n        tableStyles3.headStyles.halign = \"center\" as const;\r\n        tableStyles3.bodyStyles.overflow = 'linebreak';\r\n        tableStyles3.styles.overflow = 'linebreak';\r\n\r\n        currentY = ensureTableFitsPage(doc, currentY, 200, mar, \"Ürün Bazlı Üretim Verimliliği\");\r\n        const currentPageWidth3 = doc.internal.pageSize.getWidth();\r\n        const currentTableWidth3 = currentPageWidth3 - (mar * 2);\r\n\r\n        autoTable(doc, {\r\n            startY: currentY,\r\n            head: transliterateTableData([['Sıra', 'Ürün', 'Toplam Miktar', 'Sipariş', 'Ortalama/Sipariş']], doc),\r\n            body: transliterateTableData(efficiencyData, doc),\r\n            margin: { left: mar, right: mar },\r\n            tableWidth: currentTableWidth3,\r\n            willDrawCell: createWillDrawCell(doc),\r\n            ...tableStyles3,\r\n            columnStyles: {\r\n                0: { cellWidth: currentTableWidth3 * 0.08, halign: \"left\", textColor: [107, 114, 128] },\r\n                1: { cellWidth: currentTableWidth3 * 0.40, halign: \"left\", overflow: 'linebreak' },\r\n                2: { cellWidth: currentTableWidth3 * 0.18, halign: \"right\", fontStyle: \"bold\" },\r\n                3: { cellWidth: currentTableWidth3 * 0.15, halign: \"right\", fontStyle: \"bold\" },\r\n                4: { cellWidth: currentTableWidth3 * 0.19, halign: \"right\", textColor: [107, 114, 128] },\r\n            },\r\n        });\r\n\r\n        const tableEndY = doc.lastAutoTable?.finalY;\r\n        if (tableEndY && tableEndY > currentY) {\r\n            currentY = tableEndY + PDF_CONSTANTS.tableSpacing;\r\n        } else {\r\n            currentY += PDF_CONSTANTS.tableSpacing;\r\n        }\r\n    }\r\n\r\n    currentY = (doc.lastAutoTable?.finalY || currentY) + 50;\r\n    currentY = ensureSpace(doc, currentY, 100, mar, \"Özet\");\r\n\r\n    const onHold = safeNumber((data as any).onHold || 0);\r\n    const inProduction = safeNumber((data as any).inProduction || 0);\r\n    const planned = safeNumber(data.statusDistribution?.planned || 0);\r\n    const qualityCheck = safeNumber(data.statusDistribution?.quality_check || 0);\r\n\r\n    const summaryData: Array<[string, string]> = [\r\n        ['Toplam Sipariş', totalOrders.toString()],\r\n        ['Tamamlanan', completed.toString()],\r\n        ['Tamamlanma Oranı', `${completionRate.toFixed(1)}%`],\r\n        ['Beklemede', onHold.toString()],\r\n        ['Üretimde', inProduction.toString()],\r\n        ['Planlandı', planned.toString()],\r\n        ['Kalite Kontrol', qualityCheck.toString()],\r\n        ['En Çok Üretilen Ürün Sayısı', data.topProducts ? data.topProducts.length.toString() : \"0\"],\r\n    ];\r\n\r\n    currentY = drawSummarySection(doc, mar, currentY, contentWidth, \"Rapor Özeti\", summaryData, [37, 99, 235]);\r\n\r\n    try {\r\n        const totalPages = doc.internal.pages.length - 1;\r\n        if (totalPages > 0) {\r\n            for (let i = 1; i <= totalPages; i++) {\r\n                try {\r\n                    doc.setPage(i);\r\n                    const pageTemplate = createPDFTemplate(doc);\r\n                    drawPDFFooter(doc, pageTemplate, i, totalPages);\r\n                } catch (pageError) {\r\n                    // ignore\r\n                }\r\n            }\r\n        }\r\n    } catch (footerError) {\r\n        // ignore\r\n    }\r\n\r\n    try {\r\n        const blob = doc.output('blob');\r\n        if (!blob || blob.size === 0) {\r\n            throw new Error(\"PDF blob boş veya geçersiz\");\r\n        }\r\n        return blob;\r\n    } catch (outputError) {\r\n        throw new Error(\"PDF oluşturulamadı: \" + (outputError instanceof Error ? outputError.message : \"Bilinmeyen hata\"));\r\n    }\r\n};\r\n","usedDeprecatedRules":[]}]